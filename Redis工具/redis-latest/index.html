<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Redis 命令参考</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/badge_only.css" type="text/css" />
    <link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-2.0.3.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-migrate-1.2.1.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/underscore.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/doctools.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/readthedocs-doc-embed.js"></script>
    <link rel="top" title="None" href="index.html#document-index" />
 

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


<!-- RTD Extra Head -->



<!-- 
Read the Docs is acting as the canonical URL for your project. 
If you want to change it, more info is available in our docs:
  http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://redis.readthedocs.org/en/latest/" />

<script type="text/javascript">
  // This is included here because other places don't have access to the pagename variable.
  var READTHEDOCS_DATA = {
    project: "redis",
    version: "latest",
    language: "en",
    page: "index",
    theme: "der",
    docroot: "/",
    source_suffix: ".rst",
    api_host: "https://readthedocs.org",
    commit: "f9038ef91e07a09e0a2131edab763bd771859ca0"
  }
  // Old variables
  var doc_version = "latest";
  var doc_slug = "redis";
  var page_name = "index";
  var html_theme = "der";
</script>
<!-- RTD Analytics Code -->
<!-- Included in the header because you don't have a footer block. -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  // User Analytics Code
  _gaq.push(['user._setAccount', 'UA-53959484-7']);
  _gaq.push(['user._trackPageview']);
  // End User Analytics Code


  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- end RTD Analytics Code -->
<!-- end RTD <extrahead> -->

  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html#document-index">Redis 命令参考</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="redis">
<h1>Redis 命令参考<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h1>
<p>本文档是 <a class="reference external" href="http://redis.io/commands">Redis Command Reference</a> 和 <a class="reference external" href="http://redis.io/documentation">Redis Documentation</a> 的中文翻译版：
所有 Redis 命令文档均已翻译完毕，
Redis 最重要的一部分主题（topic）文档，
比如事务、持久化、复制、Sentinel、集群等文章也已翻译完毕。</p>
<p>文档目前描述的内容以 Redis 2.8 版本为准，
查看<a class="reference internal" href="index.html#change-log"><em>更新日志(change log)</em></a>可以了解本文档对 Redis 2.8 所做的更新。</p>
<p>你可以通过网址 <a class="reference external" href="http://www.redisdoc.com">www.RedisDoc.com</a> 在线阅览本文档，
也可以下载 <a class="reference external" href="https://raw.github.com/huangz1990/redis/master/download/redis.pdf">PDF 格式</a> 或者 <a class="reference external" href="http://media.readthedocs.org/htmlzip/redis/latest/redis.zip">HTML 格式</a> 的离线版本。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<a class="reference internal image-reference" href="_images/cover.jpg"><img alt="_images/cover.jpg" class="align-left" src="_images/cover.jpg" style="width: 83.43px; height: 116.64px;" /></a>
<p>由本文档的翻译者 huangz 创作的《Redis 设计与实现》一书正在销售中，
该书详细地介绍了 Redis 内部的运作原理以及各项功能的实现原理，
是一本致力于帮助 Redis 使用者加深对 Redis 的理解，
并且更高效地使用 Redis 的书籍。</p>
<p class="last">欢迎访问 <a class="reference external" href="http://www.RedisBook.com">RedisBook.com</a> 并了解《Redis 设计与实现》的更多相关信息。</p>
</div>
<div class="section" id="ctrl-f">
<h2>命令目录(使用 CTRL + F 快速查找)：<a class="headerlink" href="#ctrl-f" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="27%" />
<col width="23%" />
<col width="27%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><div class="toctree-wrapper first last compound">
<span id="document-key/index"></span><div class="section" id="key">
<h3>Key（键）<a class="headerlink" href="#key" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-key/del"></span><div class="section" id="del">
<span id="id1"></span><h4>DEL<a class="headerlink" href="#del" title="Permalink to this headline">¶</a></h4>
<p><strong>DEL key [key ...]</strong></p>
<p>删除给定的一个或多个 <tt class="docutils literal"><span class="pre">key</span></tt> 。</p>
<p>不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 会被忽略。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first line-block">
<div class="line">O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为被删除的 <tt class="docutils literal"><span class="pre">key</span></tt> 的数量。</div>
</div>
<div class="last line-block">
<div class="line">删除单个字符串类型的 <tt class="docutils literal"><span class="pre">key</span></tt> ，时间复杂度为O(1)。</div>
<div class="line">删除单个列表、集合、有序集合或哈希表类型的 <tt class="docutils literal"><span class="pre">key</span></tt> ，时间复杂度为O(M)， <tt class="docutils literal"><span class="pre">M</span></tt> 为以上数据结构内的元素数量。</div>
</div>
</dd>
<dt><strong>返回值：</strong></dt>
<dd>被删除 <tt class="docutils literal"><span class="pre">key</span></tt> 的数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>#  删除单个 key

redis&gt; SET name huangz
OK

redis&gt; DEL name
(integer) 1


# 删除一个不存在的 key

redis&gt; EXISTS phone
(integer) 0

redis&gt; DEL phone # 失败，没有 key 被删除
(integer) 0


# 同时删除多个 key

redis&gt; SET name &quot;redis&quot;
OK

redis&gt; SET type &quot;key-value store&quot;
OK

redis&gt; SET website &quot;redis.com&quot;
OK

redis&gt; DEL name type website
(integer) 3
</pre></div>
</div>
</div>
<span id="document-key/dump"></span><div class="section" id="dump">
<span id="id1"></span><h4>DUMP<a class="headerlink" href="#dump" title="Permalink to this headline">¶</a></h4>
<p><strong>DUMP key</strong></p>
<p>序列化给定 <tt class="docutils literal"><span class="pre">key</span></tt> ，并返回被序列化的值，使用 <a class="reference internal" href="index.html#document-key/restore"><em>RESTORE</em></a> 命令可以将这个值反序列化为 Redis 键。</p>
<p>序列化生成的值有以下几个特点：</p>
<ul class="simple">
<li>它带有 64 位的校验和，用于检测错误， <a class="reference internal" href="index.html#document-key/restore"><em>RESTORE</em></a> 在进行反序列化之前会先检查校验和。</li>
<li>值的编码格式和 RDB 文件保持一致。</li>
<li>RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。</li>
</ul>
<p>序列化的值不包括任何生存时间信息。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first last line-block">
<div class="line">查找给定键的复杂度为 O(1) ，对键进行序列化的复杂度为 O(N*M) ，其中 N 是构成 <tt class="docutils literal"><span class="pre">key</span></tt> 的 Redis 对象的数量，而 M 则是这些对象的平均大小。</div>
<div class="line">如果序列化的对象是比较小的字符串，那么复杂度为 O(1) 。</div>
</div>
</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，那么返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
<div class="line">否则，返回序列化之后的值。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET greeting &quot;hello, dumping world!&quot;
OK

redis&gt; DUMP greeting
&quot;\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde&quot;

redis&gt; DUMP not-exists-key
(nil)
</pre></div>
</div>
</div>
<span id="document-key/exists"></span><div class="section" id="exists">
<span id="id1"></span><h4>EXISTS<a class="headerlink" href="#exists" title="Permalink to this headline">¶</a></h4>
<p><strong>EXISTS key</strong></p>
<p>检查给定 <tt class="docutils literal"><span class="pre">key</span></tt> 是否存在。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>若 <tt class="docutils literal"><span class="pre">key</span></tt> 存在，返回 <tt class="docutils literal"><span class="pre">1</span></tt> ，否则返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET db &quot;redis&quot;
OK

redis&gt; EXISTS db
(integer) 1

redis&gt; DEL db
(integer) 1

redis&gt; EXISTS db
(integer) 0
</pre></div>
</div>
</div>
<span id="document-key/expire"></span><div class="section" id="expire">
<span id="id1"></span><h4>EXPIRE<a class="headerlink" href="#expire" title="Permalink to this headline">¶</a></h4>
<p><strong>EXPIRE key seconds</strong></p>
<p>为给定 <tt class="docutils literal"><span class="pre">key</span></tt> 设置生存时间，当 <tt class="docutils literal"><span class="pre">key</span></tt> 过期时(生存时间为 <tt class="docutils literal"><span class="pre">0</span></tt> )，它会被自动删除。</p>
<p>在 Redis 中，带有生存时间的 <tt class="docutils literal"><span class="pre">key</span></tt> 被称为『易失的』(volatile)。</p>
<p>生存时间可以通过使用 <a class="reference internal" href="index.html#del"><em>DEL</em></a> 命令来删除整个 <tt class="docutils literal"><span class="pre">key</span></tt> 来移除，或者被 <a class="reference internal" href="index.html#set"><em>SET</em></a> 和 <a class="reference internal" href="index.html#getset"><em>GETSET</em></a> 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 <tt class="docutils literal"><span class="pre">key</span></tt> 的值而不是用一个新的 <tt class="docutils literal"><span class="pre">key</span></tt> 值来代替(replace)它的话，那么生存时间不会被改变。</p>
<p>比如说，对一个 <tt class="docutils literal"><span class="pre">key</span></tt> 执行 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令，对一个列表进行 <a class="reference internal" href="index.html#lpush"><em>LPUSH</em></a> 命令，或者对一个哈希表执行 <a class="reference internal" href="index.html#hset"><em>HSET</em></a> 命令，这类操作都不会修改 <tt class="docutils literal"><span class="pre">key</span></tt> 本身的生存时间。</p>
<p>另一方面，如果使用 <a class="reference internal" href="index.html#document-key/rename"><em>RENAME</em></a> 对一个 <tt class="docutils literal"><span class="pre">key</span></tt> 进行改名，那么改名后的 <tt class="docutils literal"><span class="pre">key</span></tt> 的生存时间和改名前一样。</p>
<p><a class="reference internal" href="index.html#document-key/rename"><em>RENAME</em></a> 命令的另一种可能是，尝试将一个带生存时间的 <tt class="docutils literal"><span class="pre">key</span></tt> 改名成另一个带生存时间的 <tt class="docutils literal"><span class="pre">another_key</span></tt> ，这时旧的 <tt class="docutils literal"><span class="pre">another_key</span></tt> (以及它的生存时间)会被删除，然后旧的 <tt class="docutils literal"><span class="pre">key</span></tt> 会改名为 <tt class="docutils literal"><span class="pre">another_key</span></tt> ，因此，新的 <tt class="docutils literal"><span class="pre">another_key</span></tt> 的生存时间也和原本的 <tt class="docutils literal"><span class="pre">key</span></tt> 一样。</p>
<p>使用 <a class="reference internal" href="index.html#document-key/persist"><em>PERSIST</em></a> 命令可以在不删除 <tt class="docutils literal"><span class="pre">key</span></tt> 的情况下，移除 <tt class="docutils literal"><span class="pre">key</span></tt> 的生存时间，让 <tt class="docutils literal"><span class="pre">key</span></tt> 重新成为一个『持久的』(persistent) <tt class="docutils literal"><span class="pre">key</span></tt> 。</p>
<p><strong>更新生存时间</strong></p>
<p>可以对一个已经带有生存时间的 <tt class="docutils literal"><span class="pre">key</span></tt> 执行 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 命令，新指定的生存时间会取代旧的生存时间。</p>
<p><strong>过期时间的精确度</strong></p>
<p>在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 <tt class="docutils literal"><span class="pre">key</span></tt> 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</p>
<p><strong>Redis 2.1.3 之前的不同之处</strong></p>
<p>在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 <tt class="docutils literal"><span class="pre">key</span></tt> 会导致整个 <tt class="docutils literal"><span class="pre">key</span></tt> 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;=  1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">设置成功返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在或者不能为 <tt class="docutils literal"><span class="pre">key</span></tt> 设置生存时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 <tt class="docutils literal"><span class="pre">key</span></tt> 的生存时间)，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET cache_page &quot;www.google.com&quot;
OK

redis&gt; EXPIRE cache_page 30  # 设置过期时间为 30 秒
(integer) 1

redis&gt; TTL cache_page    # 查看剩余生存时间
(integer) 23

redis&gt; EXPIRE cache_page 30000   # 更新过期时间
(integer) 1

redis&gt; TTL cache_page
(integer) 29996
</pre></div>
</div>
<div class="section" id="id2">
<h5>模式：导航会话<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>假设你有一项 web 服务，打算根据用户最近访问的 N 个页面来进行物品推荐，并且假设用户停止阅览超过 60 秒，那么就清空阅览记录(为了减少物品推荐的计算量，并且保持推荐物品的新鲜度)。</p>
<p>这些最近访问的页面记录，我们称之为『导航会话』(Navigation session)，可以用 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 和 <a class="reference internal" href="index.html#rpush"><em>RPUSH</em></a> 命令在 Redis 中实现它：每当用户阅览一个网页的时候，执行以下代码：</p>
<div class="highlight-python"><div class="highlight"><pre>MULTI
    RPUSH pagewviews.user:&lt;userid&gt; http://.....
    EXPIRE pagewviews.user:&lt;userid&gt; 60
EXEC
</pre></div>
</div>
<p>如果用户停止阅览超过 60 秒，那么它的导航会话就会被清空，当用户重新开始阅览的时候，系统又会重新记录导航会话，继续进行物品推荐。</p>
</div>
</div>
<span id="document-key/expireat"></span><div class="section" id="expireat">
<span id="id1"></span><h4>EXPIREAT<a class="headerlink" href="#expireat" title="Permalink to this headline">¶</a></h4>
<p><strong>EXPIREAT key timestamp</strong></p>
<p><a class="reference internal" href="#expireat">EXPIREAT</a> 的作用和 <a class="reference internal" href="index.html#document-key/expire"><em>EXPIRE</em></a> 类似，都用于为 <tt class="docutils literal"><span class="pre">key</span></tt> 设置生存时间。</p>
<p>不同在于 <a class="reference internal" href="#expireat">EXPIREAT</a> 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果生存时间设置成功，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在或没办法设置生存时间，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET cache www.google.com
OK

redis&gt; EXPIREAT cache 1355292000     # 这个 key 将在 2012.12.12 过期
(integer) 1

redis&gt; TTL cache
(integer) 45081860
</pre></div>
</div>
</div>
<span id="document-key/keys"></span><div class="section" id="keys">
<span id="id1"></span><h4>KEYS<a class="headerlink" href="#keys" title="Permalink to this headline">¶</a></h4>
<p><strong>KEYS pattern</strong></p>
<p>查找所有符合给定模式 <tt class="docutils literal"><span class="pre">pattern</span></tt> 的 <tt class="docutils literal"><span class="pre">key</span></tt> 。</p>
<div class="line-block">
<div class="line"><tt class="docutils literal"><span class="pre">KEYS</span> <span class="pre">*</span></tt> 匹配数据库中所有 <tt class="docutils literal"><span class="pre">key</span></tt> 。</div>
<div class="line"><tt class="docutils literal"><span class="pre">KEYS</span> <span class="pre">h?llo</span></tt> 匹配 <tt class="docutils literal"><span class="pre">hello</span></tt> ，  <tt class="docutils literal"><span class="pre">hallo</span></tt> 和 <tt class="docutils literal"><span class="pre">hxllo</span></tt> 等。</div>
<div class="line"><tt class="docutils literal"><span class="pre">KEYS</span> <span class="pre">h*llo</span></tt> 匹配 <tt class="docutils literal"><span class="pre">hllo</span></tt> 和 <tt class="docutils literal"><span class="pre">heeeeello</span></tt> 等。</div>
<div class="line"><tt class="docutils literal"><span class="pre">KEYS</span> <span class="pre">h[ae]llo</span></tt> 匹配 <tt class="docutils literal"><span class="pre">hello</span></tt> 和 <tt class="docutils literal"><span class="pre">hallo</span></tt> ，但不匹配 <tt class="docutils literal"><span class="pre">hillo</span></tt> 。</div>
</div>
<p>特殊符号用 <tt class="docutils literal"><span class="pre">\</span></tt> 隔开</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><a class="reference internal" href="#keys">KEYS</a> 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 <tt class="docutils literal"><span class="pre">key</span></tt> ，你最好还是用 Redis 的集合结构(set)来代替。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为数据库中 <tt class="docutils literal"><span class="pre">key</span></tt> 的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>符合给定模式的 <tt class="docutils literal"><span class="pre">key</span></tt> 列表。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; MSET one 1 two 2 three 3 four 4  # 一次设置 4 个 key
OK

redis&gt; KEYS *o*
1) &quot;four&quot;
2) &quot;two&quot;
3) &quot;one&quot;

redis&gt; KEYS t??
1) &quot;two&quot;

redis&gt; KEYS t[w]*
1) &quot;two&quot;

redis&gt; KEYS *  # 匹配数据库内所有 key
1) &quot;four&quot;
2) &quot;three&quot;
3) &quot;two&quot;
4) &quot;one&quot;
</pre></div>
</div>
</div>
<span id="document-key/migrate"></span><div class="section" id="migrate">
<span id="id1"></span><h4>MIGRATE<a class="headerlink" href="#migrate" title="Permalink to this headline">¶</a></h4>
<p><strong>MIGRATE host port key destination-db timeout [COPY] [REPLACE]</strong></p>
<p>将 <tt class="docutils literal"><span class="pre">key</span></tt> 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， <tt class="docutils literal"><span class="pre">key</span></tt> 保证会出现在目标实例上，而当前实例上的 <tt class="docutils literal"><span class="pre">key</span></tt> 会被删除。</p>
<p>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</p>
<p>命令的内部实现是这样的：它在当前实例对给定 <tt class="docutils literal"><span class="pre">key</span></tt> 执行 <a class="reference internal" href="index.html#document-key/dump"><em>DUMP</em></a> 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 <a class="reference internal" href="index.html#document-key/restore"><em>RESTORE</em></a> 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 <a class="reference internal" href="index.html#document-key/restore"><em>RESTORE</em></a> 命令返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，它就会调用 <a class="reference internal" href="index.html#document-key/del"><em>DEL</em></a>  删除自己数据库上的 <tt class="docutils literal"><span class="pre">key</span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre">timeout</span></tt> 参数以毫秒为格式，指定当前实例和目标实例进行沟通的<strong>最大间隔时间</strong>。这说明操作并不一定要在 <tt class="docutils literal"><span class="pre">timeout</span></tt> 毫秒内完成，只是说数据传送的时间不能超过这个 <tt class="docutils literal"><span class="pre">timeout</span></tt> 数。</p>
<p><a class="reference internal" href="#migrate">MIGRATE</a> 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： <tt class="docutils literal"><span class="pre">IOERR</span></tt> 。</p>
<p>当 <tt class="docutils literal"><span class="pre">IOERR</span></tt> 出现时，有以下两种可能：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span></tt> 可能存在于两个实例</li>
<li><tt class="docutils literal"><span class="pre">key</span></tt> 可能只存在于当前实例</li>
</ul>
<p>唯一不可能发生的情况就是丢失 <tt class="docutils literal"><span class="pre">key</span></tt> ，因此，如果一个客户端执行 <a class="reference internal" href="#migrate">MIGRATE</a> 命令，并且不幸遇上 <tt class="docutils literal"><span class="pre">IOERR</span></tt> 错误，那么这个客户端唯一要做的就是检查自己数据库上的 <tt class="docutils literal"><span class="pre">key</span></tt> 是否已经被正确地删除。</p>
<p>如果有其他错误发生，那么 <a class="reference internal" href="#migrate">MIGRATE</a>  保证 <tt class="docutils literal"><span class="pre">key</span></tt> 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 <tt class="docutils literal"><span class="pre">key</span></tt> 同名的键，不过这和 <a class="reference internal" href="#migrate">MIGRATE</a> 命令没有关系）。</p>
<p><strong>可选项：</strong></p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">COPY</span></tt> ：不移除源实例上的 <tt class="docutils literal"><span class="pre">key</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">REPLACE</span></tt> ：替换目标实例上已存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 。</li>
</ul>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first last line-block">
<div class="line">这个命令在源实例上实际执行 <a class="reference internal" href="index.html#document-key/dump"><em>DUMP</em></a> 命令和 <a class="reference internal" href="index.html#document-key/del"><em>DEL</em></a> 命令，在目标实例执行 <a class="reference internal" href="index.html#document-key/restore"><em>RESTORE</em></a> 命令，查看以上命令的文档可以看到详细的复杂度说明。</div>
<div class="line"><tt class="docutils literal"><span class="pre">key</span></tt> 数据在两个实例之间传输的复杂度为 O(N) 。</div>
</div>
</dd>
<dt><strong>返回值：</strong></dt>
<dd>迁移成功时返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，否则返回相应的错误。</dd>
</dl>
<div class="section" id="id2">
<h5>示例<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>先启动两个 Redis 实例，一个使用默认的 6379 端口，一个使用 7777 端口。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-server &amp;
[1] 3557

...

$ ./redis-server --port 7777 &amp;
[2] 3560

...
</pre></div>
</div>
<p>然后用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-cli

redis 127.0.0.1:6379&gt; flushdb
OK

redis 127.0.0.1:6379&gt; SET greeting &quot;Hello from 6379 instance&quot;
OK

redis 127.0.0.1:6379&gt; MIGRATE 127.0.0.1 7777 greeting 0 1000
OK

redis 127.0.0.1:6379&gt; EXISTS greeting                           # 迁移成功后 key 被删除
(integer) 0
</pre></div>
</div>
<p>使用另一个客户端，查看 7777 端口上的实例：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-cli -p 7777

redis 127.0.0.1:7777&gt; GET greeting
&quot;Hello from 6379 instance&quot;
</pre></div>
</div>
</div>
</div>
<span id="document-key/move"></span><div class="section" id="move">
<span id="id1"></span><h4>MOVE<a class="headerlink" href="#move" title="Permalink to this headline">¶</a></h4>
<p><strong>MOVE key db</strong></p>
<p>将当前数据库的 <tt class="docutils literal"><span class="pre">key</span></tt> 移动到给定的数据库 <tt class="docutils literal"><span class="pre">db</span></tt> 当中。</p>
<p>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 <tt class="docutils literal"><span class="pre">key</span></tt> ，或者 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在于当前数据库，那么 <tt class="docutils literal"><span class="pre">MOVE</span></tt> 没有任何效果。</p>
<p>因此，也可以利用这一特性，将 <a class="reference internal" href="#move">MOVE</a> 当作锁(locking)原语(primitive)。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>移动成功返回 <tt class="docutils literal"><span class="pre">1</span></tt> ，失败则返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># key 存在于当前数据库

redis&gt; SELECT 0                             # redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。
OK

redis&gt; SET song &quot;secret base - Zone&quot;
OK

redis&gt; MOVE song 1                          # 将 song 移动到数据库 1
(integer) 1

redis&gt; EXISTS song                          # song 已经被移走
(integer) 0

redis&gt; SELECT 1                             # 使用数据库 1
OK

redis:1&gt; EXISTS song                        # 证实 song 被移到了数据库 1 (注意命令提示符变成了&quot;redis:1&quot;，表明正在使用数据库 1)
(integer) 1


# 当 key 不存在的时候

redis:1&gt; EXISTS fake_key
(integer) 0

redis:1&gt; MOVE fake_key 0                    # 试图从数据库 1 移动一个不存在的 key 到数据库 0，失败
(integer) 0

redis:1&gt; select 0                           # 使用数据库0
OK

redis&gt; EXISTS fake_key                      # 证实 fake_key 不存在
(integer) 0


# 当源数据库和目标数据库有相同的 key 时

redis&gt; SELECT 0                             # 使用数据库0
OK
redis&gt; SET favorite_fruit &quot;banana&quot;
OK

redis&gt; SELECT 1                             # 使用数据库1
OK
redis:1&gt; SET favorite_fruit &quot;apple&quot;
OK

redis:1&gt; SELECT 0                           # 使用数据库0，并试图将 favorite_fruit 移动到数据库 1
OK

redis&gt; MOVE favorite_fruit 1                # 因为两个数据库有相同的 key，MOVE 失败
(integer) 0

redis&gt; GET favorite_fruit                   # 数据库 0 的 favorite_fruit 没变
&quot;banana&quot;

redis&gt; SELECT 1
OK

redis:1&gt; GET favorite_fruit                 # 数据库 1 的 favorite_fruit 也是
&quot;apple&quot;
</pre></div>
</div>
</div>
<span id="document-key/object"></span><div class="section" id="object">
<span id="id1"></span><h4>OBJECT<a class="headerlink" href="#object" title="Permalink to this headline">¶</a></h4>
<p><strong>OBJECT subcommand [arguments [arguments]]</strong></p>
<p><a class="reference internal" href="#object">OBJECT</a> 命令允许从内部察看给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的 Redis 对象。</p>
<div class="line-block">
<div class="line">它通常用在除错(debugging)或者了解为了节省空间而对 <tt class="docutils literal"><span class="pre">key</span></tt> 使用特殊编码的情况。</div>
<div class="line">当将Redis用作缓存程序时，你也可以通过 <a class="reference internal" href="#object">OBJECT</a> 命令中的信息，决定 <tt class="docutils literal"><span class="pre">key</span></tt> 的驱逐策略(eviction policies)。</div>
</div>
<p>OBJECT 命令有多个子命令：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">OBJECT</span> <span class="pre">REFCOUNT</span> <span class="pre">&lt;key&gt;</span></tt> 返回给定 <tt class="docutils literal"><span class="pre">key</span></tt> 引用所储存的值的次数。此命令主要用于除错。</li>
<li><tt class="docutils literal"><span class="pre">OBJECT</span> <span class="pre">ENCODING</span> <span class="pre">&lt;key&gt;</span></tt> 返回给定 <tt class="docutils literal"><span class="pre">key</span></tt> 锁储存的值所使用的内部表示(representation)。</li>
<li><tt class="docutils literal"><span class="pre">OBJECT</span> <span class="pre">IDLETIME</span> <span class="pre">&lt;key&gt;</span></tt> 返回给定 <tt class="docutils literal"><span class="pre">key</span></tt> 自储存以来的空闲时间(idle， 没有被读取也没有被写入)，以秒为单位。</li>
</ul>
<div class="line-block">
<div class="line">对象可以以多种方式编码：</div>
</div>
<ul class="simple">
<li>字符串可以被编码为 <tt class="docutils literal"><span class="pre">raw</span></tt> (一般字符串)或 <tt class="docutils literal"><span class="pre">int</span></tt> (为了节约内存，Redis 会将字符串表示的 64 位有符号整数编码为整数来进行储存）。</li>
<li>列表可以被编码为 <tt class="docutils literal"><span class="pre">ziplist</span></tt> 或 <tt class="docutils literal"><span class="pre">linkedlist</span></tt> 。 <tt class="docutils literal"><span class="pre">ziplist</span></tt> 是为节约大小较小的列表空间而作的特殊表示。</li>
<li>集合可以被编码为 <tt class="docutils literal"><span class="pre">intset</span></tt> 或者 <tt class="docutils literal"><span class="pre">hashtable</span></tt> 。 <tt class="docutils literal"><span class="pre">intset</span></tt> 是只储存数字的小集合的特殊表示。</li>
<li>哈希表可以编码为 <tt class="docutils literal"><span class="pre">zipmap</span></tt> 或者 <tt class="docutils literal"><span class="pre">hashtable</span></tt> 。 <tt class="docutils literal"><span class="pre">zipmap</span></tt> 是小哈希表的特殊表示。</li>
<li>有序集合可以被编码为 <tt class="docutils literal"><span class="pre">ziplist</span></tt> 或者 <tt class="docutils literal"><span class="pre">skiplist</span></tt> 格式。 <tt class="docutils literal"><span class="pre">ziplist</span></tt> 用于表示小的有序集合，而 <tt class="docutils literal"><span class="pre">skiplist</span></tt> 则用于表示任何大小的有序集合。</li>
</ul>
<div class="line-block">
<div class="line">假如你做了什么让 Redis 没办法再使用节省空间的编码时(比如将一个只有 1 个元素的集合扩展为一个有 100 万个元素的集合)，特殊编码类型(specially encoded types)会自动转换成通用类型(general type)。</div>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.3</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">REFCOUNT</span></tt> 和 <tt class="docutils literal"><span class="pre">IDLETIME</span></tt> 返回数字。</div>
<div class="line"><tt class="docutils literal"><span class="pre">ENCODING</span></tt> 返回相应的编码类型。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET game &quot;COD&quot;           # 设置一个字符串
OK

redis&gt; OBJECT REFCOUNT game     # 只有一个引用
(integer) 1

redis&gt; OBJECT IDLETIME game     # 等待一阵。。。然后查看空闲时间
(integer) 90

redis&gt; GET game                 # 提取game， 让它处于活跃(active)状态
&quot;COD&quot;

redis&gt; OBJECT IDLETIME game     # 不再处于空闲状态
(integer) 0

redis&gt; OBJECT ENCODING game     # 字符串的编码方式
&quot;raw&quot;

redis&gt; SET big-number 23102930128301091820391092019203810281029831092  # 非常长的数字会被编码为字符串
OK

redis&gt; OBJECT ENCODING big-number
&quot;raw&quot;

redis&gt; SET small-number 12345  # 而短的数字则会被编码为整数
OK

redis&gt; OBJECT ENCODING small-number
&quot;int&quot;
</pre></div>
</div>
</div>
<span id="document-key/persist"></span><div class="section" id="persist">
<span id="id1"></span><h4>PERSIST<a class="headerlink" href="#persist" title="Permalink to this headline">¶</a></h4>
<p><strong>PERSIST key</strong></p>
<p>移除给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的生存时间，将这个 <tt class="docutils literal"><span class="pre">key</span></tt> 从『易失的』(带生存时间 <tt class="docutils literal"><span class="pre">key</span></tt> )转换成『持久的』(一个不带生存时间、永不过期的 <tt class="docutils literal"><span class="pre">key</span></tt> )。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">当生存时间移除成功时，返回 <tt class="docutils literal"><span class="pre">1</span></tt> .</div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在或 <tt class="docutils literal"><span class="pre">key</span></tt> 没有设置生存时间，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET mykey &quot;Hello&quot;
OK

redis&gt; EXPIRE mykey 10  # 为 key 设置生存时间
(integer) 1

redis&gt; TTL mykey
(integer) 10

redis&gt; PERSIST mykey    # 移除 key 的生存时间
(integer) 1

redis&gt; TTL mykey
(integer) -1
</pre></div>
</div>
</div>
<span id="document-key/pexpire"></span><div class="section" id="pexpire">
<span id="id1"></span><h4>PEXPIRE<a class="headerlink" href="#pexpire" title="Permalink to this headline">¶</a></h4>
<p><strong>PEXPIRE key milliseconds</strong></p>
<p>这个命令和 <a class="reference internal" href="index.html#document-key/expire"><em>EXPIRE</em></a> 命令的作用类似，但是它以毫秒为单位设置 <tt class="docutils literal"><span class="pre">key</span></tt> 的生存时间，而不像 <a class="reference internal" href="index.html#document-key/expire"><em>EXPIRE</em></a> 命令那样，以秒为单位。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">设置成功，返回 <tt class="docutils literal"><span class="pre">1</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">key</span></tt> 不存在或设置失败，返回 <tt class="docutils literal"><span class="pre">0</span></tt></div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET mykey &quot;Hello&quot;
OK

redis&gt; PEXPIRE mykey 1500
(integer) 1

redis&gt; TTL mykey    # TTL 的返回值以秒为单位
(integer) 2

redis&gt; PTTL mykey   # PTTL 可以给出准确的毫秒数
(integer) 1499
</pre></div>
</div>
</div>
<span id="document-key/pexpireat"></span><div class="section" id="pexpireat">
<span id="id1"></span><h4>PEXPIREAT<a class="headerlink" href="#pexpireat" title="Permalink to this headline">¶</a></h4>
<p><strong>PEXPIREAT key milliseconds-timestamp</strong></p>
<p>这个命令和 <a class="reference internal" href="index.html#document-key/expireat"><em>EXPIREAT</em></a> 命令类似，但它以毫秒为单位设置 <tt class="docutils literal"><span class="pre">key</span></tt> 的过期 unix 时间戳，而不是像 <a class="reference internal" href="index.html#document-key/expireat"><em>EXPIREAT</em></a> 那样，以秒为单位。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果生存时间设置成功，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在或没办法设置生存时间时，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。(查看 <a class="reference internal" href="index.html#document-key/expire"><em>EXPIRE</em></a> 命令获取更多信息)</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET mykey &quot;Hello&quot;
OK

redis&gt; PEXPIREAT mykey 1555555555005
(integer) 1

redis&gt; TTL mykey           # TTL 返回秒
(integer) 223157079

redis&gt; PTTL mykey          # PTTL 返回毫秒
(integer) 223157079318
</pre></div>
</div>
</div>
<span id="document-key/pttl"></span><div class="section" id="pttl">
<span id="id1"></span><h4>PTTL<a class="headerlink" href="#pttl" title="Permalink to this headline">¶</a></h4>
<p><strong>PTTL key</strong></p>
<p>这个命令类似于 <a class="reference internal" href="index.html#ttl"><em>TTL</em></a> 命令，但它以毫秒为单位返回 <tt class="docutils literal"><span class="pre">key</span></tt> 的剩余生存时间，而不是像 <a class="reference internal" href="index.html#ttl"><em>TTL</em></a> 命令那样，以秒为单位。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">-2</span></tt> 。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在但没有设置剩余生存时间时，返回 <tt class="docutils literal"><span class="pre">-1</span></tt> 。</div>
<div class="line">否则，以毫秒为单位，返回 <tt class="docutils literal"><span class="pre">key</span></tt> 的剩余生存时间。</div>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在 Redis 2.8 以前，当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，或者 <tt class="docutils literal"><span class="pre">key</span></tt> 没有设置剩余生存时间时，命令都返回 <tt class="docutils literal"><span class="pre">-1</span></tt> 。</p>
</div>
<div class="highlight-python"><div class="highlight"><pre># 不存在的 key

redis&gt; FLUSHDB
OK

redis&gt; PTTL key
(integer) -2


# key 存在，但没有设置剩余生存时间

redis&gt; SET key value
OK

redis&gt; PTTL key
(integer) -1


# 有剩余生存时间的 key

redis&gt; PEXPIRE key 10086
(integer) 1

redis&gt; PTTL key
(integer) 6179
</pre></div>
</div>
</div>
<span id="document-key/randomkey"></span><div class="section" id="randomkey">
<span id="id1"></span><h4>RANDOMKEY<a class="headerlink" href="#randomkey" title="Permalink to this headline">¶</a></h4>
<p><strong>RANDOMKEY</strong></p>
<p>从当前数据库中随机返回(不删除)一个 <tt class="docutils literal"><span class="pre">key</span></tt> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">当数据库不为空时，返回一个 <tt class="docutils literal"><span class="pre">key</span></tt> 。</div>
<div class="line">当数据库为空时，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 数据库不为空

redis&gt; MSET fruit &quot;apple&quot; drink &quot;beer&quot; food &quot;cookies&quot;   # 设置多个 key
OK

redis&gt; RANDOMKEY
&quot;fruit&quot;

redis&gt; RANDOMKEY
&quot;food&quot;

redis&gt; KEYS *    # 查看数据库内所有key，证明 RANDOMKEY 并不删除 key
1) &quot;food&quot;
2) &quot;drink&quot;
3) &quot;fruit&quot;


# 数据库为空

redis&gt; FLUSHDB  # 删除当前数据库所有 key
OK

redis&gt; RANDOMKEY
(nil)
</pre></div>
</div>
</div>
<span id="document-key/rename"></span><div class="section" id="rename">
<span id="id1"></span><h4>RENAME<a class="headerlink" href="#rename" title="Permalink to this headline">¶</a></h4>
<p><strong>RENAME key newkey</strong></p>
<p>将 <tt class="docutils literal"><span class="pre">key</span></tt> 改名为 <tt class="docutils literal"><span class="pre">newkey</span></tt> 。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 和 <tt class="docutils literal"><span class="pre">newkey</span></tt> 相同，或者 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回一个错误。</p>
<p>当 <tt class="docutils literal"><span class="pre">newkey</span></tt> 已经存在时， <a class="reference internal" href="#rename">RENAME</a> 命令将覆盖旧值。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>改名成功时提示 <tt class="docutils literal"><span class="pre">OK</span></tt> ，失败时候返回一个错误。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># key 存在且 newkey 不存在

redis&gt; SET message &quot;hello world&quot;
OK

redis&gt; RENAME message greeting
OK

redis&gt; EXISTS message               # message 不复存在
(integer) 0

redis&gt; EXISTS greeting              # greeting 取而代之
(integer) 1


# 当 key 不存在时，返回错误

redis&gt; RENAME fake_key never_exists
(error) ERR no such key


# newkey 已存在时， RENAME 会覆盖旧 newkey

redis&gt; SET pc &quot;lenovo&quot;
OK

redis&gt; SET personal_computer &quot;dell&quot;
OK

redis&gt; RENAME pc personal_computer
OK

redis&gt; GET pc
(nil)

redis:1&gt; GET personal_computer      # 原来的值 dell 被覆盖了
&quot;lenovo&quot;
</pre></div>
</div>
</div>
<span id="document-key/renamenx"></span><div class="section" id="renamenx">
<span id="id1"></span><h4>RENAMENX<a class="headerlink" href="#renamenx" title="Permalink to this headline">¶</a></h4>
<p><strong>RENAMENX key newkey</strong></p>
<p>当且仅当 <tt class="docutils literal"><span class="pre">newkey</span></tt> 不存在时，将 <tt class="docutils literal"><span class="pre">key</span></tt> 改名为 <tt class="docutils literal"><span class="pre">newkey</span></tt> 。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回一个错误。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">修改成功时，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">newkey</span></tt> 已经存在，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># newkey 不存在，改名成功

redis&gt; SET player &quot;MPlyaer&quot;
OK

redis&gt; EXISTS best_player
(integer) 0

redis&gt; RENAMENX player best_player
(integer) 1


# newkey存在时，失败

redis&gt; SET animal &quot;bear&quot;
OK

redis&gt; SET favorite_animal &quot;butterfly&quot;
OK

redis&gt; RENAMENX animal favorite_animal
(integer) 0

redis&gt; get animal
&quot;bear&quot;

redis&gt; get favorite_animal
&quot;butterfly&quot;
</pre></div>
</div>
</div>
<span id="document-key/restore"></span><div class="section" id="restore">
<span id="id1"></span><h4>RESTORE<a class="headerlink" href="#restore" title="Permalink to this headline">¶</a></h4>
<p><strong>RESTORE key ttl serialized-value [REPLACE]</strong></p>
<p>反序列化给定的序列化值，并将它和给定的 <tt class="docutils literal"><span class="pre">key</span></tt> 关联。</p>
<p>参数 <tt class="docutils literal"><span class="pre">ttl</span></tt> 以毫秒为单位为 <tt class="docutils literal"><span class="pre">key</span></tt> 设置生存时间；如果 <tt class="docutils literal"><span class="pre">ttl</span></tt> 为 <tt class="docutils literal"><span class="pre">0</span></tt> ，那么不设置生存时间。</p>
<p><a class="reference internal" href="#restore">RESTORE</a> 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 <a class="reference internal" href="#restore">RESTORE</a> 会拒绝进行反序列化，并返回一个错误。</p>
<p>如果键 <tt class="docutils literal"><span class="pre">key</span></tt> 已经存在，
并且给定了 <tt class="docutils literal"><span class="pre">REPLACE</span></tt> 选项，
那么使用反序列化得出的值来代替键 <tt class="docutils literal"><span class="pre">key</span></tt> 原有的值；
相反地，
如果键 <tt class="docutils literal"><span class="pre">key</span></tt> 已经存在，
但是没有给定 <tt class="docutils literal"><span class="pre">REPLACE</span></tt> 选项，
那么命令返回一个错误。</p>
<p>更多信息可以参考 <a class="reference internal" href="index.html#document-key/dump"><em>DUMP</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first last line-block">
<div class="line">查找给定键的复杂度为 O(1) ，对键进行反序列化的复杂度为 O(N*M) ，其中 N 是构成 <tt class="docutils literal"><span class="pre">key</span></tt> 的 Redis 对象的数量，而 M 则是这些对象的平均大小。</div>
<div class="line">有序集合(sorted set)的反序列化复杂度为 O(N*M*log(N)) ，因为有序集合每次插入的复杂度为 O(log(N)) 。</div>
<div class="line">如果反序列化的对象是比较小的字符串，那么复杂度为 O(1) 。</div>
</div>
</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果反序列化成功那么返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，否则返回一个错误。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 创建一个键，作为 DUMP 命令的输入

redis&gt; SET greeting &quot;hello, dumping world!&quot;
OK

redis&gt; DUMP greeting
&quot;\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde&quot;

# 将序列化数据 RESTORE 到另一个键上面

redis&gt; RESTORE greeting-again 0 &quot;\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde&quot;
OK

redis&gt; GET greeting-again
&quot;hello, dumping world!&quot;

# 在没有给定 REPLACE 选项的情况下，再次尝试反序列化到同一个键，失败

redis&gt; RESTORE greeting-again 0 &quot;\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde&quot;
(error) ERR Target key name is busy.

# 给定 REPLACE 选项，对同一个键进行反序列化成功

redis&gt; RESTORE greeting-again 0 &quot;\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde&quot; REPLACE
OK

# 尝试使用无效的值进行反序列化，出错

redis&gt; RESTORE fake-message 0 &quot;hello moto moto blah blah&quot;
(error) ERR DUMP payload version or checksum are wrong
</pre></div>
</div>
</div>
<span id="document-key/sort"></span><div class="section" id="sort">
<span id="id1"></span><h4>SORT<a class="headerlink" href="#sort" title="Permalink to this headline">¶</a></h4>
<p><strong>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] [STORE destination]</strong></p>
<p>返回或保存给定列表、集合、有序集合 <tt class="docutils literal"><span class="pre">key</span></tt> 中经过排序的元素。</p>
<p>排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</p>
<div class="section" id="id2">
<h5>一般 SORT 用法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>最简单的 <a class="reference internal" href="#sort">SORT</a> 使用方法是 <tt class="docutils literal"><span class="pre">SORT</span> <span class="pre">key</span></tt> 和 <tt class="docutils literal"><span class="pre">SORT</span> <span class="pre">key</span> <span class="pre">DESC</span></tt> ：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SORT</span> <span class="pre">key</span></tt> 返回键值从小到大排序的结果。</li>
<li><tt class="docutils literal"><span class="pre">SORT</span> <span class="pre">key</span> <span class="pre">DESC</span></tt> 返回键值从大到小排序的结果。</li>
</ul>
<p>假设 <tt class="docutils literal"><span class="pre">today_cost</span></tt> 列表保存了今日的开销金额，
那么可以用 <a class="reference internal" href="#sort">SORT</a> 命令对它进行排序：</p>
<div class="highlight-python"><div class="highlight"><pre># 开销金额列表

redis&gt; LPUSH today_cost 30 1.5 10 8
(integer) 4

# 排序

redis&gt; SORT today_cost
1) &quot;1.5&quot;
2) &quot;8&quot;
3) &quot;10&quot;
4) &quot;30&quot;

# 逆序排序

redis 127.0.0.1:6379&gt; SORT today_cost DESC
1) &quot;30&quot;
2) &quot;10&quot;
3) &quot;8&quot;
4) &quot;1.5&quot;
</pre></div>
</div>
</div>
<div class="section" id="alpha">
<h5>使用 ALPHA 修饰符对字符串进行排序<a class="headerlink" href="#alpha" title="Permalink to this headline">¶</a></h5>
<p>因为 <a class="reference internal" href="#sort">SORT</a> 命令默认排序对象为数字，
当需要对字符串进行排序时，
需要显式地在 <a class="reference internal" href="#sort">SORT</a> 命令之后添加 <tt class="docutils literal"><span class="pre">ALPHA</span></tt> 修饰符：</p>
<div class="highlight-python"><div class="highlight"><pre># 网址

redis&gt; LPUSH website &quot;www.reddit.com&quot;
(integer) 1

redis&gt; LPUSH website &quot;www.slashdot.com&quot;
(integer) 2

redis&gt; LPUSH website &quot;www.infoq.com&quot;
(integer) 3

# 默认（按数字）排序

redis&gt; SORT website
1) &quot;www.infoq.com&quot;
2) &quot;www.slashdot.com&quot;
3) &quot;www.reddit.com&quot;

# 按字符排序

redis&gt; SORT website ALPHA
1) &quot;www.infoq.com&quot;
2) &quot;www.reddit.com&quot;
3) &quot;www.slashdot.com&quot;
</pre></div>
</div>
<p>如果系统正确地设置了 <tt class="docutils literal"><span class="pre">LC_COLLATE</span></tt> 环境变量的话，Redis能识别 <tt class="docutils literal"><span class="pre">UTF-8</span></tt> 编码。</p>
</div>
<div class="section" id="limit">
<h5>使用 LIMIT 修饰符限制返回结果<a class="headerlink" href="#limit" title="Permalink to this headline">¶</a></h5>
<p>排序之后返回元素的数量可以通过 <tt class="docutils literal"><span class="pre">LIMIT</span></tt> 修饰符进行限制，
修饰符接受 <tt class="docutils literal"><span class="pre">offset</span></tt> 和 <tt class="docutils literal"><span class="pre">count</span></tt> 两个参数：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">offset</span></tt> 指定要跳过的元素数量。</li>
<li><tt class="docutils literal"><span class="pre">count</span></tt> 指定跳过 <tt class="docutils literal"><span class="pre">offset</span></tt> 个指定的元素之后，要返回多少个对象。</li>
</ul>
<p>以下例子返回排序结果的前 5 个对象( <tt class="docutils literal"><span class="pre">offset</span></tt> 为 <tt class="docutils literal"><span class="pre">0</span></tt> 表示没有元素被跳过)。</p>
<div class="highlight-python"><div class="highlight"><pre># 添加测试数据，列表值为 1 指 10

redis 127.0.0.1:6379&gt; RPUSH rank 1 3 5 7 9
(integer) 5

redis 127.0.0.1:6379&gt; RPUSH rank 2 4 6 8 10
(integer) 10

# 返回列表中最小的 5 个值

redis 127.0.0.1:6379&gt; SORT rank LIMIT 0 5
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;
</pre></div>
</div>
<p>可以组合使用多个修饰符。以下例子返回从大到小排序的前 5 个对象。</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT rank LIMIT 0 5 DESC
1) &quot;10&quot;
2) &quot;9&quot;
3) &quot;8&quot;
4) &quot;7&quot;
5) &quot;6&quot;
</pre></div>
</div>
</div>
<div class="section" id="key">
<h5>使用外部 key 进行排序<a class="headerlink" href="#key" title="Permalink to this headline">¶</a></h5>
<p>可以使用外部 <tt class="docutils literal"><span class="pre">key</span></tt> 的数据作为权重，代替默认的直接对比键值的方式来进行排序。</p>
<p>假设现在有用户数据如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="35%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">uid</th>
<th class="head">user_name_{uid}</th>
<th class="head">user_level_{uid}</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>admin</td>
<td>9999</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>jack</td>
<td>10</td>
</tr>
<tr class="row-even"><td>3</td>
<td>peter</td>
<td>25</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>mary</td>
<td>70</td>
</tr>
</tbody>
</table>
<p>以下代码将数据输入到 Redis 中：</p>
<div class="highlight-python"><div class="highlight"><pre># admin

redis 127.0.0.1:6379&gt; LPUSH uid 1
(integer) 1

redis 127.0.0.1:6379&gt; SET user_name_1 admin
OK

redis 127.0.0.1:6379&gt; SET user_level_1 9999
OK

# jack

redis 127.0.0.1:6379&gt; LPUSH uid 2
(integer) 2

redis 127.0.0.1:6379&gt; SET user_name_2 jack
OK

redis 127.0.0.1:6379&gt; SET user_level_2 10
OK

# peter

redis 127.0.0.1:6379&gt; LPUSH uid 3
(integer) 3

redis 127.0.0.1:6379&gt; SET user_name_3 peter
OK

redis 127.0.0.1:6379&gt; SET user_level_3 25
OK

# mary

redis 127.0.0.1:6379&gt; LPUSH uid 4
(integer) 4

redis 127.0.0.1:6379&gt; SET user_name_4 mary
OK

redis 127.0.0.1:6379&gt; SET user_level_4 70
OK
</pre></div>
</div>
<div class="section" id="by">
<h6>BY 选项<a class="headerlink" href="#by" title="Permalink to this headline">¶</a></h6>
<p>默认情况下， <tt class="docutils literal"><span class="pre">SORT</span> <span class="pre">uid</span></tt> 直接按 <tt class="docutils literal"><span class="pre">uid</span></tt> 中的值排序：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT uid
1) &quot;1&quot;      # admin
2) &quot;2&quot;      # jack
3) &quot;3&quot;      # peter
4) &quot;4&quot;      # mary
</pre></div>
</div>
<p>通过使用 <tt class="docutils literal"><span class="pre">BY</span></tt> 选项，可以让 <tt class="docutils literal"><span class="pre">uid</span></tt> 按其他键的元素来排序。</p>
<p>比如说，
以下代码让 <tt class="docutils literal"><span class="pre">uid</span></tt> 键按照 <tt class="docutils literal"><span class="pre">user_level_{uid}</span></tt> 的大小来排序：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT uid BY user_level_*
1) &quot;2&quot;      # jack , level = 10
2) &quot;3&quot;      # peter, level = 25
3) &quot;4&quot;      # mary, level = 70
4) &quot;1&quot;      # admin, level = 9999
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">user_level_*</span></tt> 是一个占位符，
它先取出 <tt class="docutils literal"><span class="pre">uid</span></tt> 中的值，
然后再用这个值来查找相应的键。</p>
<p>比如在对 <tt class="docutils literal"><span class="pre">uid</span></tt> 列表进行排序时，
程序就会先取出 <tt class="docutils literal"><span class="pre">uid</span></tt> 的值 <tt class="docutils literal"><span class="pre">1</span></tt> 、 <tt class="docutils literal"><span class="pre">2</span></tt> 、 <tt class="docutils literal"><span class="pre">3</span></tt> 、 <tt class="docutils literal"><span class="pre">4</span></tt> ，
然后使用 <tt class="docutils literal"><span class="pre">user_level_1</span></tt> 、 <tt class="docutils literal"><span class="pre">user_level_2</span></tt> 、 <tt class="docutils literal"><span class="pre">user_level_3</span></tt> 和 <tt class="docutils literal"><span class="pre">user_level_4</span></tt> 的值作为排序 <tt class="docutils literal"><span class="pre">uid</span></tt> 的权重。</p>
</div>
<div class="section" id="get">
<h6>GET 选项<a class="headerlink" href="#get" title="Permalink to this headline">¶</a></h6>
<p>使用 <tt class="docutils literal"><span class="pre">GET</span></tt> 选项，
可以根据排序的结果来取出相应的键值。</p>
<p>比如说，
以下代码先排序 <tt class="docutils literal"><span class="pre">uid</span></tt> ，
再取出键 <tt class="docutils literal"><span class="pre">user_name_{uid}</span></tt> 的值：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT uid GET user_name_*
1) &quot;admin&quot;
2) &quot;jack&quot;
3) &quot;peter&quot;
4) &quot;mary&quot;
</pre></div>
</div>
</div>
<div class="section" id="by-get">
<h6>组合使用 BY 和 GET<a class="headerlink" href="#by-get" title="Permalink to this headline">¶</a></h6>
<p>通过组合使用 <tt class="docutils literal"><span class="pre">BY</span></tt> 和 <tt class="docutils literal"><span class="pre">GET</span></tt> ，
可以让排序结果以更直观的方式显示出来。</p>
<p>比如说，
以下代码先按 <tt class="docutils literal"><span class="pre">user_level_{uid}</span></tt> 来排序 <tt class="docutils literal"><span class="pre">uid</span></tt> 列表，
再取出相应的 <tt class="docutils literal"><span class="pre">user_name_{uid}</span></tt> 的值：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT uid BY user_level_* GET user_name_*
1) &quot;jack&quot;       # level = 10
2) &quot;peter&quot;      # level = 25
3) &quot;mary&quot;       # level = 70
4) &quot;admin&quot;      # level = 9999
</pre></div>
</div>
<p>现在的排序结果要比只使用 <tt class="docutils literal"><span class="pre">SORT</span> <span class="pre">uid</span> <span class="pre">BY</span> <span class="pre">user_level_*</span></tt> 要直观得多。</p>
</div>
<div class="section" id="id3">
<h6>获取多个外部键<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h6>
<p>可以同时使用多个 <tt class="docutils literal"><span class="pre">GET</span></tt> 选项，
获取多个外部键的值。</p>
<p>以下代码就按 <tt class="docutils literal"><span class="pre">uid</span></tt> 分别获取 <tt class="docutils literal"><span class="pre">user_level_{uid}</span></tt> 和 <tt class="docutils literal"><span class="pre">user_name_{uid}</span></tt> ：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT uid GET user_level_* GET user_name_*
1) &quot;9999&quot;       # level
2) &quot;admin&quot;      # name
3) &quot;10&quot;
4) &quot;jack&quot;
5) &quot;25&quot;
6) &quot;peter&quot;
7) &quot;70&quot;
8) &quot;mary&quot;
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">GET</span></tt> 有一个额外的参数规则，那就是 —— 可以用 <tt class="docutils literal"><span class="pre">#</span></tt> 获取被排序键的值。</p>
<p>以下代码就将 <tt class="docutils literal"><span class="pre">uid</span></tt> 的值、及其相应的 <tt class="docutils literal"><span class="pre">user_level_*</span></tt> 和 <tt class="docutils literal"><span class="pre">user_name_*</span></tt> 都返回为结果：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT uid GET # GET user_level_* GET user_name_*
1) &quot;1&quot;          # uid
2) &quot;9999&quot;       # level
3) &quot;admin&quot;      # name
4) &quot;2&quot;
5) &quot;10&quot;
6) &quot;jack&quot;
7) &quot;3&quot;
8) &quot;25&quot;
9) &quot;peter&quot;
10) &quot;4&quot;
11) &quot;70&quot;
12) &quot;mary&quot;
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h6>获取外部键，但不进行排序<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h6>
<p>通过将一个不存在的键作为参数传给 <tt class="docutils literal"><span class="pre">BY</span></tt> 选项，
可以让 <tt class="docutils literal"><span class="pre">SORT</span></tt> 跳过排序操作，
直接返回结果：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key
1) &quot;4&quot;
2) &quot;3&quot;
3) &quot;2&quot;
4) &quot;1&quot;
</pre></div>
</div>
<p>这种用法在单独使用时，没什么实际用处。</p>
<p>不过，通过将这种用法和 <tt class="docutils literal"><span class="pre">GET</span></tt> 选项配合，
就可以在不排序的情况下，
获取多个外部键，
相当于执行一个整合的获取操作（类似于 SQL 数据库的 <tt class="docutils literal"><span class="pre">join</span></tt> 关键字）。</p>
<p>以下代码演示了，如何在不引起排序的情况下，使用 <tt class="docutils literal"><span class="pre">SORT</span></tt> 、 <tt class="docutils literal"><span class="pre">BY</span></tt> 和 <tt class="docutils literal"><span class="pre">GET</span></tt> 获取多个外部键：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key GET # GET user_level_* GET user_name_*
1) &quot;4&quot;      # id
2) &quot;70&quot;     # level
3) &quot;mary&quot;   # name
4) &quot;3&quot;
5) &quot;25&quot;
6) &quot;peter&quot;
7) &quot;2&quot;
8) &quot;10&quot;
9) &quot;jack&quot;
10) &quot;1&quot;
11) &quot;9999&quot;
12) &quot;admin&quot;
</pre></div>
</div>
</div>
<div class="section" id="get-by">
<h6>将哈希表作为 GET 或 BY 的参数<a class="headerlink" href="#get-by" title="Permalink to this headline">¶</a></h6>
<p>除了可以将字符串键之外，
哈希表也可以作为 <tt class="docutils literal"><span class="pre">GET</span></tt> 或 <tt class="docutils literal"><span class="pre">BY</span></tt> 选项的参数来使用。</p>
<p>比如说，对于前面给出的用户信息表：</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="35%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">uid</th>
<th class="head">user_name_{uid}</th>
<th class="head">user_level_{uid}</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>admin</td>
<td>9999</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>jack</td>
<td>10</td>
</tr>
<tr class="row-even"><td>3</td>
<td>peter</td>
<td>25</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>mary</td>
<td>70</td>
</tr>
</tbody>
</table>
<p>我们可以不将用户的名字和级别保存在 <tt class="docutils literal"><span class="pre">user_name_{uid}</span></tt> 和 <tt class="docutils literal"><span class="pre">user_level_{uid}</span></tt> 两个字符串键中，
而是用一个带有 <tt class="docutils literal"><span class="pre">name</span></tt> 域和 <tt class="docutils literal"><span class="pre">level</span></tt> 域的哈希表 <tt class="docutils literal"><span class="pre">user_info_{uid}</span></tt> 来保存用户的名字和级别信息：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; HMSET user_info_1 name admin level 9999
OK

redis 127.0.0.1:6379&gt; HMSET user_info_2 name jack level 10
OK

redis 127.0.0.1:6379&gt; HMSET user_info_3 name peter level 25
OK

redis 127.0.0.1:6379&gt; HMSET user_info_4 name mary level 70
OK
</pre></div>
</div>
<p>之后， <tt class="docutils literal"><span class="pre">BY</span></tt> 和 <tt class="docutils literal"><span class="pre">GET</span></tt> 选项都可以用 <tt class="docutils literal"><span class="pre">key-&gt;field</span></tt> 的格式来获取哈希表中的域的值，
其中 <tt class="docutils literal"><span class="pre">key</span></tt> 表示哈希表键，
而 <tt class="docutils literal"><span class="pre">field</span></tt> 则表示哈希表的域：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level
1) &quot;2&quot;
2) &quot;3&quot;
3) &quot;4&quot;
4) &quot;1&quot;

redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level GET user_info_*-&gt;name
1) &quot;jack&quot;
2) &quot;peter&quot;
3) &quot;mary&quot;
4) &quot;admin&quot;
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h5>保存排序结果<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>默认情况下， <a class="reference internal" href="#sort">SORT</a> 操作只是简单地返回排序结果，并不进行任何保存操作。</p>
<p>通过给 <tt class="docutils literal"><span class="pre">STORE</span></tt> 选项指定一个 <tt class="docutils literal"><span class="pre">key</span></tt> 参数，可以将排序结果保存到给定的键上。</p>
<p>如果被指定的 <tt class="docutils literal"><span class="pre">key</span></tt> 已存在，那么原有的值将被排序结果覆盖。</p>
<div class="highlight-python"><div class="highlight"><pre># 测试数据

redis 127.0.0.1:6379&gt; RPUSH numbers 1 3 5 7 9
(integer) 5

redis 127.0.0.1:6379&gt; RPUSH numbers 2 4 6 8 10
(integer) 10

redis 127.0.0.1:6379&gt; LRANGE numbers 0 -1
1) &quot;1&quot;
2) &quot;3&quot;
3) &quot;5&quot;
4) &quot;7&quot;
5) &quot;9&quot;
6) &quot;2&quot;
7) &quot;4&quot;
8) &quot;6&quot;
9) &quot;8&quot;
10) &quot;10&quot;

redis 127.0.0.1:6379&gt; SORT numbers STORE sorted-numbers
(integer) 10

# 排序后的结果

redis 127.0.0.1:6379&gt; LRANGE sorted-numbers 0 -1
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;
6) &quot;6&quot;
7) &quot;7&quot;
8) &quot;8&quot;
9) &quot;9&quot;
10) &quot;10&quot;
</pre></div>
</div>
<p>可以通过将 <a class="reference internal" href="#sort">SORT</a> 命令的执行结果保存，并用 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 为结果设置生存时间，以此来产生一个 <a class="reference internal" href="#sort">SORT</a> 操作的结果缓存。</p>
<p>这样就可以避免对 <a class="reference internal" href="#sort">SORT</a> 操作的频繁调用：只有当结果集过期时，才需要再调用一次 <a class="reference internal" href="#sort">SORT</a> 操作。</p>
<p>另外，为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行 <a class="reference internal" href="#sort">SORT</a> 操作，并保存为结果集)，具体参见 <a class="reference internal" href="index.html#setnx"><em>SETNX</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first last line-block">
<div class="line">O(N+M*log(M))， <tt class="docutils literal"><span class="pre">N</span></tt> 为要排序的列表或集合内的元素数量， <tt class="docutils literal"><span class="pre">M</span></tt> 为要返回的元素数量。</div>
<div class="line">如果只是使用 <a class="reference internal" href="#sort">SORT</a> 命令的 <tt class="docutils literal"><span class="pre">GET</span></tt> 选项获取数据而没有进行排序，时间复杂度 O(N)。</div>
</div>
</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">没有使用 <tt class="docutils literal"><span class="pre">STORE</span></tt> 参数，返回列表形式的排序结果。</div>
<div class="line">使用 <tt class="docutils literal"><span class="pre">STORE</span></tt> 参数，返回排序结果的元素数量。</div>
</div>
</dd>
</dl>
</div>
</div>
<span id="document-key/ttl"></span><div class="section" id="ttl">
<span id="id1"></span><h4>TTL<a class="headerlink" href="#ttl" title="Permalink to this headline">¶</a></h4>
<p><strong>TTL key</strong></p>
<p>以秒为单位，返回给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的剩余生存时间(TTL, time to live)。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">-2</span></tt> 。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在但没有设置剩余生存时间时，返回 <tt class="docutils literal"><span class="pre">-1</span></tt> 。</div>
<div class="line">否则，以秒为单位，返回 <tt class="docutils literal"><span class="pre">key</span></tt> 的剩余生存时间。</div>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在 Redis 2.8 以前，当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，或者 <tt class="docutils literal"><span class="pre">key</span></tt> 没有设置剩余生存时间时，命令都返回 <tt class="docutils literal"><span class="pre">-1</span></tt> 。</p>
</div>
<div class="highlight-python"><div class="highlight"><pre># 不存在的 key

redis&gt; FLUSHDB
OK

redis&gt; TTL key
(integer) -2


# key 存在，但没有设置剩余生存时间

redis&gt; SET key value
OK

redis&gt; TTL key
(integer) -1


# 有剩余生存时间的 key

redis&gt; EXPIRE key 10086
(integer) 1

redis&gt; TTL key
(integer) 10084
</pre></div>
</div>
</div>
<span id="document-key/type"></span><div class="section" id="type">
<span id="id1"></span><h4>TYPE<a class="headerlink" href="#type" title="Permalink to this headline">¶</a></h4>
<p><strong>TYPE key</strong></p>
<p>返回 <tt class="docutils literal"><span class="pre">key</span></tt> 所储存的值的类型。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">none</span></tt> (key不存在)</div>
<div class="line"><tt class="docutils literal"><span class="pre">string</span></tt> (字符串)</div>
<div class="line"><tt class="docutils literal"><span class="pre">list</span></tt> (列表)</div>
<div class="line"><tt class="docutils literal"><span class="pre">set</span></tt> (集合)</div>
<div class="line"><tt class="docutils literal"><span class="pre">zset</span></tt> (有序集)</div>
<div class="line"><tt class="docutils literal"><span class="pre">hash</span></tt> (哈希表)</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 字符串

redis&gt; SET weather &quot;sunny&quot;
OK

redis&gt; TYPE weather
string


# 列表

redis&gt; LPUSH book_list &quot;programming in scala&quot;
(integer) 1

redis&gt; TYPE book_list
list


# 集合

redis&gt; SADD pat &quot;dog&quot;
(integer) 1

redis&gt; TYPE pat
set
</pre></div>
</div>
</div>
<span id="document-key/scan"></span><div class="section" id="scan">
<span id="id1"></span><h4>SCAN<a class="headerlink" href="#scan" title="Permalink to this headline">¶</a></h4>
<p><strong>SCAN cursor [MATCH pattern] [COUNT count]</strong></p>
<p><a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令及其相关的 <a class="reference internal" href="index.html#sscan"><em>SSCAN</em></a> 命令、 <a class="reference internal" href="index.html#hscan"><em>HSCAN</em></a> 命令和 <a class="reference internal" href="index.html#zscan"><em>ZSCAN</em></a> 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令用于迭代当前数据库中的数据库键。</li>
<li><a class="reference internal" href="index.html#sscan"><em>SSCAN</em></a> 命令用于迭代集合键中的元素。</li>
<li><a class="reference internal" href="index.html#hscan"><em>HSCAN</em></a> 命令用于迭代哈希键中的键值对。</li>
<li><a class="reference internal" href="index.html#zscan"><em>ZSCAN</em></a> 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</li>
</ul>
<p>以上列出的四个命令都支持增量式迭代，
它们每次执行都只会返回少量元素，
所以这些命令可以用于生产环境，
而不会出现像 <a class="reference internal" href="index.html#keys"><em>KEYS</em></a> 命令、 <a class="reference internal" href="index.html#smembers"><em>SMEMBERS</em></a> 命令带来的问题 ——
当 <a class="reference internal" href="index.html#keys"><em>KEYS</em></a> 命令被用于处理一个大的数据库时，
又或者 <a class="reference internal" href="index.html#smembers"><em>SMEMBERS</em></a> 命令被用于处理一个大的集合键时，
它们可能会阻塞服务器达数秒之久。</p>
<p>不过，
增量式迭代命令也不是没有缺点的：
举个例子，
使用 <a class="reference internal" href="index.html#smembers"><em>SMEMBERS</em></a> 命令可以返回集合键当前包含的所有元素，
但是对于 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 这类增量式迭代命令来说，
因为在对键进行增量式迭代的过程中，
键可能会被修改，
所以增量式迭代命令只能对被返回的元素提供有限的保证
（offer limited guarantees about the returned elements）。</p>
<p>因为 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 、 <a class="reference internal" href="index.html#sscan"><em>SSCAN</em></a> 、 <a class="reference internal" href="index.html#hscan"><em>HSCAN</em></a> 和 <a class="reference internal" href="index.html#zscan"><em>ZSCAN</em></a> 四个命令的工作方式都非常相似，
所以这个文档会一并介绍这四个命令，
但是要记住：</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#sscan"><em>SSCAN</em></a> 命令、 <a class="reference internal" href="index.html#hscan"><em>HSCAN</em></a> 命令和 <a class="reference internal" href="index.html#zscan"><em>ZSCAN</em></a> 命令的第一个参数总是一个数据库键。</li>
<li>而 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令则不需要在第一个参数提供任何数据库键 ——
因为它迭代的是当前数据库中的所有数据库键。</li>
</ul>
<div class="section" id="id2">
<h5>SCAN 命令的基本用法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令是一个基于游标的迭代器（cursor based iterator）：
<a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令每次被调用之后，
都会向用户返回一个新的游标，
用户在下次迭代时需要使用这个新游标作为 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令的游标参数，
以此来延续之前的迭代过程。</p>
<p>当 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令的游标参数被设置为 <tt class="docutils literal"><span class="pre">0</span></tt> 时，
服务器将开始一次新的迭代，
而当服务器向用户返回值为 <tt class="docutils literal"><span class="pre">0</span></tt> 的游标时，
表示迭代已结束。</p>
<p>以下是一个 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令的迭代过程示例：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; scan 0
1) &quot;17&quot;
2)  1) &quot;key:12&quot;
    2) &quot;key:8&quot;
    3) &quot;key:4&quot;
    4) &quot;key:14&quot;
    5) &quot;key:16&quot;
    6) &quot;key:17&quot;
    7) &quot;key:15&quot;
    8) &quot;key:10&quot;
    9) &quot;key:3&quot;
    10) &quot;key:7&quot;
    11) &quot;key:1&quot;

redis 127.0.0.1:6379&gt; scan 17
1) &quot;0&quot;
2) 1) &quot;key:5&quot;
   2) &quot;key:18&quot;
   3) &quot;key:0&quot;
   4) &quot;key:2&quot;
   5) &quot;key:19&quot;
   6) &quot;key:13&quot;
   7) &quot;key:6&quot;
   8) &quot;key:9&quot;
   9) &quot;key:11&quot;
</pre></div>
</div>
<p>在上面这个例子中，
第一次迭代使用 <tt class="docutils literal"><span class="pre">0</span></tt> 作为游标，
表示开始一次新的迭代。</p>
<p>第二次迭代使用的是第一次迭代时返回的游标，
也即是命令回复第一个元素的值 —— <tt class="docutils literal"><span class="pre">17</span></tt> 。</p>
<p>从上面的示例可以看到，
<a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令的回复是一个包含两个元素的数组，
第一个数组元素是用于进行下一次迭代的新游标，
而第二个数组元素则是一个数组，
这个数组中包含了所有被迭代的元素。</p>
<p>在第二次调用 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令时，
命令返回了游标 <tt class="docutils literal"><span class="pre">0</span></tt> ，
这表示迭代已经结束，
整个数据集（collection）已经被完整遍历过了。</p>
<p>以 <tt class="docutils literal"><span class="pre">0</span></tt> 作为游标开始一次新的迭代，
一直调用 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令，
直到命令返回游标 <tt class="docutils literal"><span class="pre">0</span></tt> ，
我们称这个过程为一次<strong>完整遍历</strong>（full iteration）。</p>
</div>
<div class="section" id="scan-guarantees">
<h5>SCAN 命令的保证（guarantees）<a class="headerlink" href="#scan-guarantees" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令，
以及其他增量式迭代命令，
在进行完整遍历的情况下可以为用户带来以下保证：
从完整遍历开始直到完整遍历结束期间，
一直存在于数据集内的所有元素都会被完整遍历返回；
这意味着，
如果有一个元素，
它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中，
那么 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令总会在某次迭代中将这个元素返回给用户。</p>
<p>然而因为增量式命令仅仅使用游标来记录迭代状态，
所以这些命令带有以下缺点：</p>
<ul class="simple">
<li>同一个元素可能会被返回多次。
处理重复元素的工作交由应用程序负责，
比如说，
可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。</li>
<li>如果一个元素是在迭代过程中被添加到数据集的，
又或者是在迭代过程中从数据集中被删除的，
那么这个元素可能会被返回，
也可能不会，
这是未定义的（undefined）。</li>
</ul>
</div>
<div class="section" id="id3">
<h5>SCAN 命令每次执行返回的元素数量<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>增量式迭代命令并不保证每次执行都返回某个给定数量的元素。</p>
<p>增量式命令甚至可能会返回零个元素，
但只要命令返回的游标不是 <tt class="docutils literal"><span class="pre">0</span></tt> ，
应用程序就不应该将迭代视作结束。</p>
<p>不过命令返回的元素数量总是符合一定规则的，
在实际中：</p>
<ul class="simple">
<li>对于一个大数据集来说，
增量式迭代命令每次最多可能会返回数十个元素；</li>
<li>而对于一个足够小的数据集来说，
如果这个数据集的底层表示为编码数据结构（encoded data structure，适用于是小集合键、小哈希键和小有序集合键），
那么增量迭代命令将在一次调用中返回数据集中的所有元素。</li>
</ul>
<p>最后，
用户可以通过增量式迭代命令提供的 <tt class="docutils literal"><span class="pre">COUNT</span></tt> 选项来指定每次迭代返回元素的最大值。</p>
</div>
<div class="section" id="count">
<h5>COUNT 选项<a class="headerlink" href="#count" title="Permalink to this headline">¶</a></h5>
<p>虽然增量式迭代命令不保证每次迭代所返回的元素数量，
但我们可以使用 <tt class="docutils literal"><span class="pre">COUNT</span></tt> 选项，
对命令的行为进行一定程度上的调整。</p>
<p>基本上，
<tt class="docutils literal"><span class="pre">COUNT</span></tt> 选项的作用就是让用户告知迭代命令，
在每次迭代中应该从数据集里返回多少元素。</p>
<p>虽然 <tt class="docutils literal"><span class="pre">COUNT</span></tt> 选项<strong>只是对增量式迭代命令的一种提示</strong>（hint），
但是在大多数情况下，
这种提示都是有效的。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">COUNT</span></tt> 参数的默认值为 <tt class="docutils literal"><span class="pre">10</span></tt> 。</li>
<li>在迭代一个足够大的、由哈希表实现的数据库、集合键、哈希键或者有序集合键时，
如果用户没有使用 <tt class="docutils literal"><span class="pre">MATCH</span></tt> 选项，
那么命令返回的元素数量通常和 <tt class="docutils literal"><span class="pre">COUNT</span></tt> 选项指定的一样，
或者比 <tt class="docutils literal"><span class="pre">COUNT</span></tt> 选项指定的数量稍多一些。</li>
<li>在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、
或者编码为压缩列表（ziplist，由不同值构成的一个小哈希或者一个小有序集合）时，
增量式迭代命令通常会无视 <tt class="docutils literal"><span class="pre">COUNT</span></tt> 选项指定的值，
在第一次迭代就将数据集包含的所有元素都返回给用户。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>并非每次迭代都要使用相同的</strong> <tt class="docutils literal"><span class="pre">COUNT</span></tt> <strong>值。</strong></p>
<p class="last">用户可以在每次迭代中按自己的需要随意改变 <tt class="docutils literal"><span class="pre">COUNT</span></tt> 值，
只要记得将上次迭代返回的游标用到下次迭代里面就可以了。</p>
</div>
</div>
<div class="section" id="match">
<h5>MATCH 选项<a class="headerlink" href="#match" title="Permalink to this headline">¶</a></h5>
<p>和 <a class="reference internal" href="index.html#keys"><em>KEYS</em></a> 命令一样，
增量式迭代命令也可以通过提供一个 glob 风格的模式参数，
让命令只返回和给定模式相匹配的元素，
这一点可以通过在执行增量式迭代命令时，
通过给定 <tt class="docutils literal"><span class="pre">MATCH</span> <span class="pre">&lt;pattern&gt;</span></tt> 参数来实现。</p>
<p>以下是一个使用 <tt class="docutils literal"><span class="pre">MATCH</span></tt> 选项进行迭代的示例：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; sadd myset 1 2 3 foo foobar feelsgood
(integer) 6

redis 127.0.0.1:6379&gt; sscan myset 0 match f*
1) &quot;0&quot;
2) 1) &quot;foo&quot;
   2) &quot;feelsgood&quot;
   3) &quot;foobar&quot;
</pre></div>
</div>
<p>需要注意的是，
对元素的模式匹配工作是在命令从数据集中取出元素之后，
向客户端返回元素之前的这段时间内进行的，
所以如果被迭代的数据集中只有少量元素和模式相匹配，
那么迭代命令或许会在多次执行中都不返回任何元素。</p>
<p>以下是这种情况的一个例子：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; scan 0 MATCH *11*
1) &quot;288&quot;
2) 1) &quot;key:911&quot;

redis 127.0.0.1:6379&gt; scan 288 MATCH *11*
1) &quot;224&quot;
2) (empty list or set)

redis 127.0.0.1:6379&gt; scan 224 MATCH *11*
1) &quot;80&quot;
2) (empty list or set)

redis 127.0.0.1:6379&gt; scan 80 MATCH *11*
1) &quot;176&quot;
2) (empty list or set)

redis 127.0.0.1:6379&gt; scan 176 MATCH *11* COUNT 1000
1) &quot;0&quot;
2)  1) &quot;key:611&quot;
    2) &quot;key:711&quot;
    3) &quot;key:118&quot;
    4) &quot;key:117&quot;
    5) &quot;key:311&quot;
    6) &quot;key:112&quot;
    7) &quot;key:111&quot;
    8) &quot;key:110&quot;
    9) &quot;key:113&quot;
   10) &quot;key:211&quot;
   11) &quot;key:411&quot;
   12) &quot;key:115&quot;
   13) &quot;key:116&quot;
   14) &quot;key:114&quot;
   15) &quot;key:119&quot;
   16) &quot;key:811&quot;
   17) &quot;key:511&quot;
   18) &quot;key:11&quot;
</pre></div>
</div>
<p>如你所见，
以上的大部分迭代都不返回任何元素。</p>
<p>在最后一次迭代，
我们通过将 <tt class="docutils literal"><span class="pre">COUNT</span></tt> 选项的参数设置为 <tt class="docutils literal"><span class="pre">1000</span></tt> ，
强制命令为本次迭代扫描更多元素，
从而使得命令返回的元素也变多了。</p>
</div>
<div class="section" id="id4">
<h5>并发执行多个迭代<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>在同一时间，
可以有任意多个客户端对同一数据集进行迭代，
客户端每次执行迭代都需要传入一个游标，
并在迭代执行之后获得一个新的游标，
而这个游标就包含了迭代的所有状态，
因此，
服务器无须为迭代记录任何状态。</p>
</div>
<div class="section" id="id5">
<h5>中途停止迭代<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>因为迭代的所有状态都保存在游标里面，
而服务器无须为迭代保存任何状态，
所以客户端可以在中途停止一个迭代，
而无须对服务器进行任何通知。</p>
<p>即使有任意数量的迭代在中途停止，
也不会产生任何问题。</p>
</div>
<div class="section" id="id6">
<h5>使用错误的游标进行增量式迭代<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>使用间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃，
但可能会让命令产生未定义的行为。</p>
<p>未定义行为指的是，
增量式命令对返回值所做的保证可能会不再为真。</p>
<p>只有两种游标是合法的：</p>
<ol class="arabic simple">
<li>在开始一个新的迭代时，
游标必须为 <tt class="docutils literal"><span class="pre">0</span></tt> 。</li>
<li>增量式迭代命令在执行之后返回的，
用于延续（continue）迭代过程的游标。</li>
</ol>
</div>
<div class="section" id="id7">
<h5>迭代终结的保证<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>增量式迭代命令所使用的算法只保证在数据集的大小有界（bounded）的情况下，
迭代才会停止，
换句话说，
如果被迭代数据集的大小不断地增长的话，
增量式迭代命令可能永远也无法完成一次完整迭代。</p>
<p>从直觉上可以看出，
当一个数据集不断地变大时，
想要访问这个数据集中的所有元素就需要做越来越多的工作，
能否结束一个迭代取决于用户执行迭代的速度是否比数据集增长的速度更快。</p>
<p><strong>可用版本：</strong></p>
<blockquote>
<div>&gt;= 2.8.0</div></blockquote>
<p><strong>时间复杂度：</strong></p>
<blockquote>
<div>增量式迭代命令每次执行的复杂度为 O(1) ，
对数据集进行一次完整迭代的复杂度为 O(N) ，
其中 N 为数据集中的元素数量。</div></blockquote>
<p><strong>返回值：</strong></p>
<blockquote>
<div><p><a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令、 <a class="reference internal" href="index.html#sscan"><em>SSCAN</em></a> 命令、 <a class="reference internal" href="index.html#hscan"><em>HSCAN</em></a> 命令和 <a class="reference internal" href="index.html#zscan"><em>ZSCAN</em></a> 命令都返回一个包含两个元素的 multi-bulk 回复：
回复的第一个元素是字符串表示的无符号 64 位整数（游标），
回复的第二个元素是另一个 multi-bulk 回复，
这个 multi-bulk 回复包含了本次被迭代的元素。</p>
<p><a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令返回的每个元素都是一个数据库键。</p>
<p><a class="reference internal" href="index.html#sscan"><em>SSCAN</em></a> 命令返回的每个元素都是一个集合成员。</p>
<p><a class="reference internal" href="index.html#hscan"><em>HSCAN</em></a> 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</p>
<p><a class="reference internal" href="index.html#zscan"><em>ZSCAN</em></a> 命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</p>
</div></blockquote>
</div>
</div>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-string/index"></span><div class="section" id="string">
<h3>String（字符串）<a class="headerlink" href="#string" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-string/append"></span><div class="section" id="append">
<span id="id1"></span><h4>APPEND<a class="headerlink" href="#append" title="Permalink to this headline">¶</a></h4>
<p><strong>APPEND key value</strong></p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 已经存在并且是一个字符串， <a class="reference internal" href="#append">APPEND</a> 命令将 <tt class="docutils literal"><span class="pre">value</span></tt> 追加到 <tt class="docutils literal"><span class="pre">key</span></tt> 原来的值的末尾。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在， <a class="reference internal" href="#append">APPEND</a> 就简单地将给定 <tt class="docutils literal"><span class="pre">key</span></tt> 设为 <tt class="docutils literal"><span class="pre">value</span></tt> ，就像执行 <tt class="docutils literal"><span class="pre">SET</span> <span class="pre">key</span> <span class="pre">value</span></tt> 一样。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>平摊O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>追加 <tt class="docutils literal"><span class="pre">value</span></tt> 之后， <tt class="docutils literal"><span class="pre">key</span></tt> 中字符串的长度。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对不存在的 key 执行 APPEND

redis&gt; EXISTS myphone               # 确保 myphone 不存在
(integer) 0

redis&gt; APPEND myphone &quot;nokia&quot;       # 对不存在的 key 进行 APPEND ，等同于 SET myphone &quot;nokia&quot;
(integer) 5                         # 字符长度


# 对已存在的字符串进行 APPEND

redis&gt; APPEND myphone &quot; - 1110&quot;     # 长度从 5 个字符增加到 12 个字符
(integer) 12

redis&gt; GET myphone
&quot;nokia - 1110&quot;
</pre></div>
</div>
<div class="section" id="time-series">
<h5>模式：时间序列(Time series)<a class="headerlink" href="#time-series" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="#append">APPEND</a> 可以为一系列定长(fixed-size)数据(sample)提供一种紧凑的表示方式，通常称之为时间序列。</p>
<p>每当一个新数据到达的时候，执行以下命令：</p>
<div class="highlight-python"><div class="highlight"><pre>APPEND timeseries &quot;fixed-size sample&quot;
</pre></div>
</div>
<p>然后可以通过以下的方式访问时间序列的各项属性：</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#strlen"><em>STRLEN</em></a> 给出时间序列中数据的数量</li>
<li><a class="reference internal" href="index.html#getrange"><em>GETRANGE</em></a> 可以用于随机访问。只要有相关的时间信息的话，我们就可以在 Redis 2.6 中使用 Lua 脚本和 <a class="reference internal" href="index.html#getrange"><em>GETRANGE</em></a> 命令实现二分查找。</li>
<li><a class="reference internal" href="index.html#setrange"><em>SETRANGE</em></a> 可以用于覆盖或修改已存在的的时间序列。</li>
</ul>
<p>这个模式的唯一缺陷是我们只能增长时间序列，而不能对时间序列进行缩短，因为 Redis 目前还没有对字符串进行修剪(tirm)的命令，但是，不管怎么说，这个模式的储存方式还是可以节省下大量的空间。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">可以考虑使用 UNIX 时间戳作为时间序列的键名，这样一来，可以避免单个 <tt class="docutils literal"><span class="pre">key</span></tt> 因为保存过大的时间序列而占用大量内存，另一方面，也可以节省下大量命名空间。</p>
</div>
<p>下面是一个时间序列的例子：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; APPEND ts &quot;0043&quot;
(integer) 4

redis&gt; APPEND ts &quot;0035&quot;
(integer) 8

redis&gt; GETRANGE ts 0 3
&quot;0043&quot;

redis&gt; GETRANGE ts 4 7
&quot;0035&quot;
</pre></div>
</div>
</div>
</div>
<span id="document-string/bitcount"></span><div class="section" id="bitcount">
<span id="id1"></span><h4>BITCOUNT<a class="headerlink" href="#bitcount" title="Permalink to this headline">¶</a></h4>
<p><strong>BITCOUNT key [start] [end]</strong></p>
<p>计算给定字符串中，被设置为 <tt class="docutils literal"><span class="pre">1</span></tt> 的比特位的数量。</p>
<p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <tt class="docutils literal"><span class="pre">start</span></tt> 或 <tt class="docutils literal"><span class="pre">end</span></tt> 参数，可以让计数只在特定的位上进行。</p>
<p><tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">end</span></tt> 参数的设置和 <a class="reference internal" href="index.html#getrange"><em>GETRANGE</em></a> 命令类似，都可以使用负数值：
比如 <tt class="docutils literal"><span class="pre">-1</span></tt> 表示最后一个字节， <tt class="docutils literal"><span class="pre">-2</span></tt> 表示倒数第二个字节，以此类推。</p>
<p>不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 被当成是空字符串来处理，因此对一个不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 进行 <tt class="docutils literal"><span class="pre">BITCOUNT</span></tt> 操作，结果为 <tt class="docutils literal"><span class="pre">0</span></tt> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)</dd>
<dt><strong>返回值：</strong></dt>
<dd>被设置为 <tt class="docutils literal"><span class="pre">1</span></tt> 的位的数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; BITCOUNT bits
(integer) 0

redis&gt; SETBIT bits 0 1          # 0001
(integer) 0

redis&gt; BITCOUNT bits
(integer) 1

redis&gt; SETBIT bits 3 1          # 1001
(integer) 0

redis&gt; BITCOUNT bits
(integer) 2
</pre></div>
</div>
<div class="section" id="bitmap">
<h5>模式：使用 bitmap 实现用户上线次数统计<a class="headerlink" href="#bitmap" title="Permalink to this headline">¶</a></h5>
<p>Bitmap 对于一些特定类型的计算非常有效。</p>
<p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 <a class="reference internal" href="index.html#setbit"><em>SETBIT</em></a> 和 <a class="reference internal" href="index.html#bitcount"><em>BITCOUNT</em></a> 来实现。</p>
<p>比如说，每当用户在某一天上线的时候，我们就使用 <a class="reference internal" href="index.html#setbit"><em>SETBIT</em></a> ，以用户名作为 <tt class="docutils literal"><span class="pre">key</span></tt> ，将那天所代表的网站的上线日作为 <tt class="docutils literal"><span class="pre">offset</span></tt> 参数，并将这个 <tt class="docutils literal"><span class="pre">offset</span></tt> 上的为设置为 <tt class="docutils literal"><span class="pre">1</span></tt> 。</p>
<p>举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 <tt class="docutils literal"><span class="pre">SETBIT</span> <span class="pre">peter</span> <span class="pre">100</span> <span class="pre">1</span></tt> ；如果明天 peter 也继续阅览网站，那么执行命令 <tt class="docutils literal"><span class="pre">SETBIT</span> <span class="pre">peter</span> <span class="pre">101</span> <span class="pre">1</span></tt> ，以此类推。</p>
<p>当要计算 peter 总共以来的上线次数时，就使用 <a class="reference internal" href="index.html#bitcount"><em>BITCOUNT</em></a> 命令：执行 <tt class="docutils literal"><span class="pre">BITCOUNT</span> <span class="pre">peter</span></tt> ，得出的结果就是 peter 上线的总天数。</p>
<p>更详细的实现可以参考博文(墙外) <a class="reference external" href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/">Fast, easy, realtime metrics using Redis bitmaps</a> 。</p>
</div>
<div class="section" id="id2">
<h5>性能<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， <a class="reference internal" href="index.html#bitcount"><em>BITCOUNT</em></a> 的处理速度就像 <a class="reference internal" href="index.html#get"><em>GET</em></a> 和 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 这种 O(1) 复杂度的操作一样快。</p>
<p>如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：</p>
<ol class="arabic simple">
<li>将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。</li>
<li>使用 <a class="reference internal" href="index.html#bitcount"><em>BITCOUNT</em></a> 的 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">end</span></tt> 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。</li>
</ol>
</div>
</div>
<span id="document-string/bitop"></span><div class="section" id="bitop">
<span id="id1"></span><h4>BITOP<a class="headerlink" href="#bitop" title="Permalink to this headline">¶</a></h4>
<p><strong>BITOP operation destkey key [key ...]</strong></p>
<p>对一个或多个保存二进制位的字符串 <tt class="docutils literal"><span class="pre">key</span></tt> 进行位元操作，并将结果保存到 <tt class="docutils literal"><span class="pre">destkey</span></tt> 上。</p>
<p><tt class="docutils literal"><span class="pre">operation</span></tt> 可以是 <tt class="docutils literal"><span class="pre">AND</span></tt> 、 <tt class="docutils literal"><span class="pre">OR</span></tt> 、 <tt class="docutils literal"><span class="pre">NOT</span></tt> 、 <tt class="docutils literal"><span class="pre">XOR</span></tt> 这四种操作中的任意一种：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">BITOP</span> <span class="pre">AND</span> <span class="pre">destkey</span> <span class="pre">key</span> <span class="pre">[key</span> <span class="pre">...]</span></tt> ，对一个或多个 <tt class="docutils literal"><span class="pre">key</span></tt> 求逻辑并，并将结果保存到 <tt class="docutils literal"><span class="pre">destkey</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">BITOP</span> <span class="pre">OR</span> <span class="pre">destkey</span> <span class="pre">key</span> <span class="pre">[key</span> <span class="pre">...]</span></tt> ，对一个或多个 <tt class="docutils literal"><span class="pre">key</span></tt> 求逻辑或，并将结果保存到 <tt class="docutils literal"><span class="pre">destkey</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">BITOP</span> <span class="pre">XOR</span> <span class="pre">destkey</span> <span class="pre">key</span> <span class="pre">[key</span> <span class="pre">...]</span></tt> ，对一个或多个 <tt class="docutils literal"><span class="pre">key</span></tt> 求逻辑异或，并将结果保存到 <tt class="docutils literal"><span class="pre">destkey</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">BITOP</span> <span class="pre">NOT</span> <span class="pre">destkey</span> <span class="pre">key</span></tt> ，对给定 <tt class="docutils literal"><span class="pre">key</span></tt> 求逻辑非，并将结果保存到 <tt class="docutils literal"><span class="pre">destkey</span></tt> 。</li>
</ul>
<p>除了 <tt class="docutils literal"><span class="pre">NOT</span></tt> 操作之外，其他操作都可以接受一个或多个 <tt class="docutils literal"><span class="pre">key</span></tt> 作为输入。</p>
<p><strong>处理不同长度的字符串</strong></p>
<p>当 <a class="reference internal" href="#bitop">BITOP</a> 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <tt class="docutils literal"><span class="pre">0</span></tt> 。</p>
<p>空的 <tt class="docutils literal"><span class="pre">key</span></tt> 也被看作是包含 <tt class="docutils literal"><span class="pre">0</span></tt> 的字符串序列。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)</dd>
<dt><strong>返回值：</strong></dt>
<dd>保存到 <tt class="docutils literal"><span class="pre">destkey</span></tt> 的字符串的长度，和输入 <tt class="docutils literal"><span class="pre">key</span></tt> 中最长的字符串长度相等。</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="#bitop">BITOP</a> 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p>
</div>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SETBIT bits-1 0 1        # bits-1 = 1001
(integer) 0

redis&gt; SETBIT bits-1 3 1
(integer) 0

redis&gt; SETBIT bits-2 0 1        # bits-2 = 1011
(integer) 0

redis&gt; SETBIT bits-2 1 1
(integer) 0

redis&gt; SETBIT bits-2 3 1
(integer) 0

redis&gt; BITOP AND and-result bits-1 bits-2
(integer) 1

redis&gt; GETBIT and-result 0      # and-result = 1001
(integer) 1

redis&gt; GETBIT and-result 1
(integer) 0

redis&gt; GETBIT and-result 2
(integer) 0

redis&gt; GETBIT and-result 3
(integer) 1
</pre></div>
</div>
</div>
<span id="document-string/decr"></span><div class="section" id="decr">
<span id="id1"></span><h4>DECR<a class="headerlink" href="#decr" title="Permalink to this headline">¶</a></h4>
<p><strong>DECR key</strong></p>
<p>将 <tt class="docutils literal"><span class="pre">key</span></tt> 中储存的数字值减一。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，那么 <tt class="docutils literal"><span class="pre">key</span></tt> 的值会先被初始化为 <tt class="docutils literal"><span class="pre">0</span></tt> ，然后再执行 <a class="reference internal" href="#decr">DECR</a> 操作。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p>
<p>关于递增(increment) / 递减(decrement)操作的更多信息，请参见 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>执行 <a class="reference internal" href="#decr">DECR</a> 命令之后 <tt class="docutils literal"><span class="pre">key</span></tt> 的值。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对存在的数字值 key 进行 DECR

redis&gt; SET failure_times 10
OK

redis&gt; DECR failure_times
(integer) 9


# 对不存在的 key 值进行 DECR

redis&gt; EXISTS count
(integer) 0

redis&gt; DECR count
(integer) -1


# 对存在但不是数值的 key 进行 DECR

redis&gt; SET company YOUR_CODE_SUCKS.LLC
OK

redis&gt; DECR company
(error) ERR value is not an integer or out of range
</pre></div>
</div>
</div>
<span id="document-string/decrby"></span><div class="section" id="decrby">
<span id="id1"></span><h4>DECRBY<a class="headerlink" href="#decrby" title="Permalink to this headline">¶</a></h4>
<p><strong>DECRBY key decrement</strong></p>
<p>将 <tt class="docutils literal"><span class="pre">key</span></tt> 所储存的值减去减量 <tt class="docutils literal"><span class="pre">decrement</span></tt> 。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，那么 <tt class="docutils literal"><span class="pre">key</span></tt> 的值会先被初始化为 <tt class="docutils literal"><span class="pre">0</span></tt> ，然后再执行 <a class="reference internal" href="#decrby">DECRBY</a> 操作。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p>
<p>关于更多递增(increment) / 递减(decrement)操作的更多信息，请参见 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>减去 <tt class="docutils literal"><span class="pre">decrement</span></tt> 之后， <tt class="docutils literal"><span class="pre">key</span></tt> 的值。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对已存在的 key 进行 DECRBY

redis&gt; SET count 100
OK

redis&gt; DECRBY count 20
(integer) 80


# 对不存在的 key 进行DECRBY

redis&gt; EXISTS pages
(integer) 0

redis&gt; DECRBY pages 10
(integer) -10
</pre></div>
</div>
</div>
<span id="document-string/get"></span><div class="section" id="get">
<span id="id1"></span><h4>GET<a class="headerlink" href="#get" title="Permalink to this headline">¶</a></h4>
<p><strong>GET key</strong></p>
<p>返回 <tt class="docutils literal"><span class="pre">key</span></tt> 所关联的字符串值。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在那么返回特殊值 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</p>
<p>假如 <tt class="docutils literal"><span class="pre">key</span></tt> 储存的值不是字符串类型，返回一个错误，因为 <a class="reference internal" href="#get">GET</a> 只能用于处理字符串值。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> ，否则，返回 <tt class="docutils literal"><span class="pre">key</span></tt> 的值。</div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不是字符串类型，那么返回一个错误。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对不存在的 key 或字符串类型 key 进行 GET

redis&gt; GET db
(nil)

redis&gt; SET db redis
OK

redis&gt; GET db
&quot;redis&quot;


# 对不是字符串类型的 key 进行 GET

redis&gt; DEL db
(integer) 1

redis&gt; LPUSH db redis mongodb mysql
(integer) 3

redis&gt; GET db
(error) ERR Operation against a key holding the wrong kind of value
</pre></div>
</div>
</div>
<span id="document-string/getbit"></span><div class="section" id="getbit">
<span id="id1"></span><h4>GETBIT<a class="headerlink" href="#getbit" title="Permalink to this headline">¶</a></h4>
<p><strong>GETBIT key offset</strong></p>
<p>对 <tt class="docutils literal"><span class="pre">key</span></tt> 所储存的字符串值，获取指定偏移量上的位(bit)。</p>
<p>当 <tt class="docutils literal"><span class="pre">offset</span></tt> 比字符串值的长度大，或者 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>字符串值指定偏移量上的位(bit)。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0

redis&gt; EXISTS bit
(integer) 0

redis&gt; GETBIT bit 10086
(integer) 0


# 对已存在的 offset 进行 GETBIT

redis&gt; SETBIT bit 10086 1
(integer) 0

redis&gt; GETBIT bit 10086
(integer) 1
</pre></div>
</div>
</div>
<span id="document-string/getrange"></span><div class="section" id="getrange">
<span id="id1"></span><h4>GETRANGE<a class="headerlink" href="#getrange" title="Permalink to this headline">¶</a></h4>
<p><strong>GETRANGE key start end</strong></p>
<p>返回 <tt class="docutils literal"><span class="pre">key</span></tt> 中字符串值的子字符串，字符串的截取范围由 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">end</span></tt> 两个偏移量决定(包括 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">end</span></tt> 在内)。</p>
<p>负数偏移量表示从字符串最后开始计数， <tt class="docutils literal"><span class="pre">-1</span></tt> 表示最后一个字符， <tt class="docutils literal"><span class="pre">-2</span></tt> 表示倒数第二个，以此类推。</p>
<p><a class="reference internal" href="#getrange">GETRANGE</a> 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在 &lt;= 2.0 的版本里，GETRANGE 被叫作 SUBSTR。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.4.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first last line-block">
<div class="line">O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为要返回的字符串的长度。</div>
<div class="line">复杂度最终由字符串的返回值长度决定，但因为从已有字符串中取出子字符串的操作非常廉价(cheap)，所以对于长度不大的字符串，该操作的复杂度也可看作O(1)。</div>
</div>
</dd>
<dt><strong>返回值：</strong></dt>
<dd>截取得出的子字符串。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET greeting &quot;hello, my friend&quot;
OK

redis&gt; GETRANGE greeting 0 4          # 返回索引0-4的字符，包括4。
&quot;hello&quot;

redis&gt; GETRANGE greeting -1 -5        # 不支持回绕操作
&quot;&quot;

redis&gt; GETRANGE greeting -3 -1        # 负数索引
&quot;end&quot;

redis&gt; GETRANGE greeting 0 -1         # 从第一个到最后一个
&quot;hello, my friend&quot;

redis&gt; GETRANGE greeting 0 1008611    # 值域范围不超过实际字符串，超过部分自动被符略
&quot;hello, my friend&quot;
</pre></div>
</div>
</div>
<span id="document-string/getset"></span><div class="section" id="getset">
<span id="id1"></span><h4>GETSET<a class="headerlink" href="#getset" title="Permalink to this headline">¶</a></h4>
<p><strong>GETSET key value</strong></p>
<p>将给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的值设为 <tt class="docutils literal"><span class="pre">value</span></tt> ，并返回 <tt class="docutils literal"><span class="pre">key</span></tt> 的旧值(old value)。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在但不是字符串类型时，返回一个错误。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">返回给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的旧值。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 没有旧值时，也即是， <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; GETSET db mongodb    # 没有旧值，返回 nil
(nil)

redis&gt; GET db
&quot;mongodb&quot;

redis&gt; GETSET db redis      # 返回旧值 mongodb
&quot;mongodb&quot;

redis&gt; GET db
&quot;redis&quot;
</pre></div>
</div>
<div class="section" id="id2">
<h5>模式<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="#getset">GETSET</a> 可以和 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 组合使用，实现一个有原子性(atomic)复位操作的计数器(counter)。</p>
<p>举例来说，每次当某个事件发生时，进程可能对一个名为 <tt class="docutils literal"><span class="pre">mycount</span></tt> 的 <tt class="docutils literal"><span class="pre">key</span></tt> 调用 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 操作，通常我们还要在一个原子时间内同时完成获得计数器的值和将计数器值复位为 <tt class="docutils literal"><span class="pre">0</span></tt> 两个操作。</p>
<p>可以用命令 <tt class="docutils literal"><span class="pre">GETSET</span> <span class="pre">mycounter</span> <span class="pre">0</span></tt> 来实现这一目标。</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; INCR mycount
(integer) 11

redis&gt; GETSET mycount 0  # 一个原子内完成 GET mycount 和 SET mycount 0 操作
&quot;11&quot;

redis&gt; GET mycount       # 计数器被重置
&quot;0&quot;
</pre></div>
</div>
</div>
</div>
<span id="document-string/incr"></span><div class="section" id="incr">
<span id="id1"></span><h4>INCR<a class="headerlink" href="#incr" title="Permalink to this headline">¶</a></h4>
<p><strong>INCR key</strong></p>
<p>将 <tt class="docutils literal"><span class="pre">key</span></tt> 中储存的数字值增一。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，那么 <tt class="docutils literal"><span class="pre">key</span></tt> 的值会先被初始化为 <tt class="docutils literal"><span class="pre">0</span></tt> ，然后再执行 <a class="reference internal" href="#incr">INCR</a> 操作。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">这是一个针对字符串的操作，因为 Redis 没有专用的整数类型，所以 key 内储存的字符串被解释为十进制 64 位有符号整数来执行 INCR 操作。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>执行 <a class="reference internal" href="#incr">INCR</a> 命令之后 <tt class="docutils literal"><span class="pre">key</span></tt> 的值。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET page_view 20
OK

redis&gt; INCR page_view
(integer) 21

redis&gt; GET page_view    # 数字值在 Redis 中以字符串的形式保存
&quot;21&quot;
</pre></div>
</div>
<div class="section" id="id2">
<h5>模式：计数器<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>计数器是 Redis 的原子性自增操作可实现的最直观的模式了，它的想法相当简单：每当某个操作发生时，向 Redis 发送一个 <a class="reference internal" href="#incr">INCR</a> 命令。</p>
<p>比如在一个 web 应用程序中，如果想知道用户在一年中每天的点击量，那么只要将用户 ID 以及相关的日期信息作为键，并在每次用户点击页面时，执行一次自增操作即可。</p>
<p>比如用户名是 <tt class="docutils literal"><span class="pre">peter</span></tt> ，点击时间是 2012 年 3 月 22 日，那么执行命令 <tt class="docutils literal"><span class="pre">INCR</span> <span class="pre">peter::2012.3.22</span></tt> 。</p>
<p>可以用以下几种方式扩展这个简单的模式：</p>
<ul class="simple">
<li>可以通过组合使用 <a class="reference internal" href="#incr">INCR</a> 和 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> ，来达到只在规定的生存时间内进行计数(counting)的目的。</li>
<li>客户端可以通过使用 <a class="reference internal" href="index.html#getset"><em>GETSET</em></a> 命令原子性地获取计数器的当前值并将计数器清零，更多信息请参考 <a class="reference internal" href="index.html#getset"><em>GETSET</em></a> 命令。</li>
<li>使用其他自增/自减操作，比如 <a class="reference internal" href="index.html#decr"><em>DECR</em></a> 和 <a class="reference internal" href="index.html#incrby"><em>INCRBY</em></a> ，用户可以通过执行不同的操作增加或减少计数器的值，比如在游戏中的记分器就可能用到这些命令。</li>
</ul>
</div>
<div class="section" id="id3">
<h5>模式：限速器<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>限速器是特殊化的计算器，它用于限制一个操作可以被执行的速率(rate)。</p>
<p>限速器的典型用法是限制公开 API 的请求次数，以下是一个限速器实现示例，它将 API 的最大请求数限制在每个 IP 地址每秒钟十个之内：</p>
<div class="highlight-python"><div class="highlight"><pre>FUNCTION LIMIT_API_CALL(ip)
ts = CURRENT_UNIX_TIME()
keyname = ip+&quot;:&quot;+ts
current = GET(keyname)

IF current != NULL AND current &gt; 10 THEN
    ERROR &quot;too many requests per second&quot;
END

IF current == NULL THEN
    MULTI
        INCR(keyname, 1)
        EXPIRE(keyname, 1)
    EXEC
ELSE
    INCR(keyname, 1)
END

PERFORM_API_CALL()
</pre></div>
</div>
<p>这个实现每秒钟为每个 IP 地址使用一个不同的计数器，并用 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 命令设置生存时间(这样 Redis 就会负责自动删除过期的计数器)。</p>
<p>注意，我们使用事务打包执行 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令和 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 命令，避免引入竞争条件，保证每次调用 API 时都可以正确地对计数器进行自增操作并设置生存时间。</p>
<p>以下是另一个限速器实现：</p>
<div class="highlight-python"><div class="highlight"><pre>FUNCTION LIMIT_API_CALL(ip):
current = GET(ip)
IF current != NULL AND current &gt; 10 THEN
    ERROR &quot;too many requests per second&quot;
ELSE
    value = INCR(ip)
    IF value == 1 THEN
        EXPIRE(ip,1)
    END
    PERFORM_API_CALL()
END
</pre></div>
</div>
<p>这个限速器只使用单个计数器，它的生存时间为一秒钟，如果在一秒钟内，这个计数器的值大于 <tt class="docutils literal"><span class="pre">10</span></tt> 的话，那么访问就会被禁止。</p>
<p>这个新的限速器在思路方面是没有问题的，但它在实现方面不够严谨，如果我们仔细观察一下的话，就会发现在 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 和 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 之间存在着一个竞争条件，假如客户端在执行 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 之后，因为某些原因(比如客户端失败)而忘记设置 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 的话，那么这个计数器就会一直存在下去，造成每个用户只能访问 <tt class="docutils literal"><span class="pre">10</span></tt> 次，噢，这简直是个灾难！</p>
<p>要消灭这个实现中的竞争条件，我们可以将它转化为一个 Lua 脚本，并放到 Redis 中运行(这个方法仅限于 Redis 2.6 及以上的版本)：</p>
<div class="highlight-python"><div class="highlight"><pre>local current
current = redis.call(&quot;incr&quot;,KEYS[1])
if tonumber(current) == 1 then
    redis.call(&quot;expire&quot;,KEYS[1],1)
end
</pre></div>
</div>
<p>通过将计数器作为脚本放到 Redis 上运行，我们保证了 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 和 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 两个操作的原子性，现在这个脚本实现不会引入竞争条件，它可以运作的很好。</p>
<p>关于在 Redis 中运行 Lua 脚本的更多信息，请参考 <a class="reference internal" href="index.html#eval"><em>EVAL</em></a> 命令。</p>
<p>还有另一种消灭竞争条件的方法，就是使用 Redis 的列表结构来代替 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令，这个方法无须脚本支持，因此它在 Redis 2.6 以下的版本也可以运行得很好：</p>
<div class="highlight-python"><div class="highlight"><pre>FUNCTION LIMIT_API_CALL(ip)
current = LLEN(ip)
IF current &gt; 10 THEN
    ERROR &quot;too many requests per second&quot;
ELSE
    IF EXISTS(ip) == FALSE
        MULTI
            RPUSH(ip,ip)
            EXPIRE(ip,1)
        EXEC
    ELSE
        RPUSHX(ip,ip)
    END
    PERFORM_API_CALL()
END
</pre></div>
</div>
<p>新的限速器使用了列表结构作为容器， <a class="reference internal" href="index.html#llen"><em>LLEN</em></a> 用于对访问次数进行检查，一个事务包裹着 <a class="reference internal" href="index.html#rpush"><em>RPUSH</em></a> 和 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 两个命令，用于在第一次执行计数时创建列表，并正确设置地设置过期时间，最后， <a class="reference internal" href="index.html#rpushx"><em>RPUSHX</em></a> 在后续的计数操作中进行增加操作。</p>
</div>
</div>
<span id="document-string/incrby"></span><div class="section" id="incrby">
<span id="id1"></span><h4>INCRBY<a class="headerlink" href="#incrby" title="Permalink to this headline">¶</a></h4>
<p><strong>INCRBY key increment</strong></p>
<p>将 <tt class="docutils literal"><span class="pre">key</span></tt> 所储存的值加上增量 <tt class="docutils literal"><span class="pre">increment</span></tt> 。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，那么 <tt class="docutils literal"><span class="pre">key</span></tt> 的值会先被初始化为 <tt class="docutils literal"><span class="pre">0</span></tt> ，然后再执行 <a class="reference internal" href="#incrby">INCRBY</a> 命令。</p>
<p>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。</p>
<p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p>
<p>关于递增(increment) / 递减(decrement)操作的更多信息，参见 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>加上 <tt class="docutils literal"><span class="pre">increment</span></tt> 之后， <tt class="docutils literal"><span class="pre">key</span></tt> 的值。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># key 存在且是数字值

redis&gt; SET rank 50
OK

redis&gt; INCRBY rank 20
(integer) 70

redis&gt; GET rank
&quot;70&quot;


# key 不存在时

redis&gt; EXISTS counter
(integer) 0

redis&gt; INCRBY counter 30
(integer) 30

redis&gt; GET counter
&quot;30&quot;


# key 不是数字值时

redis&gt; SET book &quot;long long ago...&quot;
OK

redis&gt; INCRBY book 200
(error) ERR value is not an integer or out of range
</pre></div>
</div>
</div>
<span id="document-string/incrbyfloat"></span><div class="section" id="incrbyfloat">
<span id="id1"></span><h4>INCRBYFLOAT<a class="headerlink" href="#incrbyfloat" title="Permalink to this headline">¶</a></h4>
<p><strong>INCRBYFLOAT key increment</strong></p>
<p>为 <tt class="docutils literal"><span class="pre">key</span></tt> 中所储存的值加上浮点数增量 <tt class="docutils literal"><span class="pre">increment</span></tt> 。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，那么 <a class="reference internal" href="#incrbyfloat">INCRBYFLOAT</a> 会先将 <tt class="docutils literal"><span class="pre">key</span></tt> 的值设为 <tt class="docutils literal"><span class="pre">0</span></tt> ，再执行加法操作。</p>
<p>如果命令执行成功，那么 <tt class="docutils literal"><span class="pre">key</span></tt> 的值会被更新为（执行加法之后的）新值，并且新值会以字符串的形式返回给调用者。</p>
<p>无论是 <tt class="docutils literal"><span class="pre">key</span></tt> 的值，还是增量 <tt class="docutils literal"><span class="pre">increment</span></tt> ，都可以使用像 <tt class="docutils literal"><span class="pre">2.0e7</span></tt> 、 <tt class="docutils literal"><span class="pre">3e5</span></tt> 、 <tt class="docutils literal"><span class="pre">90e-2</span></tt> 那样的指数符号(exponential notation)来表示，但是，<strong>执行 INCRBYFLOAT 命令之后的值</strong>总是以同样的形式储存，也即是，它们总是由一个数字，一个（可选的）小数点和一个任意位的小数部分组成（比如 <tt class="docutils literal"><span class="pre">3.14</span></tt> 、 <tt class="docutils literal"><span class="pre">69.768</span></tt> ，诸如此类)，小数部分尾随的 <tt class="docutils literal"><span class="pre">0</span></tt> 会被移除，如果有需要的话，还会将浮点数改为整数（比如 <tt class="docutils literal"><span class="pre">3.0</span></tt> 会被保存成 <tt class="docutils literal"><span class="pre">3</span></tt> ）。</p>
<p>除此之外，无论加法计算所得的浮点数的实际精度有多长， <a class="reference internal" href="#incrbyfloat">INCRBYFLOAT</a> 的计算结果也最多只能表示小数点的后十七位。</p>
<p>当以下任意一个条件发生时，返回一个错误：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">key</span></tt> 的值不是字符串类型(因为 Redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</li>
<li><tt class="docutils literal"><span class="pre">key</span></tt> 当前的值或者给定的增量 <tt class="docutils literal"><span class="pre">increment</span></tt> 不能解释(parse)为双精度浮点数(double precision floating point number）</li>
</ul>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>执行命令之后 <tt class="docutils literal"><span class="pre">key</span></tt> 的值。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 值和增量都不是指数符号

redis&gt; SET mykey 10.50
OK

redis&gt; INCRBYFLOAT mykey 0.1
&quot;10.6&quot;


# 值和增量都是指数符号

redis&gt; SET mykey 314e-2
OK

redis&gt; GET mykey                # 用 SET 设置的值可以是指数符号
&quot;314e-2&quot;

redis&gt; INCRBYFLOAT mykey 0      # 但执行 INCRBYFLOAT 之后格式会被改成非指数符号
&quot;3.14&quot;


# 可以对整数类型执行

redis&gt; SET mykey 3
OK

redis&gt; INCRBYFLOAT mykey 1.1
&quot;4.1&quot;


# 后跟的 0 会被移除

redis&gt; SET mykey 3.0
OK

redis&gt; GET mykey                                    # SET 设置的值小数部分可以是 0
&quot;3.0&quot;

redis&gt; INCRBYFLOAT mykey 1.000000000000000000000    # 但 INCRBYFLOAT 会将无用的 0 忽略掉，有需要的话，将浮点变为整数
&quot;4&quot;

redis&gt; GET mykey
&quot;4&quot;
</pre></div>
</div>
</div>
<span id="document-string/mget"></span><div class="section" id="mget">
<span id="id1"></span><h4>MGET<a class="headerlink" href="#mget" title="Permalink to this headline">¶</a></h4>
<p><strong>MGET key [key ...]</strong></p>
<p>返回所有(一个或多个)给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的值。</p>
<p>如果给定的 <tt class="docutils literal"><span class="pre">key</span></tt> 里面，有某个 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，那么这个 <tt class="docutils literal"><span class="pre">key</span></tt> 返回特殊值 <tt class="docutils literal"><span class="pre">nil</span></tt> 。因此，该命令永不失败。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N) , <tt class="docutils literal"><span class="pre">N</span></tt> 为给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>一个包含所有给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的值的列表。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET redis redis.com
OK

redis&gt; SET mongodb mongodb.org
OK

redis&gt; MGET redis mongodb
1) &quot;redis.com&quot;
2) &quot;mongodb.org&quot;

redis&gt; MGET redis mongodb mysql     # 不存在的 mysql 返回 nil
1) &quot;redis.com&quot;
2) &quot;mongodb.org&quot;
3) (nil)
</pre></div>
</div>
</div>
<span id="document-string/mset"></span><div class="section" id="mset">
<span id="id1"></span><h4>MSET<a class="headerlink" href="#mset" title="Permalink to this headline">¶</a></h4>
<p><strong>MSET key value [key value ...]</strong></p>
<p>同时设置一个或多个 <tt class="docutils literal"><span class="pre">key-value</span></tt> 对。</p>
<p>如果某个给定 <tt class="docutils literal"><span class="pre">key</span></tt> 已经存在，那么 <a class="reference internal" href="#mset">MSET</a> 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 <a class="reference internal" href="index.html#msetnx"><em>MSETNX</em></a> 命令：它只会在所有给定 <tt class="docutils literal"><span class="pre">key</span></tt> 都不存在的情况下进行设置操作。</p>
<p><a class="reference internal" href="#mset">MSET</a> 是一个原子性(atomic)操作，所有给定 <tt class="docutils literal"><span class="pre">key</span></tt> 都会在同一时间内被设置，某些给定 <tt class="docutils literal"><span class="pre">key</span></tt> 被更新而另一些给定 <tt class="docutils literal"><span class="pre">key</span></tt> 没有改变的情况，不可能发生。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.1</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为要设置的 <tt class="docutils literal"><span class="pre">key</span></tt> 数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> (因为 <tt class="docutils literal"><span class="pre">MSET</span></tt> 不可能失败)</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; MSET date &quot;2012.3.30&quot; time &quot;11:00 a.m.&quot; weather &quot;sunny&quot;
OK

redis&gt; MGET date time weather
1) &quot;2012.3.30&quot;
2) &quot;11:00 a.m.&quot;
3) &quot;sunny&quot;


# MSET 覆盖旧值例子

redis&gt; SET google &quot;google.hk&quot;
OK

redis&gt; MSET google &quot;google.com&quot;
OK

redis&gt; GET google
&quot;google.com&quot;
</pre></div>
</div>
</div>
<span id="document-string/msetnx"></span><div class="section" id="msetnx">
<span id="id1"></span><h4>MSETNX<a class="headerlink" href="#msetnx" title="Permalink to this headline">¶</a></h4>
<p><strong>MSETNX key value [key value ...]</strong></p>
<p>同时设置一个或多个 <tt class="docutils literal"><span class="pre">key-value</span></tt> 对，当且仅当所有给定 <tt class="docutils literal"><span class="pre">key</span></tt> 都不存在。</p>
<p>即使只有一个给定 <tt class="docutils literal"><span class="pre">key</span></tt> 已存在， <a class="reference internal" href="#msetnx">MSETNX</a> 也会拒绝执行所有给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的设置操作。</p>
<p><a class="reference internal" href="#msetnx">MSETNX</a> 是原子性的，因此它可以用作设置多个不同 <tt class="docutils literal"><span class="pre">key</span></tt> 表示不同字段(field)的唯一性逻辑对象(unique logic object)，所有字段要么全被设置，要么全不被设置。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.1</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为要设置的 <tt class="docutils literal"><span class="pre">key</span></tt> 的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">当所有 <tt class="docutils literal"><span class="pre">key</span></tt> 都成功设置，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">如果所有给定 <tt class="docutils literal"><span class="pre">key</span></tt> 都设置失败(至少有一个 <tt class="docutils literal"><span class="pre">key</span></tt> 已经存在)，那么返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对不存在的 key 进行 MSETNX

redis&gt; MSETNX rmdbs &quot;MySQL&quot; nosql &quot;MongoDB&quot; key-value-store &quot;redis&quot;
(integer) 1

redis&gt; MGET rmdbs nosql key-value-store
1) &quot;MySQL&quot;
2) &quot;MongoDB&quot;
3) &quot;redis&quot;


# MSET 的给定 key 当中有已存在的 key

redis&gt; MSETNX rmdbs &quot;Sqlite&quot; language &quot;python&quot;  # rmdbs 键已经存在，操作失败
(integer) 0

redis&gt; EXISTS language                          # 因为 MSET 是原子性操作，language 没有被设置
(integer) 0

redis&gt; GET rmdbs                                # rmdbs 也没有被修改
&quot;MySQL&quot;
</pre></div>
</div>
</div>
<span id="document-string/psetex"></span><div class="section" id="psetex">
<span id="id1"></span><h4>PSETEX<a class="headerlink" href="#psetex" title="Permalink to this headline">¶</a></h4>
<p><strong>PSETEX key milliseconds value</strong></p>
<p>这个命令和 <a class="reference internal" href="index.html#setex"><em>SETEX</em></a> 命令相似，但它以毫秒为单位设置 <tt class="docutils literal"><span class="pre">key</span></tt> 的生存时间，而不是像 <a class="reference internal" href="index.html#setex"><em>SETEX</em></a> 命令那样，以秒为单位。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>设置成功时返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; PSETEX mykey 1000 &quot;Hello&quot;
OK

redis&gt; PTTL mykey
(integer) 999

redis&gt; GET mykey
&quot;Hello&quot;
</pre></div>
</div>
</div>
<span id="document-string/set"></span><div class="section" id="set">
<span id="id1"></span><h4>SET<a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h4>
<p><strong>SET key value [EX seconds] [PX milliseconds] [NX|XX]</strong></p>
<p>将字符串值 <tt class="docutils literal"><span class="pre">value</span></tt> 关联到 <tt class="docutils literal"><span class="pre">key</span></tt> 。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 已经持有其他值， <a class="reference internal" href="#set">SET</a> 就覆写旧值，无视类型。</p>
<p>对于某个原本带有生存时间（TTL）的键来说，
当 <a class="reference internal" href="index.html#set"><em>SET</em></a> 命令成功在这个键上执行时，
这个键原有的 TTL 将被清除。</p>
<p><strong>可选参数</strong></p>
<p>从 Redis 2.6.12 版本开始， <a class="reference internal" href="index.html#set"><em>SET</em></a> 命令的行为可以通过一系列参数来修改：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">EX</span> <span class="pre">second</span></tt> ：设置键的过期时间为 <tt class="docutils literal"><span class="pre">second</span></tt> 秒。 <tt class="docutils literal"><span class="pre">SET</span> <span class="pre">key</span> <span class="pre">value</span> <span class="pre">EX</span> <span class="pre">second</span></tt> 效果等同于 <tt class="docutils literal"><span class="pre">SETEX</span> <span class="pre">key</span> <span class="pre">second</span> <span class="pre">value</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">PX</span> <span class="pre">millisecond</span></tt> ：设置键的过期时间为 <tt class="docutils literal"><span class="pre">millisecond</span></tt> 毫秒。 <tt class="docutils literal"><span class="pre">SET</span> <span class="pre">key</span> <span class="pre">value</span> <span class="pre">PX</span> <span class="pre">millisecond</span></tt> 效果等同于 <tt class="docutils literal"><span class="pre">PSETEX</span> <span class="pre">key</span> <span class="pre">millisecond</span> <span class="pre">value</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">NX</span></tt> ：只在键不存在时，才对键进行设置操作。 <tt class="docutils literal"><span class="pre">SET</span> <span class="pre">key</span> <span class="pre">value</span> <span class="pre">NX</span></tt> 效果等同于 <tt class="docutils literal"><span class="pre">SETNX</span> <span class="pre">key</span> <span class="pre">value</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">XX</span></tt> ：只在键已经存在时，才对键进行设置操作。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">因为 <a class="reference internal" href="index.html#set"><em>SET</em></a> 命令可以通过参数来实现和 <a class="reference internal" href="index.html#setnx"><em>SETNX</em></a> 、 <a class="reference internal" href="index.html#setex"><em>SETEX</em></a> 和 <a class="reference internal" href="index.html#psetex"><em>PSETEX</em></a> 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除 <a class="reference internal" href="index.html#setnx"><em>SETNX</em></a> 、 <a class="reference internal" href="index.html#setex"><em>SETEX</em></a> 和 <a class="reference internal" href="index.html#psetex"><em>PSETEX</em></a> 这三个命令。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><p class="first">在 Redis 2.6.12 版本以前， <a class="reference internal" href="index.html#set"><em>SET</em></a> 命令总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</p>
<div class="last line-block">
<div class="line">从 Redis 2.6.12 版本开始， <a class="reference internal" href="index.html#set"><em>SET</em></a> 在设置操作成功完成时，才返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</div>
<div class="line">如果设置了 <tt class="docutils literal"><span class="pre">NX</span></tt> 或者 <tt class="docutils literal"><span class="pre">XX</span></tt> ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对不存在的键进行设置

redis 127.0.0.1:6379&gt; SET key &quot;value&quot;
OK

redis 127.0.0.1:6379&gt; GET key
&quot;value&quot;


# 对已存在的键进行设置

redis 127.0.0.1:6379&gt; SET key &quot;new-value&quot;
OK

redis 127.0.0.1:6379&gt; GET key
&quot;new-value&quot;


# 使用 EX 选项

redis 127.0.0.1:6379&gt; SET key-with-expire-time &quot;hello&quot; EX 10086
OK

redis 127.0.0.1:6379&gt; GET key-with-expire-time
&quot;hello&quot;

redis 127.0.0.1:6379&gt; TTL key-with-expire-time
(integer) 10069


# 使用 PX 选项

redis 127.0.0.1:6379&gt; SET key-with-pexpire-time &quot;moto&quot; PX 123321
OK

redis 127.0.0.1:6379&gt; GET key-with-pexpire-time
&quot;moto&quot;

redis 127.0.0.1:6379&gt; PTTL key-with-pexpire-time
(integer) 111939


# 使用 NX 选项

redis 127.0.0.1:6379&gt; SET not-exists-key &quot;value&quot; NX
OK      # 键不存在，设置成功

redis 127.0.0.1:6379&gt; GET not-exists-key
&quot;value&quot;

redis 127.0.0.1:6379&gt; SET not-exists-key &quot;new-value&quot; NX
(nil)   # 键已经存在，设置失败

redis 127.0.0.1:6379&gt; GEt not-exists-key
&quot;value&quot; # 维持原值不变


# 使用 XX 选项

redis 127.0.0.1:6379&gt; EXISTS exists-key
(integer) 0

redis 127.0.0.1:6379&gt; SET exists-key &quot;value&quot; XX
(nil)   # 因为键不存在，设置失败

redis 127.0.0.1:6379&gt; SET exists-key &quot;value&quot;
OK      # 先给键设置一个值

redis 127.0.0.1:6379&gt; SET exists-key &quot;new-value&quot; XX
OK      # 设置新值成功

redis 127.0.0.1:6379&gt; GET exists-key
&quot;new-value&quot;


# NX 或 XX 可以和 EX 或者 PX 组合使用

redis 127.0.0.1:6379&gt; SET key-with-expire-and-NX &quot;hello&quot; EX 10086 NX
OK

redis 127.0.0.1:6379&gt; GET key-with-expire-and-NX
&quot;hello&quot;

redis 127.0.0.1:6379&gt; TTL key-with-expire-and-NX
(integer) 10063

redis 127.0.0.1:6379&gt; SET key-with-pexpire-and-XX &quot;old value&quot;
OK

redis 127.0.0.1:6379&gt; SET key-with-pexpire-and-XX &quot;new value&quot; PX 123321
OK

redis 127.0.0.1:6379&gt; GET key-with-pexpire-and-XX
&quot;new value&quot;

redis 127.0.0.1:6379&gt; PTTL key-with-pexpire-and-XX
(integer) 112999


# EX 和 PX 可以同时出现，但后面给出的选项会覆盖前面给出的选项

redis 127.0.0.1:6379&gt; SET key &quot;value&quot; EX 1000 PX 5000000
OK

redis 127.0.0.1:6379&gt; TTL key
(integer) 4993  # 这是 PX 参数设置的值

redis 127.0.0.1:6379&gt; SET another-key &quot;value&quot; PX 5000000 EX 1000
OK

redis 127.0.0.1:6379&gt; TTL another-key
(integer) 997   # 这是 EX 参数设置的值
</pre></div>
</div>
<div class="section" id="id2">
<h5>使用模式<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>命令 <tt class="docutils literal"><span class="pre">SET</span> <span class="pre">resource-name</span> <span class="pre">anystring</span> <span class="pre">NX</span> <span class="pre">EX</span> <span class="pre">max-lock-time</span></tt> 是一种在 Redis 中实现锁的简单方法。</p>
<p>客户端执行以上的命令：</p>
<ul class="simple">
<li>如果服务器返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，那么这个客户端获得锁。</li>
<li>如果服务器返回 <tt class="docutils literal"><span class="pre">NIL</span></tt> ，那么客户端获取锁失败，可以在稍后再重试。</li>
</ul>
<p>设置的过期时间到达之后，锁将自动释放。</p>
<p>可以通过以下修改，让这个锁实现更健壮：</p>
<ul class="simple">
<li>不使用固定的字符串作为键的值，而是设置一个不可猜测（non-guessable）的长随机字符串，作为口令串（token）。</li>
<li>不使用 <a class="reference internal" href="index.html#del"><em>DEL</em></a> 命令来释放锁，而是发送一个 Lua 脚本，这个脚本只在客户端传入的值和键的口令串相匹配时，才对键进行删除。</li>
</ul>
<p>这两个改动可以防止持有过期锁的客户端误删现有锁的情况出现。</p>
<p>以下是一个简单的解锁脚本示例：</p>
<div class="highlight-lua"><div class="highlight"><pre><span class="k">if</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">get&quot;</span><span class="p">,</span><span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">then</span>
    <span class="k">return</span> <span class="n">redis</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">del&quot;</span><span class="p">,</span><span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">else</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="k">end</span>
</pre></div>
</div>
<p>这个脚本可以通过 <tt class="docutils literal"><span class="pre">EVAL</span> <span class="pre">...script...</span> <span class="pre">1</span> <span class="pre">resource-name</span> <span class="pre">token-value</span></tt> 命令来调用。</p>
</div>
</div>
<span id="document-string/setbit"></span><div class="section" id="setbit">
<span id="id1"></span><h4>SETBIT<a class="headerlink" href="#setbit" title="Permalink to this headline">¶</a></h4>
<p><strong>SETBIT key offset value</strong></p>
<p>对 <tt class="docutils literal"><span class="pre">key</span></tt> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p>
<p>位的设置或清除取决于 <tt class="docutils literal"><span class="pre">value</span></tt> 参数，可以是 <tt class="docutils literal"><span class="pre">0</span></tt> 也可以是 <tt class="docutils literal"><span class="pre">1</span></tt> 。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，自动生成一个新的字符串值。</p>
<p>字符串会进行伸展(grown)以确保它可以将 <tt class="docutils literal"><span class="pre">value</span></tt> 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 <tt class="docutils literal"><span class="pre">0</span></tt> 填充。</p>
<p><tt class="docutils literal"><span class="pre">offset</span></tt> 参数必须大于或等于 <tt class="docutils literal"><span class="pre">0</span></tt> ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">对使用大的 <tt class="docutils literal"><span class="pre">offset</span></tt> 的 <a class="reference internal" href="#setbit">SETBIT</a> 操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考 <a class="reference internal" href="index.html#setrange"><em>SETRANGE</em></a> 命令，warning(警告)部分。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>指定偏移量原来储存的位。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SETBIT bit 10086 1
(integer) 0

redis&gt; GETBIT bit 10086
(integer) 1

redis&gt; GETBIT bit 100   # bit 默认被初始化为 0
(integer) 0
</pre></div>
</div>
</div>
<span id="document-string/setex"></span><div class="section" id="setex">
<span id="id1"></span><h4>SETEX<a class="headerlink" href="#setex" title="Permalink to this headline">¶</a></h4>
<p><strong>SETEX key seconds value</strong></p>
<p>将值 <tt class="docutils literal"><span class="pre">value</span></tt> 关联到 <tt class="docutils literal"><span class="pre">key</span></tt> ，并将 <tt class="docutils literal"><span class="pre">key</span></tt> 的生存时间设为 <tt class="docutils literal"><span class="pre">seconds</span></tt> (以秒为单位)。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 已经存在， <a class="reference internal" href="#setex">SETEX</a> 命令将覆写旧值。</p>
<p>这个命令类似于以下两个命令：</p>
<div class="highlight-python"><div class="highlight"><pre>SET key value
EXPIRE key seconds  # 设置生存时间
</pre></div>
</div>
<p>不同之处是， <a class="reference internal" href="#setex">SETEX</a> 是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成，该命令在 Redis 用作缓存时，非常实用。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">设置成功时返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">seconds</span></tt> 参数不合法时，返回一个错误。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 在 key 不存在时进行 SETEX

redis&gt; SETEX cache_user_id 60 10086
OK

redis&gt; GET cache_user_id  # 值
&quot;10086&quot;

redis&gt; TTL cache_user_id  # 剩余生存时间
(integer) 49


# key 已经存在时，SETEX 覆盖旧值

redis&gt; SET cd &quot;timeless&quot;
OK

redis&gt; SETEX cd 3000 &quot;goodbye my love&quot;
OK

redis&gt; GET cd
&quot;goodbye my love&quot;

redis&gt; TTL cd
(integer) 2997
</pre></div>
</div>
</div>
<span id="document-string/setnx"></span><div class="section" id="setnx">
<span id="id1"></span><h4>SETNX<a class="headerlink" href="#setnx" title="Permalink to this headline">¶</a></h4>
<p><strong>SETNX key value</strong></p>
<p>将 <tt class="docutils literal"><span class="pre">key</span></tt> 的值设为 <tt class="docutils literal"><span class="pre">value</span></tt> ，当且仅当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在。</p>
<p>若给定的 <tt class="docutils literal"><span class="pre">key</span></tt> 已经存在，则 <a class="reference internal" href="#setnx">SETNX</a> 不做任何动作。</p>
<p><a class="reference internal" href="#setnx">SETNX</a> 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">设置成功，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">设置失败，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; EXISTS job                # job 不存在
(integer) 0

redis&gt; SETNX job &quot;programmer&quot;    # job 设置成功
(integer) 1

redis&gt; SETNX job &quot;code-farmer&quot;   # 尝试覆盖 job ，失败
(integer) 0

redis&gt; GET job                   # 没有被覆盖
&quot;programmer&quot;
</pre></div>
</div>
</div>
<span id="document-string/setrange"></span><div class="section" id="setrange">
<span id="id1"></span><h4>SETRANGE<a class="headerlink" href="#setrange" title="Permalink to this headline">¶</a></h4>
<p><strong>SETRANGE key offset value</strong></p>
<p>用 <tt class="docutils literal"><span class="pre">value</span></tt> 参数覆写(overwrite)给定 <tt class="docutils literal"><span class="pre">key</span></tt> 所储存的字符串值，从偏移量 <tt class="docutils literal"><span class="pre">offset</span></tt> 开始。</p>
<p>不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 当作空白字符串处理。</p>
<p><a class="reference internal" href="#setrange">SETRANGE</a> 命令会确保字符串足够长以便将 <tt class="docutils literal"><span class="pre">value</span></tt> 设置在指定的偏移量上，如果给定 <tt class="docutils literal"><span class="pre">key</span></tt> 原来储存的字符串长度比偏移量小(比如字符串只有 <tt class="docutils literal"><span class="pre">5</span></tt> 个字符长，但你设置的 <tt class="docutils literal"><span class="pre">offset</span></tt> 是 <tt class="docutils literal"><span class="pre">10</span></tt> )，那么原字符和偏移量之间的空白将用零字节(zerobytes, <tt class="docutils literal"><span class="pre">&quot;\x00&quot;</span></tt> )来填充。</p>
<p>注意你能使用的最大偏移量是 2^29-1(536870911) ，因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内。如果你需要使用比这更大的空间，你可以使用多个 <tt class="docutils literal"><span class="pre">key</span></tt> 。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">当生成一个很长的字符串时，Redis 需要分配内存空间，该操作有时候可能会造成服务器阻塞(block)。在2010年的Macbook Pro上，设置偏移量为 536870911(512MB 内存分配)，耗费约 300 毫秒，
设置偏移量为 134217728(128MB 内存分配)，耗费约 80 毫秒，设置偏移量 33554432(32MB 内存分配)，耗费约 30 毫秒，设置偏移量为 8388608(8MB 内存分配)，耗费约 8 毫秒。
注意若首次内存分配成功之后，再对同一个 <tt class="docutils literal"><span class="pre">key</span></tt> 调用 <a class="reference internal" href="#setrange">SETRANGE</a> 操作，无须再重新内存。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first last line-block">
<div class="line">对小(small)的字符串，平摊复杂度O(1)。(关于什么字符串是&#8221;小&#8221;的，请参考 <a class="reference internal" href="index.html#append"><em>APPEND</em></a> 命令)</div>
<div class="line">否则为O(M)， <tt class="docutils literal"><span class="pre">M</span></tt> 为 <tt class="docutils literal"><span class="pre">value</span></tt> 参数的长度。</div>
</div>
</dd>
<dt><strong>返回值：</strong></dt>
<dd>被 <a class="reference internal" href="#setrange">SETRANGE</a> 修改之后，字符串的长度。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对非空字符串进行 SETRANGE

redis&gt; SET greeting &quot;hello world&quot;
OK

redis&gt; SETRANGE greeting 6 &quot;Redis&quot;
(integer) 11

redis&gt; GET greeting
&quot;hello Redis&quot;


# 对空字符串/不存在的 key 进行 SETRANGE

redis&gt; EXISTS empty_string
(integer) 0

redis&gt; SETRANGE empty_string 5 &quot;Redis!&quot;   # 对不存在的 key 使用 SETRANGE
(integer) 11

redis&gt; GET empty_string                   # 空白处被&quot;\x00&quot;填充
&quot;\x00\x00\x00\x00\x00Redis!&quot;
</pre></div>
</div>
<div class="section" id="id2">
<h5>模式<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>因为有了 <a class="reference internal" href="#setrange">SETRANGE</a> 和 <a class="reference internal" href="index.html#getrange"><em>GETRANGE</em></a> 命令，你可以将 Redis 字符串用作具有O(1)随机访问时间的线性数组，这在很多真实用例中都是非常快速且高效的储存方式，具体请参考 <a class="reference internal" href="index.html#append"><em>APPEND</em></a> 命令的『模式：时间序列』部分。</p>
</div>
</div>
<span id="document-string/strlen"></span><div class="section" id="strlen">
<span id="id1"></span><h4>STRLEN<a class="headerlink" href="#strlen" title="Permalink to this headline">¶</a></h4>
<p><strong>STRLEN key</strong></p>
<p>返回 <tt class="docutils literal"><span class="pre">key</span></tt> 所储存的字符串值的长度。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 储存的不是字符串值时，返回一个错误。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">字符串值的长度。</div>
<div class="line">当  <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 获取字符串的长度

redis&gt; SET mykey &quot;Hello world&quot;
OK

redis&gt; STRLEN mykey
(integer) 11


# 不存在的 key 长度为 0

redis&gt; STRLEN nonexisting
(integer) 0
</pre></div>
</div>
</div>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-hash/index"></span><div class="section" id="hash">
<h3>Hash（哈希表）<a class="headerlink" href="#hash" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-hash/hdel"></span><div class="section" id="hdel">
<span id="id1"></span><h4>HDEL<a class="headerlink" href="#hdel" title="Permalink to this headline">¶</a></h4>
<p><strong>HDEL key field [field ...]</strong></p>
<p>删除哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中的一个或多个指定域，不存在的域将被忽略。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在Redis2.4以下的版本里， <a class="reference internal" href="#hdel">HDEL</a> 每次只能删除单个域，如果你需要在一个原子时间内删除多个域，请将命令包含在 <a class="reference internal" href="index.html#multi"><em>MULTI</em></a> /  <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 块内。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为要删除的域的数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd>被成功移除的域的数量，不包括被忽略的域。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 测试数据

redis&gt; HGETALL abbr
1) &quot;a&quot;
2) &quot;apple&quot;
3) &quot;b&quot;
4) &quot;banana&quot;
5) &quot;c&quot;
6) &quot;cat&quot;
7) &quot;d&quot;
8) &quot;dog&quot;


# 删除单个域

redis&gt; HDEL abbr a
(integer) 1


# 删除不存在的域

redis&gt; HDEL abbr not-exists-field
(integer) 0


# 删除多个域

redis&gt; HDEL abbr b c
(integer) 2

redis&gt; HGETALL abbr
1) &quot;d&quot;
2) &quot;dog&quot;
</pre></div>
</div>
</div>
<span id="document-hash/hexists"></span><div class="section" id="hexists">
<span id="id1"></span><h4>HEXISTS<a class="headerlink" href="#hexists" title="Permalink to this headline">¶</a></h4>
<p><strong>HEXISTS key field</strong></p>
<p>查看哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中，给定域 <tt class="docutils literal"><span class="pre">field</span></tt> 是否存在。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果哈希表含有给定域，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">如果哈希表不含有给定域，或 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; HEXISTS phone myphone
(integer) 0

redis&gt; HSET phone myphone nokia-1110
(integer) 1

redis&gt; HEXISTS phone myphone
(integer) 1
</pre></div>
</div>
</div>
<span id="document-hash/hget"></span><div class="section" id="hget">
<span id="id1"></span><h4>HGET<a class="headerlink" href="#hget" title="Permalink to this headline">¶</a></h4>
<p><strong>HGET key field</strong></p>
<p>返回哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中给定域 <tt class="docutils literal"><span class="pre">field</span></tt> 的值。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">给定域的值。</div>
<div class="line">当给定域不存在或是给定 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 域存在

redis&gt; HSET site redis redis.com
(integer) 1

redis&gt; HGET site redis
&quot;redis.com&quot;


# 域不存在

redis&gt; HGET site mysql
(nil)
</pre></div>
</div>
</div>
<span id="document-hash/hgetall"></span><div class="section" id="hgetall">
<span id="id1"></span><h4>HGETALL<a class="headerlink" href="#hgetall" title="Permalink to this headline">¶</a></h4>
<p><strong>HGETALL key</strong></p>
<p>返回哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中，所有的域和值。</p>
<p>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为哈希表的大小。</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">以列表形式返回哈希表的域和域的值。</div>
<div class="line">若 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，返回空列表。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; HSET people jack &quot;Jack Sparrow&quot;
(integer) 1

redis&gt; HSET people gump &quot;Forrest Gump&quot;
(integer) 1

redis&gt; HGETALL people
1) &quot;jack&quot;          # 域
2) &quot;Jack Sparrow&quot;  # 值
3) &quot;gump&quot;
4) &quot;Forrest Gump&quot;
</pre></div>
</div>
</div>
<span id="document-hash/hincrby"></span><div class="section" id="hincrby">
<span id="id1"></span><h4>HINCRBY<a class="headerlink" href="#hincrby" title="Permalink to this headline">¶</a></h4>
<p><strong>HINCRBY key field increment</strong></p>
<p>为哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中的域 <tt class="docutils literal"><span class="pre">field</span></tt> 的值加上增量 <tt class="docutils literal"><span class="pre">increment</span></tt> 。</p>
<p>增量也可以为负数，相当于对给定域进行减法操作。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，一个新的哈希表被创建并执行 <a class="reference internal" href="#hincrby">HINCRBY</a> 命令。</p>
<p>如果域 <tt class="docutils literal"><span class="pre">field</span></tt> 不存在，那么在执行命令前，域的值被初始化为 <tt class="docutils literal"><span class="pre">0</span></tt> 。</p>
<p>对一个储存字符串值的域 <tt class="docutils literal"><span class="pre">field</span></tt> 执行 <a class="reference internal" href="#hincrby">HINCRBY</a> 命令将造成一个错误。</p>
<p>本操作的值被限制在 64 位(bit)有符号数字表示之内。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>执行 <a class="reference internal" href="#hincrby">HINCRBY</a> 命令之后，哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中域 <tt class="docutils literal"><span class="pre">field</span></tt> 的值。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># increment 为正数

redis&gt; HEXISTS counter page_view    # 对空域进行设置
(integer) 0

redis&gt; HINCRBY counter page_view 200
(integer) 200

redis&gt; HGET counter page_view
&quot;200&quot;


# increment 为负数

redis&gt; HGET counter page_view
&quot;200&quot;

redis&gt; HINCRBY counter page_view -50
(integer) 150

redis&gt; HGET counter page_view
&quot;150&quot;


# 尝试对字符串值的域执行HINCRBY命令

redis&gt; HSET myhash string hello,world       # 设定一个字符串值
(integer) 1

redis&gt; HGET myhash string
&quot;hello,world&quot;

redis&gt; HINCRBY myhash string 1              # 命令执行失败，错误。
(error) ERR hash value is not an integer

redis&gt; HGET myhash string                   # 原值不变
&quot;hello,world&quot;
</pre></div>
</div>
</div>
<span id="document-hash/hincrbyfloat"></span><div class="section" id="hincrbyfloat">
<span id="id1"></span><h4>HINCRBYFLOAT<a class="headerlink" href="#hincrbyfloat" title="Permalink to this headline">¶</a></h4>
<p><strong>HINCRBYFLOAT key field increment</strong></p>
<p>为哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中的域 <tt class="docutils literal"><span class="pre">field</span></tt> 加上浮点数增量 <tt class="docutils literal"><span class="pre">increment</span></tt> 。</p>
<p>如果哈希表中没有域 <tt class="docutils literal"><span class="pre">field</span></tt> ，那么 <a class="reference internal" href="#hincrbyfloat">HINCRBYFLOAT</a> 会先将域 <tt class="docutils literal"><span class="pre">field</span></tt> 的值设为 <tt class="docutils literal"><span class="pre">0</span></tt> ，然后再执行加法操作。</p>
<p>如果键 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，那么 <a class="reference internal" href="#hincrbyfloat">HINCRBYFLOAT</a> 会先创建一个哈希表，再创建域 <tt class="docutils literal"><span class="pre">field</span></tt> ，最后再执行加法操作。</p>
<p>当以下任意一个条件发生时，返回一个错误：</p>
<ul class="simple">
<li>域 <tt class="docutils literal"><span class="pre">field</span></tt> 的值不是字符串类型(因为 redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</li>
<li>域 <tt class="docutils literal"><span class="pre">field</span></tt> 当前的值或给定的增量 <tt class="docutils literal"><span class="pre">increment</span></tt> 不能解释(parse)为双精度浮点数(double precision floating point number)</li>
</ul>
<p><a class="reference internal" href="#hincrbyfloat">HINCRBYFLOAT</a> 命令的详细功能和 <a class="reference internal" href="index.html#incrbyfloat"><em>INCRBYFLOAT</em></a> 命令类似，请查看 <a class="reference internal" href="index.html#incrbyfloat"><em>INCRBYFLOAT</em></a> 命令获取更多相关信息。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>执行加法操作之后 <tt class="docutils literal"><span class="pre">field</span></tt> 域的值。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 值和增量都是普通小数

redis&gt; HSET mykey field 10.50
(integer) 1
redis&gt; HINCRBYFLOAT mykey field 0.1
&quot;10.6&quot;


# 值和增量都是指数符号

redis&gt; HSET mykey field 5.0e3
(integer) 0
redis&gt; HINCRBYFLOAT mykey field 2.0e2
&quot;5200&quot;


# 对不存在的键执行 HINCRBYFLOAT

redis&gt; EXISTS price
(integer) 0
redis&gt; HINCRBYFLOAT price milk 3.5
&quot;3.5&quot;
redis&gt; HGETALL price
1) &quot;milk&quot;
2) &quot;3.5&quot;


# 对不存在的域进行 HINCRBYFLOAT

redis&gt; HGETALL price
1) &quot;milk&quot;
2) &quot;3.5&quot;
redis&gt; HINCRBYFLOAT price coffee 4.5   # 新增 coffee 域
&quot;4.5&quot;
redis&gt; HGETALL price
1) &quot;milk&quot;
2) &quot;3.5&quot;
3) &quot;coffee&quot;
4) &quot;4.5&quot;
</pre></div>
</div>
</div>
<span id="document-hash/hkeys"></span><div class="section" id="hkeys">
<span id="id1"></span><h4>HKEYS<a class="headerlink" href="#hkeys" title="Permalink to this headline">¶</a></h4>
<p><strong>HKEYS key</strong></p>
<p>返回哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中的所有域。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为哈希表的大小。</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">一个包含哈希表中所有域的表。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回一个空表。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 哈希表非空

redis&gt; HMSET website google www.google.com yahoo www.yahoo.com
OK

redis&gt; HKEYS website
1) &quot;google&quot;
2) &quot;yahoo&quot;


# 空哈希表/key不存在

redis&gt; EXISTS fake_key
(integer) 0

redis&gt; HKEYS fake_key
(empty list or set)
</pre></div>
</div>
</div>
<span id="document-hash/hlen"></span><div class="section" id="hlen">
<span id="id1"></span><h4>HLEN<a class="headerlink" href="#hlen" title="Permalink to this headline">¶</a></h4>
<p><strong>HLEN key</strong></p>
<p>返回哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中域的数量。</p>
<dl class="docutils">
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">哈希表中域的数量。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; HSET db redis redis.com
(integer) 1

redis&gt; HSET db mysql mysql.com
(integer) 1

redis&gt; HLEN db
(integer) 2

redis&gt; HSET db mongodb mongodb.org
(integer) 1

redis&gt; HLEN db
(integer) 3
</pre></div>
</div>
</div>
<span id="document-hash/hmget"></span><div class="section" id="hmget">
<span id="id1"></span><h4>HMGET<a class="headerlink" href="#hmget" title="Permalink to this headline">¶</a></h4>
<p><strong>HMGET key field [field ...]</strong></p>
<p>返回哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中，一个或多个给定域的值。</p>
<p>如果给定的域不存在于哈希表，那么返回一个 <tt class="docutils literal"><span class="pre">nil</span></tt> 值。</p>
<p>因为不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 被当作一个空哈希表来处理，所以对一个不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 进行 <a class="reference internal" href="#hmget">HMGET</a> 操作将返回一个只带有 <tt class="docutils literal"><span class="pre">nil</span></tt> 值的表。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为给定域的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; HMSET pet dog &quot;doudou&quot; cat &quot;nounou&quot;    # 一次设置多个域
OK

redis&gt; HMGET pet dog cat fake_pet             # 返回值的顺序和传入参数的顺序一样
1) &quot;doudou&quot;
2) &quot;nounou&quot;
3) (nil)                                      # 不存在的域返回nil值
</pre></div>
</div>
</div>
<span id="document-hash/hmset"></span><div class="section" id="hmset">
<span id="id1"></span><h4>HMSET<a class="headerlink" href="#hmset" title="Permalink to this headline">¶</a></h4>
<p><strong>HMSET key field value [field value ...]</strong></p>
<p>同时将多个 <tt class="docutils literal"><span class="pre">field-value</span></tt> (域-值)对设置到哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中。</p>
<p>此命令会覆盖哈希表中已存在的域。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，一个空哈希表被创建并执行 <a class="reference internal" href="#hmset">HMSET</a> 操作。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为 <tt class="docutils literal"><span class="pre">field-value</span></tt> 对的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果命令执行成功，返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不是哈希表(hash)类型时，返回一个错误。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; HMSET website google www.google.com yahoo www.yahoo.com
OK

redis&gt; HGET website google
&quot;www.google.com&quot;

redis&gt; HGET website yahoo
&quot;www.yahoo.com&quot;
</pre></div>
</div>
</div>
<span id="document-hash/hset"></span><div class="section" id="hset">
<span id="id1"></span><h4>HSET<a class="headerlink" href="#hset" title="Permalink to this headline">¶</a></h4>
<p><strong>HSET key field value</strong></p>
<p>将哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中的域 <tt class="docutils literal"><span class="pre">field</span></tt> 的值设为 <tt class="docutils literal"><span class="pre">value</span></tt> 。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，一个新的哈希表被创建并进行 <a class="reference internal" href="#hset">HSET</a> 操作。</p>
<p>如果域 <tt class="docutils literal"><span class="pre">field</span></tt> 已经存在于哈希表中，旧值将被覆盖。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果 <tt class="docutils literal"><span class="pre">field</span></tt> 是哈希表中的一个新建域，并且值设置成功，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">如果哈希表中域 <tt class="docutils literal"><span class="pre">field</span></tt> 已经存在且旧值已被新值覆盖，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; HSET website google &quot;www.g.cn&quot;       # 设置一个新域
(integer) 1

redis&gt; HSET website google &quot;www.google.com&quot; # 覆盖一个旧域
(integer) 0
</pre></div>
</div>
</div>
<span id="document-hash/hsetnx"></span><div class="section" id="hsetnx">
<span id="id1"></span><h4>HSETNX<a class="headerlink" href="#hsetnx" title="Permalink to this headline">¶</a></h4>
<p><strong>HSETNX key field value</strong></p>
<p>将哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中的域 <tt class="docutils literal"><span class="pre">field</span></tt> 的值设置为 <tt class="docutils literal"><span class="pre">value</span></tt> ，当且仅当域 <tt class="docutils literal"><span class="pre">field</span></tt> 不存在。</p>
<p>若域 <tt class="docutils literal"><span class="pre">field</span></tt> 已经存在，该操作无效。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，一个新哈希表被创建并执行 <a class="reference internal" href="#hsetnx">HSETNX</a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">设置成功，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">如果给定域已经存在且没有操作被执行，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; HSETNX nosql key-value-store redis
(integer) 1

redis&gt; HSETNX nosql key-value-store redis       # 操作无效，域 key-value-store 已存在
(integer) 0
</pre></div>
</div>
</div>
<span id="document-hash/hvals"></span><div class="section" id="hvals">
<span id="id1"></span><h4>HVALS<a class="headerlink" href="#hvals" title="Permalink to this headline">¶</a></h4>
<p><strong>HVALS key</strong></p>
<p>返回哈希表 <tt class="docutils literal"><span class="pre">key</span></tt> 中所有域的值。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为哈希表的大小。</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">一个包含哈希表中所有值的表。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回一个空表。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 非空哈希表

redis&gt; HMSET website google www.google.com yahoo www.yahoo.com
OK

redis&gt; HVALS website
1) &quot;www.google.com&quot;
2) &quot;www.yahoo.com&quot;


# 空哈希表/不存在的key

redis&gt; EXISTS not_exists
(integer) 0

redis&gt; HVALS not_exists
(empty list or set)
</pre></div>
</div>
</div>
<span id="document-hash/hscan"></span><div class="section" id="hscan">
<span id="id1"></span><h4>HSCAN<a class="headerlink" href="#hscan" title="Permalink to this headline">¶</a></h4>
<p><strong>HSCAN key cursor [MATCH pattern] [COUNT count]</strong></p>
<p>具体信息请参考 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令。</p>
</div>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-list/index"></span><div class="section" id="list">
<h3>List（列表）<a class="headerlink" href="#list" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-list/blpop"></span><div class="section" id="blpop">
<span id="id1"></span><h4>BLPOP<a class="headerlink" href="#blpop" title="Permalink to this headline">¶</a></h4>
<p><strong>BLPOP key [key ...] timeout</strong></p>
<p><a class="reference internal" href="#blpop">BLPOP</a> 是列表的阻塞式(blocking)弹出原语。</p>
<p>它是 <a class="reference internal" href="index.html#lpop"><em>LPOP</em></a> 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 <a class="reference internal" href="#blpop">BLPOP</a> 命令阻塞，直到等待超时或发现可弹出元素为止。</p>
<p>当给定多个 <tt class="docutils literal"><span class="pre">key</span></tt> 参数时，按参数 <tt class="docutils literal"><span class="pre">key</span></tt> 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p>
<p><strong>非阻塞行为</strong></p>
<p>当 <a class="reference internal" href="#blpop">BLPOP</a> 被调用时，如果给定 <tt class="docutils literal"><span class="pre">key</span></tt> 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。</p>
<p>当存在多个给定 <tt class="docutils literal"><span class="pre">key</span></tt> 时， <a class="reference internal" href="#blpop">BLPOP</a> 按给定 <tt class="docutils literal"><span class="pre">key</span></tt> 参数排列的先后顺序，依次检查各个列表。</p>
<p>假设现在有 <tt class="docutils literal"><span class="pre">job</span></tt> 、  <tt class="docutils literal"><span class="pre">command</span></tt> 和 <tt class="docutils literal"><span class="pre">request</span></tt> 三个列表，其中 <tt class="docutils literal"><span class="pre">job</span></tt> 不存在， <tt class="docutils literal"><span class="pre">command</span></tt> 和 <tt class="docutils literal"><span class="pre">request</span></tt> 都持有非空列表。考虑以下命令：</p>
<p><tt class="docutils literal"><span class="pre">BLPOP</span> <span class="pre">job</span> <span class="pre">command</span> <span class="pre">request</span> <span class="pre">0</span></tt></p>
<p><a class="reference internal" href="#blpop">BLPOP</a> 保证返回的元素来自 <tt class="docutils literal"><span class="pre">command</span></tt> ，因为它是按&#8221;查找 <tt class="docutils literal"><span class="pre">job</span></tt>  -&gt; 查找 <tt class="docutils literal"><span class="pre">command</span></tt>  -&gt; 查找 <tt class="docutils literal"><span class="pre">request</span></tt> &#8220;这样的顺序，第一个找到的非空列表。</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; DEL job command request           # 确保key都被删除
(integer) 0

redis&gt; LPUSH command &quot;update system...&quot;  # 为command列表增加一个值
(integer) 1

redis&gt; LPUSH request &quot;visit page&quot;        # 为request列表增加一个值
(integer) 1

redis&gt; BLPOP job command request 0       # job 列表为空，被跳过，紧接着 command 列表的第一个元素被弹出。
1) &quot;command&quot;                             # 弹出元素所属的列表
2) &quot;update system...&quot;                    # 弹出元素所属的值
</pre></div>
</div>
<p><strong>阻塞行为</strong></p>
<p>如果所有给定 <tt class="docutils literal"><span class="pre">key</span></tt> 都不存在或包含空列表，那么 <a class="reference internal" href="#blpop">BLPOP</a> 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的任意一个执行 <a class="reference internal" href="index.html#lpush"><em>LPUSH</em></a> 或 <a class="reference internal" href="index.html#rpush"><em>RPUSH</em></a> 命令为止。</p>
<p>超时参数 <tt class="docutils literal"><span class="pre">timeout</span></tt> 接受一个以秒为单位的数字作为值。超时参数设为 <tt class="docutils literal"><span class="pre">0</span></tt> 表示阻塞时间可以无限期延长(block indefinitely) 。</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; EXISTS job                # 确保两个 key 都不存在
(integer) 0
redis&gt; EXISTS command
(integer) 0

redis&gt; BLPOP job command 300     # 因为key一开始不存在，所以操作会被阻塞，直到另一客户端对 job 或者 command 列表进行 PUSH 操作。
1) &quot;job&quot;                         # 这里被 push 的是 job
2) &quot;do my home work&quot;             # 被弹出的值
(26.26s)                         # 等待的秒数

redis&gt; BLPOP job command 5       # 等待超时的情况
(nil)
(5.66s)                          # 等待的秒数
</pre></div>
</div>
<p><strong>相同的key被多个客户端同时阻塞</strong></p>
<p>相同的 <tt class="docutils literal"><span class="pre">key</span></tt> 可以被多个客户端同时阻塞。</p>
<p>不同的客户端被放进一个队列中，按『先阻塞先服务』(first-BLPOP，first-served)的顺序为 <tt class="docutils literal"><span class="pre">key</span></tt> 执行 <a class="reference internal" href="#blpop">BLPOP</a> 命令。</p>
<p><strong>在MULTI/EXEC事务中的BLPOP</strong></p>
<p><a class="reference internal" href="#blpop">BLPOP</a> 可以用于流水线(pipline,批量地发送多个命令并读入多个回复)，但把它用在 <a class="reference internal" href="index.html#multi"><em>MULTI</em></a> / <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 块当中没有意义。因为这要求整个服务器被阻塞以保证块执行时的原子性，该行为阻止了其他客户端执行 <a class="reference internal" href="index.html#lpush"><em>LPUSH</em></a> 或 <a class="reference internal" href="index.html#rpush"><em>RPUSH</em></a> 命令。</p>
<p>因此，一个被包裹在 <a class="reference internal" href="index.html#multi"><em>MULTI</em></a> / <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 块内的 <a class="reference internal" href="#blpop">BLPOP</a> 命令，行为表现得就像 <a class="reference internal" href="index.html#lpop"><em>LPOP</em></a> 一样，对空列表返回 <tt class="docutils literal"><span class="pre">nil</span></tt> ，对非空列表弹出列表元素，不进行任何阻塞操作。</p>
<div class="highlight-python"><div class="highlight"><pre># 对非空列表进行操作

redis&gt; RPUSH job programming
(integer) 1

redis&gt; MULTI
OK

redis&gt; BLPOP job 30
QUEUED

redis&gt; EXEC           # 不阻塞，立即返回
1) 1) &quot;job&quot;
   2) &quot;programming&quot;


# 对空列表进行操作

redis&gt; LLEN job      # 空列表
(integer) 0

redis&gt; MULTI
OK

redis&gt; BLPOP job 30
QUEUED

redis&gt; EXEC         # 不阻塞，立即返回
1) (nil)
</pre></div>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果列表为空，返回一个 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
<div class="line">否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <tt class="docutils literal"><span class="pre">key</span></tt> ，第二个元素是被弹出元素的值。</div>
</div>
</dd>
</dl>
<div class="section" id="id2">
<h5>模式：事件提醒<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>有时候，为了等待一个新元素到达数据中，需要使用轮询的方式对数据进行探查。</p>
<p>另一种更好的方式是，使用系统提供的阻塞原语，在新元素到达时立即进行处理，而新元素还没到达时，就一直阻塞住，避免轮询占用资源。</p>
<p>对于 Redis ，我们似乎需要一个阻塞版的 <a class="reference internal" href="index.html#spop"><em>SPOP</em></a> 命令，但实际上，使用 <a class="reference internal" href="#blpop">BLPOP</a> 或者 <a class="reference internal" href="index.html#brpop"><em>BRPOP</em></a> 就能很好地解决这个问题。</p>
<p>使用元素的客户端(消费者)可以执行类似以下的代码：</p>
<div class="highlight-python"><div class="highlight"><pre>LOOP forever
    WHILE SPOP(key) returns elements
        ... process elements ...
    END
    BRPOP helper_key
END
</pre></div>
</div>
<p>添加元素的客户端(消费者)则执行以下代码：</p>
<div class="highlight-python"><div class="highlight"><pre>MULTI
    SADD key element
    LPUSH helper_key x
EXEC
</pre></div>
</div>
</div>
</div>
<span id="document-list/brpop"></span><div class="section" id="brpop">
<span id="id1"></span><h4>BRPOP<a class="headerlink" href="#brpop" title="Permalink to this headline">¶</a></h4>
<p><strong>BRPOP key [key ...] timeout</strong></p>
<p><a class="reference internal" href="#brpop">BRPOP</a> 是列表的阻塞式(blocking)弹出原语。</p>
<p>它是 <a class="reference internal" href="index.html#rpop"><em>RPOP</em></a> 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 <a class="reference internal" href="#brpop">BRPOP</a> 命令阻塞，直到等待超时或发现可弹出元素为止。</p>
<p>当给定多个 <tt class="docutils literal"><span class="pre">key</span></tt> 参数时，按参数 <tt class="docutils literal"><span class="pre">key</span></tt> 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</p>
<p>关于阻塞操作的更多信息，请查看 <a class="reference internal" href="index.html#blpop"><em>BLPOP</em></a> 命令， <a class="reference internal" href="#brpop">BRPOP</a> 除了弹出元素的位置和 <a class="reference internal" href="index.html#blpop"><em>BLPOP</em></a> 不同之外，其他表现一致。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">假如在指定时间内没有任何元素被弹出，则返回一个 <tt class="docutils literal"><span class="pre">nil</span></tt> 和等待时长。</div>
<div class="line">反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <tt class="docutils literal"><span class="pre">key</span></tt> ，第二个元素是被弹出元素的值。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; LLEN course
(integer) 0

redis&gt; RPUSH course algorithm001
(integer) 1

redis&gt; RPUSH course c++101
(integer) 2

redis&gt; BRPOP course 30
1) &quot;course&quot;             # 被弹出元素所属的列表键
2) &quot;c++101&quot;             # 被弹出的元素
</pre></div>
</div>
</div>
<span id="document-list/brpoplpush"></span><div class="section" id="brpoplpush">
<span id="id1"></span><h4>BRPOPLPUSH<a class="headerlink" href="#brpoplpush" title="Permalink to this headline">¶</a></h4>
<p><strong>BRPOPLPUSH source destination timeout</strong></p>
<p><a class="reference internal" href="#brpoplpush">BRPOPLPUSH</a> 是 <a class="reference internal" href="index.html#rpoplpush"><em>RPOPLPUSH</em></a> 的阻塞版本，当给定列表 <tt class="docutils literal"><span class="pre">source</span></tt> 不为空时， <a class="reference internal" href="#brpoplpush">BRPOPLPUSH</a> 的表现和 <a class="reference internal" href="index.html#rpoplpush"><em>RPOPLPUSH</em></a> 一样。</p>
<p>当列表 <tt class="docutils literal"><span class="pre">source</span></tt> 为空时， <a class="reference internal" href="#brpoplpush">BRPOPLPUSH</a> 命令将阻塞连接，直到等待超时，或有另一个客户端对 <tt class="docutils literal"><span class="pre">source</span></tt> 执行 <a class="reference internal" href="index.html#lpush"><em>LPUSH</em></a> 或 <a class="reference internal" href="index.html#rpush"><em>RPUSH</em></a> 命令为止。</p>
<p>超时参数 <tt class="docutils literal"><span class="pre">timeout</span></tt> 接受一个以秒为单位的数字作为值。超时参数设为 <tt class="docutils literal"><span class="pre">0</span></tt> 表示阻塞时间可以无限期延长(block indefinitely) 。</p>
<p>更多相关信息，请参考 <a class="reference internal" href="index.html#rpoplpush"><em>RPOPLPUSH</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">假如在指定时间内没有任何元素被弹出，则返回一个 <tt class="docutils literal"><span class="pre">nil</span></tt> 和等待时长。</div>
<div class="line">反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 非空列表

redis&gt; BRPOPLPUSH msg reciver 500
&quot;hello moto&quot;                        # 弹出元素的值
(3.38s)                             # 等待时长

redis&gt; LLEN reciver
(integer) 1

redis&gt; LRANGE reciver 0 0
1) &quot;hello moto&quot;


# 空列表

redis&gt; BRPOPLPUSH msg reciver 1
(nil)
(1.34s)
</pre></div>
</div>
<div class="section" id="id2">
<h5>模式：安全队列<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>参考 <a class="reference internal" href="index.html#rpoplpush"><em>RPOPLPUSH</em></a> 命令的『安全队列』模式。</p>
</div>
<div class="section" id="id3">
<h5>模式：循环列表<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>参考 <a class="reference internal" href="index.html#rpoplpush"><em>RPOPLPUSH</em></a> 命令的『循环列表』模式。</p>
</div>
</div>
<span id="document-list/lindex"></span><div class="section" id="lindex">
<span id="id1"></span><h4>LINDEX<a class="headerlink" href="#lindex" title="Permalink to this headline">¶</a></h4>
<p><strong>LINDEX key index</strong></p>
<p>返回列表 <tt class="docutils literal"><span class="pre">key</span></tt> 中，下标为 <tt class="docutils literal"><span class="pre">index</span></tt> 的元素。</p>
<p>下标(index)参数 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">stop</span></tt> 都以 <tt class="docutils literal"><span class="pre">0</span></tt> 为底，也就是说，以 <tt class="docutils literal"><span class="pre">0</span></tt> 表示列表的第一个元素，以 <tt class="docutils literal"><span class="pre">1</span></tt> 表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以 <tt class="docutils literal"><span class="pre">-1</span></tt> 表示列表的最后一个元素， <tt class="docutils literal"><span class="pre">-2</span></tt> 表示列表的倒数第二个元素，以此类推。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不是列表类型，返回一个错误。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first last line-block">
<div class="line">O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为到达下标 <tt class="docutils literal"><span class="pre">index</span></tt> 过程中经过的元素数量。</div>
<div class="line">因此，对列表的头元素和尾元素执行 <a class="reference internal" href="#lindex">LINDEX</a> 命令，复杂度为O(1)。</div>
</div>
</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">列表中下标为 <tt class="docutils literal"><span class="pre">index</span></tt> 的元素。</div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">index</span></tt> 参数的值不在列表的区间范围内(out of range)，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; LPUSH mylist &quot;World&quot;
(integer) 1

redis&gt; LPUSH mylist &quot;Hello&quot;
(integer) 2

redis&gt; LINDEX mylist 0
&quot;Hello&quot;

redis&gt; LINDEX mylist -1
&quot;World&quot;

redis&gt; LINDEX mylist 3        # index不在 mylist 的区间范围内
(nil)
</pre></div>
</div>
</div>
<span id="document-list/linsert"></span><div class="section" id="linsert">
<span id="id1"></span><h4>LINSERT<a class="headerlink" href="#linsert" title="Permalink to this headline">¶</a></h4>
<p><strong>LINSERT key BEFORE|AFTER pivot value</strong></p>
<p>将值 <tt class="docutils literal"><span class="pre">value</span></tt> 插入到列表 <tt class="docutils literal"><span class="pre">key</span></tt> 当中，位于值 <tt class="docutils literal"><span class="pre">pivot</span></tt> 之前或之后。</p>
<p>当 <tt class="docutils literal"><span class="pre">pivot</span></tt> 不存在于列表 <tt class="docutils literal"><span class="pre">key</span></tt> 时，不执行任何操作。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时， <tt class="docutils literal"><span class="pre">key</span></tt> 被视为空列表，不执行任何操作。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不是列表类型，返回一个错误。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为寻找 <tt class="docutils literal"><span class="pre">pivot</span></tt> 过程中经过的元素数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果命令执行成功，返回插入操作完成之后，列表的长度。</div>
<div class="line">如果没有找到 <tt class="docutils literal"><span class="pre">pivot</span></tt> ，返回 <tt class="docutils literal"><span class="pre">-1</span></tt> 。</div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在或为空列表，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; RPUSH mylist &quot;Hello&quot;
(integer) 1

redis&gt; RPUSH mylist &quot;World&quot;
(integer) 2

redis&gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;
(integer) 3

redis&gt; LRANGE mylist 0 -1
1) &quot;Hello&quot;
2) &quot;There&quot;
3) &quot;World&quot;


# 对一个非空列表插入，查找一个不存在的 pivot

redis&gt; LINSERT mylist BEFORE &quot;go&quot; &quot;let&#39;s&quot;
(integer) -1                                    # 失败


# 对一个空列表执行 LINSERT 命令

redis&gt; EXISTS fake_list
(integer) 0

redis&gt; LINSERT fake_list BEFORE &quot;nono&quot; &quot;gogogog&quot;
(integer) 0                                      # 失败
</pre></div>
</div>
</div>
<span id="document-list/llen"></span><div class="section" id="llen">
<span id="id1"></span><h4>LLEN<a class="headerlink" href="#llen" title="Permalink to this headline">¶</a></h4>
<p><strong>LLEN key</strong></p>
<p>返回列表 <tt class="docutils literal"><span class="pre">key</span></tt> 的长度。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，则 <tt class="docutils literal"><span class="pre">key</span></tt> 被解释为一个空列表，返回 <tt class="docutils literal"><span class="pre">0</span></tt> .</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不是列表类型，返回一个错误。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>列表 <tt class="docutils literal"><span class="pre">key</span></tt> 的长度。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 空列表

redis&gt; LLEN job
(integer) 0


# 非空列表

redis&gt; LPUSH job &quot;cook food&quot;
(integer) 1

redis&gt; LPUSH job &quot;have lunch&quot;
(integer) 2

redis&gt; LLEN job
(integer) 2
</pre></div>
</div>
</div>
<span id="document-list/lpop"></span><div class="section" id="lpop">
<span id="id1"></span><h4>LPOP<a class="headerlink" href="#lpop" title="Permalink to this headline">¶</a></h4>
<p><strong>LPOP key</strong></p>
<p>移除并返回列表 <tt class="docutils literal"><span class="pre">key</span></tt> 的头元素。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">列表的头元素。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; LLEN course
(integer) 0

redis&gt; RPUSH course algorithm001
(integer) 1

redis&gt; RPUSH course c++101
(integer) 2

redis&gt; LPOP course  # 移除头元素
&quot;algorithm001&quot;
</pre></div>
</div>
</div>
<span id="document-list/lpush"></span><div class="section" id="lpush">
<span id="id1"></span><h4>LPUSH<a class="headerlink" href="#lpush" title="Permalink to this headline">¶</a></h4>
<p><strong>LPUSH key value [value ...]</strong></p>
<p>将一个或多个值 <tt class="docutils literal"><span class="pre">value</span></tt> 插入到列表 <tt class="docutils literal"><span class="pre">key</span></tt> 的表头</p>
<p>如果有多个 <tt class="docutils literal"><span class="pre">value</span></tt> 值，那么各个 <tt class="docutils literal"><span class="pre">value</span></tt> 值按从左到右的顺序依次插入到表头：
比如说，对空列表 <tt class="docutils literal"><span class="pre">mylist</span></tt> 执行命令 <tt class="docutils literal"><span class="pre">LPUSH</span> <span class="pre">mylist</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></tt> ，列表的值将是 <tt class="docutils literal"><span class="pre">c</span> <span class="pre">b</span> <span class="pre">a</span></tt> ，这等同于原子性地执行 <tt class="docutils literal"><span class="pre">LPUSH</span> <span class="pre">mylist</span> <span class="pre">a</span></tt> 、 <tt class="docutils literal"><span class="pre">LPUSH</span> <span class="pre">mylist</span> <span class="pre">b</span></tt> 和 <tt class="docutils literal"><span class="pre">LPUSH</span> <span class="pre">mylist</span> <span class="pre">c</span></tt> 三个命令。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，一个空列表会被创建并执行 <a class="reference internal" href="#lpush">LPUSH</a> 操作。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在但不是列表类型时，返回一个错误。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在Redis 2.4版本以前的 <a class="reference internal" href="#lpush">LPUSH</a> 命令，都只接受单个 <tt class="docutils literal"><span class="pre">value</span></tt> 值。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>执行 <a class="reference internal" href="#lpush">LPUSH</a> 命令后，列表的长度。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 加入单个元素

redis&gt; LPUSH languages python
(integer) 1


# 加入重复元素

redis&gt; LPUSH languages python
(integer) 2

redis&gt; LRANGE languages 0 -1     # 列表允许重复元素
1) &quot;python&quot;
2) &quot;python&quot;


# 加入多个元素

redis&gt; LPUSH mylist a b c
(integer) 3

redis&gt; LRANGE mylist 0 -1
1) &quot;c&quot;
2) &quot;b&quot;
3) &quot;a&quot;
</pre></div>
</div>
</div>
<span id="document-list/lpushx"></span><div class="section" id="lpushx">
<span id="id1"></span><h4>LPUSHX<a class="headerlink" href="#lpushx" title="Permalink to this headline">¶</a></h4>
<p><strong>LPUSHX key value</strong></p>
<p>将值 <tt class="docutils literal"><span class="pre">value</span></tt> 插入到列表 <tt class="docutils literal"><span class="pre">key</span></tt> 的表头，当且仅当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在并且是一个列表。</p>
<p>和 <a class="reference internal" href="index.html#lpush"><em>LPUSH</em></a> 命令相反，当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时， <a class="reference internal" href="#lpushx">LPUSHX</a> 命令什么也不做。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><a class="reference internal" href="#lpushx">LPUSHX</a> 命令执行之后，表的长度。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对空列表执行 LPUSHX

redis&gt; LLEN greet                       # greet 是一个空列表
(integer) 0

redis&gt; LPUSHX greet &quot;hello&quot;             # 尝试 LPUSHX，失败，因为列表为空
(integer) 0


# 对非空列表执行 LPUSHX

redis&gt; LPUSH greet &quot;hello&quot;              # 先用 LPUSH 创建一个有一个元素的列表
(integer) 1

redis&gt; LPUSHX greet &quot;good morning&quot;      # 这次 LPUSHX 执行成功
(integer) 2

redis&gt; LRANGE greet 0 -1
1) &quot;good morning&quot;
2) &quot;hello&quot;
</pre></div>
</div>
</div>
<span id="document-list/lrange"></span><div class="section" id="lrange">
<span id="id1"></span><h4>LRANGE<a class="headerlink" href="#lrange" title="Permalink to this headline">¶</a></h4>
<p><strong>LRANGE key start stop</strong></p>
<p>返回列表 <tt class="docutils literal"><span class="pre">key</span></tt> 中指定区间内的元素，区间以偏移量 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">stop</span></tt> 指定。</p>
<p>下标(index)参数 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">stop</span></tt> 都以 <tt class="docutils literal"><span class="pre">0</span></tt> 为底，也就是说，以 <tt class="docutils literal"><span class="pre">0</span></tt> 表示列表的第一个元素，以 <tt class="docutils literal"><span class="pre">1</span></tt> 表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以 <tt class="docutils literal"><span class="pre">-1</span></tt> 表示列表的最后一个元素， <tt class="docutils literal"><span class="pre">-2</span></tt> 表示列表的倒数第二个元素，以此类推。</p>
<p><strong>注意LRANGE命令和编程语言区间函数的区别</strong></p>
<p>假如你有一个包含一百个元素的列表，对该列表执行 <tt class="docutils literal"><span class="pre">LRANGE</span> <span class="pre">list</span> <span class="pre">0</span> <span class="pre">10</span></tt> ，结果是一个包含11个元素的列表，这表明 <tt class="docutils literal"><span class="pre">stop</span></tt> 下标也在 <a class="reference internal" href="#lrange">LRANGE</a> 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 <tt class="docutils literal"><span class="pre">Range.new</span></tt> 、 <tt class="docutils literal"><span class="pre">Array#slice</span></tt> 和Python的 <tt class="docutils literal"><span class="pre">range()</span></tt> 函数。</p>
<p><strong>超出范围的下标</strong></p>
<p>超出范围的下标值不会引起错误。</p>
<p>如果 <tt class="docutils literal"><span class="pre">start</span></tt> 下标比列表的最大下标 <tt class="docutils literal"><span class="pre">end</span></tt> ( <tt class="docutils literal"><span class="pre">LLEN</span> <span class="pre">list</span></tt> 减去 <tt class="docutils literal"><span class="pre">1</span></tt> )还要大，那么 <a class="reference internal" href="#lrange">LRANGE</a> 返回一个空列表。</p>
<p>如果 <tt class="docutils literal"><span class="pre">stop</span></tt> 下标比 <tt class="docutils literal"><span class="pre">end</span></tt> 下标还要大，Redis将 <tt class="docutils literal"><span class="pre">stop</span></tt> 的值设置为 <tt class="docutils literal"><span class="pre">end</span></tt> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(S+N)， <tt class="docutils literal"><span class="pre">S</span></tt> 为偏移量 <tt class="docutils literal"><span class="pre">start</span></tt> ， <tt class="docutils literal"><span class="pre">N</span></tt> 为指定区间内元素的数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd>一个列表，包含指定区间内的元素。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; RPUSH fp-language lisp
(integer) 1

redis&gt; LRANGE fp-language 0 0
1) &quot;lisp&quot;

redis&gt; RPUSH fp-language scheme
(integer) 2

redis&gt; LRANGE fp-language 0 1
1) &quot;lisp&quot;
2) &quot;scheme&quot;
</pre></div>
</div>
</div>
<span id="document-list/lrem"></span><div class="section" id="lrem">
<span id="id1"></span><h4>LREM<a class="headerlink" href="#lrem" title="Permalink to this headline">¶</a></h4>
<p><strong>LREM key count value</strong></p>
<p>根据参数 <tt class="docutils literal"><span class="pre">count</span></tt> 的值，移除列表中与参数 <tt class="docutils literal"><span class="pre">value</span></tt> 相等的元素。</p>
<p><tt class="docutils literal"><span class="pre">count</span></tt> 的值可以是以下几种：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">count</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt> : 从表头开始向表尾搜索，移除与 <tt class="docutils literal"><span class="pre">value</span></tt> 相等的元素，数量为 <tt class="docutils literal"><span class="pre">count</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">count</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt> : 从表尾开始向表头搜索，移除与 <tt class="docutils literal"><span class="pre">value</span></tt> 相等的元素，数量为 <tt class="docutils literal"><span class="pre">count</span></tt> 的绝对值。</li>
<li><tt class="docutils literal"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">0</span></tt> : 移除表中所有与 <tt class="docutils literal"><span class="pre">value</span></tt> 相等的值。</li>
</ul>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为列表的长度。</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">被移除元素的数量。</div>
<div class="line">因为不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 被视作空表(empty list)，所以当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时， <a class="reference internal" href="#lrem">LREM</a> 命令总是返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 先创建一个表，内容排列是
# morning hello morning helllo morning

redis&gt; LPUSH greet &quot;morning&quot;
(integer) 1
redis&gt; LPUSH greet &quot;hello&quot;
(integer) 2
redis&gt; LPUSH greet &quot;morning&quot;
(integer) 3
redis&gt; LPUSH greet &quot;hello&quot;
(integer) 4
redis&gt; LPUSH greet &quot;morning&quot;
(integer) 5

redis&gt; LRANGE greet 0 4         # 查看所有元素
1) &quot;morning&quot;
2) &quot;hello&quot;
3) &quot;morning&quot;
4) &quot;hello&quot;
5) &quot;morning&quot;

redis&gt; LREM greet 2 morning     # 移除从表头到表尾，最先发现的两个 morning
(integer) 2                     # 两个元素被移除

redis&gt; LLEN greet               # 还剩 3 个元素
(integer) 3

redis&gt; LRANGE greet 0 2
1) &quot;hello&quot;
2) &quot;hello&quot;
3) &quot;morning&quot;

redis&gt; LREM greet -1 morning    # 移除从表尾到表头，第一个 morning
(integer) 1

redis&gt; LLEN greet               # 剩下两个元素
(integer) 2

redis&gt; LRANGE greet 0 1
1) &quot;hello&quot;
2) &quot;hello&quot;

redis&gt; LREM greet 0 hello      # 移除表中所有 hello
(integer) 2                    # 两个 hello 被移除

redis&gt; LLEN greet
(integer) 0
</pre></div>
</div>
</div>
<span id="document-list/lset"></span><div class="section" id="lset">
<span id="id1"></span><h4>LSET<a class="headerlink" href="#lset" title="Permalink to this headline">¶</a></h4>
<p><strong>LSET key index value</strong></p>
<p>将列表 <tt class="docutils literal"><span class="pre">key</span></tt> 下标为 <tt class="docutils literal"><span class="pre">index</span></tt> 的元素的值设置为 <tt class="docutils literal"><span class="pre">value</span></tt> 。</p>
<p>当 <tt class="docutils literal"><span class="pre">index</span></tt> 参数超出范围，或对一个空列表( <tt class="docutils literal"><span class="pre">key</span></tt> 不存在)进行 <a class="reference internal" href="#lset">LSET</a> 时，返回一个错误。</p>
<p>关于列表下标的更多信息，请参考 <a class="reference internal" href="index.html#lindex"><em>LINDEX</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first last line-block">
<div class="line">对头元素或尾元素进行 <a class="reference internal" href="#lset">LSET</a> 操作，复杂度为 O(1)。</div>
<div class="line">其他情况下，为 O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为列表的长度。</div>
</div>
</dd>
<dt><strong>返回值：</strong></dt>
<dd>操作成功返回 <tt class="docutils literal"><span class="pre">ok</span></tt> ，否则返回错误信息。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对空列表(key 不存在)进行 LSET

redis&gt; EXISTS list
(integer) 0

redis&gt; LSET list 0 item
(error) ERR no such key


# 对非空列表进行 LSET

redis&gt; LPUSH job &quot;cook food&quot;
(integer) 1

redis&gt; LRANGE job 0 0
1) &quot;cook food&quot;

redis&gt; LSET job 0 &quot;play game&quot;
OK

redis&gt; LRANGE job  0 0
1) &quot;play game&quot;


# index 超出范围

redis&gt; LLEN list                    # 列表长度为 1
(integer) 1

redis&gt; LSET list 3 &#39;out of range&#39;
(error) ERR index out of range
</pre></div>
</div>
</div>
<span id="document-list/ltrim"></span><div class="section" id="ltrim">
<span id="id1"></span><h4>LTRIM<a class="headerlink" href="#ltrim" title="Permalink to this headline">¶</a></h4>
<p><strong>LTRIM key start stop</strong></p>
<p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>
<p>举个例子，执行命令 <tt class="docutils literal"><span class="pre">LTRIM</span> <span class="pre">list</span> <span class="pre">0</span> <span class="pre">2</span></tt> ，表示只保留列表 <tt class="docutils literal"><span class="pre">list</span></tt> 的前三个元素，其余元素全部删除。</p>
<p>下标(index)参数 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">stop</span></tt> 都以 <tt class="docutils literal"><span class="pre">0</span></tt> 为底，也就是说，以 <tt class="docutils literal"><span class="pre">0</span></tt> 表示列表的第一个元素，以 <tt class="docutils literal"><span class="pre">1</span></tt> 表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以 <tt class="docutils literal"><span class="pre">-1</span></tt> 表示列表的最后一个元素， <tt class="docutils literal"><span class="pre">-2</span></tt> 表示列表的倒数第二个元素，以此类推。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 不是列表类型时，返回一个错误。</p>
<p><a class="reference internal" href="#ltrim">LTRIM</a> 命令通常和 <a class="reference internal" href="index.html#lpush"><em>LPUSH</em></a> 命令或 <a class="reference internal" href="index.html#rpush"><em>RPUSH</em></a> 命令配合使用，举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre>LPUSH log newest_log
LTRIM log 0 99
</pre></div>
</div>
<p>这个例子模拟了一个日志程序，每次将最新日志 <tt class="docutils literal"><span class="pre">newest_log</span></tt> 放到 <tt class="docutils literal"><span class="pre">log</span></tt> 列表中，并且只保留最新的 <tt class="docutils literal"><span class="pre">100</span></tt> 项。注意当这样使用 <tt class="docutils literal"><span class="pre">LTRIM</span></tt> 命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。</p>
<p><strong>注意LTRIM命令和编程语言区间函数的区别</strong></p>
<p>假如你有一个包含一百个元素的列表 <tt class="docutils literal"><span class="pre">list</span></tt> ，对该列表执行 <tt class="docutils literal"><span class="pre">LTRIM</span> <span class="pre">list</span> <span class="pre">0</span> <span class="pre">10</span></tt> ，结果是一个包含11个元素的列表，这表明 <tt class="docutils literal"><span class="pre">stop</span></tt> 下标也在 <a class="reference internal" href="#ltrim">LTRIM</a> 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 <tt class="docutils literal"><span class="pre">Range.new</span></tt> 、 <tt class="docutils literal"><span class="pre">Array#slice</span></tt> 和Python的 <tt class="docutils literal"><span class="pre">range()</span></tt> 函数。</p>
<p><strong>超出范围的下标</strong></p>
<p>超出范围的下标值不会引起错误。</p>
<p>如果 <tt class="docutils literal"><span class="pre">start</span></tt> 下标比列表的最大下标 <tt class="docutils literal"><span class="pre">end</span></tt> ( <tt class="docutils literal"><span class="pre">LLEN</span> <span class="pre">list</span></tt> 减去 <tt class="docutils literal"><span class="pre">1</span></tt> )还要大，或者 <tt class="docutils literal"><span class="pre">start</span> <span class="pre">&gt;</span> <span class="pre">stop</span></tt> ， <a class="reference internal" href="#ltrim">LTRIM</a> 返回一个空列表(因为 <a class="reference internal" href="#ltrim">LTRIM</a> 已经将整个列表清空)。</p>
<p>如果 <tt class="docutils literal"><span class="pre">stop</span></tt> 下标比 <tt class="docutils literal"><span class="pre">end</span></tt> 下标还要大，Redis将 <tt class="docutils literal"><span class="pre">stop</span></tt> 的值设置为 <tt class="docutils literal"><span class="pre">end</span></tt> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为被移除的元素的数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">命令执行成功时，返回 <tt class="docutils literal"><span class="pre">ok</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 情况 1： 常见情况， start 和 stop 都在列表的索引范围之内

redis&gt; LRANGE alpha 0 -1       # alpha 是一个包含 5 个字符串的列表
1) &quot;h&quot;
2) &quot;e&quot;
3) &quot;l&quot;
4) &quot;l&quot;
5) &quot;o&quot;

redis&gt; LTRIM alpha 1 -1        # 删除 alpha 列表索引为 0 的元素
OK

redis&gt; LRANGE alpha 0 -1       # &quot;h&quot; 被删除了
1) &quot;e&quot;
2) &quot;l&quot;
3) &quot;l&quot;
4) &quot;o&quot;


# 情况 2： stop 比列表的最大下标还要大


redis&gt; LTRIM alpha 1 10086     # 保留 alpha 列表索引 1 至索引 10086 上的元素
OK

redis&gt; LRANGE alpha 0 -1       # 只有索引 0 上的元素 &quot;e&quot; 被删除了，其他元素还在
1) &quot;l&quot;
2) &quot;l&quot;
3) &quot;o&quot;


# 情况 3： start 和 stop 都比列表的最大下标要大，并且 start &lt; stop

redis&gt; LTRIM alpha 10086 123321
OK

redis&gt; LRANGE alpha 0 -1        # 列表被清空
(empty list or set)


# 情况 4： start 和 stop 都比列表的最大下标要大，并且 start &gt; stop

redis&gt; RPUSH new-alpha &quot;h&quot; &quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot;     # 重新建立一个新列表
(integer) 5

redis&gt; LRANGE new-alpha 0 -1
1) &quot;h&quot;
2) &quot;e&quot;
3) &quot;l&quot;
4) &quot;l&quot;
5) &quot;o&quot;

redis&gt; LTRIM new-alpha 123321 10086    # 执行 LTRIM
OK

redis&gt; LRANGE new-alpha 0 -1           # 同样被清空
(empty list or set)
</pre></div>
</div>
</div>
<span id="document-list/rpop"></span><div class="section" id="rpop">
<span id="id1"></span><h4>RPOP<a class="headerlink" href="#rpop" title="Permalink to this headline">¶</a></h4>
<p><strong>RPOP key</strong></p>
<p>移除并返回列表 <tt class="docutils literal"><span class="pre">key</span></tt> 的尾元素。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">列表的尾元素。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; RPUSH mylist &quot;one&quot;
(integer) 1

redis&gt; RPUSH mylist &quot;two&quot;
(integer) 2

redis&gt; RPUSH mylist &quot;three&quot;
(integer) 3

redis&gt; RPOP mylist           # 返回被弹出的元素
&quot;three&quot;

redis&gt; LRANGE mylist 0 -1    # 列表剩下的元素
1) &quot;one&quot;
2) &quot;two&quot;
</pre></div>
</div>
</div>
<span id="document-list/rpoplpush"></span><div class="section" id="rpoplpush">
<span id="id1"></span><h4>RPOPLPUSH<a class="headerlink" href="#rpoplpush" title="Permalink to this headline">¶</a></h4>
<p><strong>RPOPLPUSH source destination</strong></p>
<p>命令 <a class="reference internal" href="#rpoplpush">RPOPLPUSH</a> 在一个原子时间内，执行以下两个动作：</p>
<ul class="simple">
<li>将列表 <tt class="docutils literal"><span class="pre">source</span></tt> 中的最后一个元素(尾元素)弹出，并返回给客户端。</li>
<li>将 <tt class="docutils literal"><span class="pre">source</span></tt> 弹出的元素插入到列表 <tt class="docutils literal"><span class="pre">destination</span></tt> ，作为 <tt class="docutils literal"><span class="pre">destination</span></tt> 列表的的头元素。</li>
</ul>
<p>举个例子，你有两个列表 <tt class="docutils literal"><span class="pre">source</span></tt> 和 <tt class="docutils literal"><span class="pre">destination</span></tt> ， <tt class="docutils literal"><span class="pre">source</span></tt> 列表有元素 <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></tt> ， <tt class="docutils literal"><span class="pre">destination</span></tt> 列表有元素 <tt class="docutils literal"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span></tt> ，执行 <tt class="docutils literal"><span class="pre">RPOPLPUSH</span> <span class="pre">source</span> <span class="pre">destination</span></tt> 之后， <tt class="docutils literal"><span class="pre">source</span></tt> 列表包含元素 <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">b</span></tt> ， <tt class="docutils literal"><span class="pre">destination</span></tt> 列表包含元素 <tt class="docutils literal"><span class="pre">c,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span></tt>  ，并且元素 <tt class="docutils literal"><span class="pre">c</span></tt> 会被返回给客户端。</p>
<p>如果 <tt class="docutils literal"><span class="pre">source</span></tt> 不存在，值 <tt class="docutils literal"><span class="pre">nil</span></tt> 被返回，并且不执行其他动作。</p>
<p>如果 <tt class="docutils literal"><span class="pre">source</span></tt> 和 <tt class="docutils literal"><span class="pre">destination</span></tt> 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>被弹出的元素。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># source 和 destination 不同

redis&gt; LRANGE alpha 0 -1         # 查看所有元素
1) &quot;a&quot;
2) &quot;b&quot;
3) &quot;c&quot;
4) &quot;d&quot;

redis&gt; RPOPLPUSH alpha reciver   # 执行一次 RPOPLPUSH 看看
&quot;d&quot;

redis&gt; LRANGE alpha 0 -1
1) &quot;a&quot;
2) &quot;b&quot;
3) &quot;c&quot;

redis&gt; LRANGE reciver 0 -1
1) &quot;d&quot;

redis&gt; RPOPLPUSH alpha reciver   # 再执行一次，证实 RPOP 和 LPUSH 的位置正确
&quot;c&quot;

redis&gt; LRANGE alpha 0 -1
1) &quot;a&quot;
2) &quot;b&quot;

redis&gt; LRANGE reciver 0 -1
1) &quot;c&quot;
2) &quot;d&quot;


# source 和 destination 相同

redis&gt; LRANGE number 0 -1
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;

redis&gt; RPOPLPUSH number number
&quot;4&quot;

redis&gt; LRANGE number 0 -1           # 4 被旋转到了表头
1) &quot;4&quot;
2) &quot;1&quot;
3) &quot;2&quot;
4) &quot;3&quot;

redis&gt; RPOPLPUSH number number
&quot;3&quot;

redis&gt; LRANGE number 0 -1           # 这次是 3 被旋转到了表头
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;1&quot;
4) &quot;2&quot;
</pre></div>
</div>
<div class="section" id="id2">
<h5>模式： 安全的队列<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 <a class="reference internal" href="index.html#lpush"><em>LPUSH</em></a> 命令将消息放入队列中，而另一个客户端通过 <a class="reference internal" href="index.html#rpop"><em>RPOP</em></a> 或者 <a class="reference internal" href="index.html#brpop"><em>BRPOP</em></a> 命令取出队列中等待时间最长的消息。</p>
<p>不幸的是，上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。</p>
<p>使用 <a class="reference internal" href="#rpoplpush">RPOPLPUSH</a> 命令(或者它的阻塞版本 <a class="reference internal" href="index.html#brpoplpush"><em>BRPOPLPUSH</em></a> )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 <a class="reference internal" href="index.html#lrem"><em>LREM</em></a> 命令将这个消息从备份表删除。</p>
<p>最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。</p>
</div>
<div class="section" id="id3">
<h5>模式：循环列表<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>通过使用相同的 <tt class="docutils literal"><span class="pre">key</span></tt> 作为 <a class="reference internal" href="#rpoplpush">RPOPLPUSH</a> 命令的两个参数，客户端可以用一个接一个地获取列表元素的方式，取得列表的所有元素，而不必像 <a class="reference internal" href="index.html#lrange"><em>LRANGE</em></a> 命令那样一下子将所有列表元素都从服务器传送到客户端中(两种方式的总复杂度都是 O(N))。</p>
<p>以上的模式甚至在以下的两个情况下也能正常工作：</p>
<ul class="simple">
<li>有多个客户端同时对同一个列表进行旋转(rotating)，它们获取不同的元素，直到所有元素都被读取完，之后又从头开始。</li>
<li>有客户端在向列表尾部(右边)添加新元素。</li>
</ul>
<p>这个模式使得我们可以很容易实现这样一类系统：有 N 个客户端，需要连续不断地对一些元素进行处理，而且处理的过程必须尽可能地快。一个典型的例子就是服务器的监控程序：它们需要在尽可能短的时间内，并行地检查一组网站，确保它们的可访问性。</p>
<p>注意，使用这个模式的客户端是易于扩展(scala)且安全(reliable)的，因为就算接收到元素的客户端失败，元素还是保存在列表里面，不会丢失，等到下个迭代来临的时候，别的客户端又可以继续处理这些元素了。</p>
</div>
</div>
<span id="document-list/rpush"></span><div class="section" id="rpush">
<span id="id1"></span><h4>RPUSH<a class="headerlink" href="#rpush" title="Permalink to this headline">¶</a></h4>
<p><strong>RPUSH key value [value ...]</strong></p>
<p>将一个或多个值 <tt class="docutils literal"><span class="pre">value</span></tt> 插入到列表 <tt class="docutils literal"><span class="pre">key</span></tt> 的表尾(最右边)。</p>
<p>如果有多个 <tt class="docutils literal"><span class="pre">value</span></tt> 值，那么各个 <tt class="docutils literal"><span class="pre">value</span></tt> 值按从左到右的顺序依次插入到表尾：比如对一个空列表 <tt class="docutils literal"><span class="pre">mylist</span></tt> 执行 <tt class="docutils literal"><span class="pre">RPUSH</span> <span class="pre">mylist</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></tt> ，得出的结果列表为 <tt class="docutils literal"><span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></tt> ，等同于执行命令 <tt class="docutils literal"><span class="pre">RPUSH</span> <span class="pre">mylist</span> <span class="pre">a</span></tt> 、 <tt class="docutils literal"><span class="pre">RPUSH</span> <span class="pre">mylist</span> <span class="pre">b</span></tt> 、 <tt class="docutils literal"><span class="pre">RPUSH</span> <span class="pre">mylist</span> <span class="pre">c</span></tt> 。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，一个空列表会被创建并执行 <a class="reference internal" href="#rpush">RPUSH</a> 操作。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在但不是列表类型时，返回一个错误。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在 Redis 2.4 版本以前的 <a class="reference internal" href="#rpush">RPUSH</a> 命令，都只接受单个 <tt class="docutils literal"><span class="pre">value</span></tt> 值。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>执行 <a class="reference internal" href="#rpush">RPUSH</a> 操作后，表的长度。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 添加单个元素

redis&gt; RPUSH languages c
(integer) 1


# 添加重复元素

redis&gt; RPUSH languages c
(integer) 2

redis&gt; LRANGE languages 0 -1 # 列表允许重复元素
1) &quot;c&quot;
2) &quot;c&quot;


# 添加多个元素

redis&gt; RPUSH mylist a b c
(integer) 3

redis&gt; LRANGE mylist 0 -1
1) &quot;a&quot;
2) &quot;b&quot;
3) &quot;c&quot;
</pre></div>
</div>
</div>
<span id="document-list/rpushx"></span><div class="section" id="rpushx">
<span id="id1"></span><h4>RPUSHX<a class="headerlink" href="#rpushx" title="Permalink to this headline">¶</a></h4>
<p><strong>RPUSHX key value</strong></p>
<p>将值 <tt class="docutils literal"><span class="pre">value</span></tt> 插入到列表 <tt class="docutils literal"><span class="pre">key</span></tt> 的表尾，当且仅当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在并且是一个列表。</p>
<p>和 <a class="reference internal" href="index.html#rpush"><em>RPUSH</em></a> 命令相反，当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时， <a class="reference internal" href="#rpushx">RPUSHX</a> 命令什么也不做。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><a class="reference internal" href="#rpushx">RPUSHX</a> 命令执行之后，表的长度。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># key不存在

redis&gt; LLEN greet
(integer) 0

redis&gt; RPUSHX greet &quot;hello&quot;     # 对不存在的 key 进行 RPUSHX，PUSH 失败。
(integer) 0


# key 存在且是一个非空列表

redis&gt; RPUSH greet &quot;hi&quot;         # 先用 RPUSH 插入一个元素
(integer) 1

redis&gt; RPUSHX greet &quot;hello&quot;     # greet 现在是一个列表类型，RPUSHX 操作成功。
(integer) 2

redis&gt; LRANGE greet 0 -1
1) &quot;hi&quot;
2) &quot;hello&quot;
</pre></div>
</div>
</div>
</div>
</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="toctree-wrapper first last compound">
<span id="document-set/index"></span><div class="section" id="set">
<h3>Set（集合）<a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-set/sadd"></span><div class="section" id="sadd">
<span id="id1"></span><h4>SADD<a class="headerlink" href="#sadd" title="Permalink to this headline">¶</a></h4>
<p><strong>SADD key member [member ...]</strong></p>
<p>将一个或多个 <tt class="docutils literal"><span class="pre">member</span></tt> 元素加入到集合 <tt class="docutils literal"><span class="pre">key</span></tt> 当中，已经存在于集合的 <tt class="docutils literal"><span class="pre">member</span></tt> 元素将被忽略。</p>
<p>假如 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，则创建一个只包含 <tt class="docutils literal"><span class="pre">member</span></tt> 元素作成员的集合。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 不是集合类型时，返回一个错误。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在Redis2.4版本以前， <a class="reference internal" href="#sadd">SADD</a> 只接受单个 <tt class="docutils literal"><span class="pre">member</span></tt> 值。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 是被添加的元素的数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd>被添加到集合中的新元素的数量，不包括被忽略的元素。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 添加单个元素

redis&gt; SADD bbs &quot;discuz.net&quot;
(integer) 1


# 添加重复元素

redis&gt; SADD bbs &quot;discuz.net&quot;
(integer) 0


# 添加多个元素

redis&gt; SADD bbs &quot;tianya.cn&quot; &quot;groups.google.com&quot;
(integer) 2

redis&gt; SMEMBERS bbs
1) &quot;discuz.net&quot;
2) &quot;groups.google.com&quot;
3) &quot;tianya.cn&quot;
</pre></div>
</div>
</div>
<span id="document-set/scard"></span><div class="section" id="scard">
<span id="id1"></span><h4>SCARD<a class="headerlink" href="#scard" title="Permalink to this headline">¶</a></h4>
<p><strong>SCARD key</strong></p>
<p>返回集合 <tt class="docutils literal"><span class="pre">key</span></tt> 的基数(集合中元素的数量)。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">集合的基数。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SADD tool pc printer phone
(integer) 3

redis&gt; SCARD tool   # 非空集合
(integer) 3

redis&gt; DEL tool
(integer) 1

redis&gt; SCARD tool   # 空集合
(integer) 0
</pre></div>
</div>
</div>
<span id="document-set/sdiff"></span><div class="section" id="sdiff">
<span id="id1"></span><h4>SDIFF<a class="headerlink" href="#sdiff" title="Permalink to this headline">¶</a></h4>
<p><strong>SDIFF key [key ...]</strong></p>
<p>返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p>
<p>不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 被视为空集。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 是所有给定集合的成员数量之和。</dd>
<dt><strong>返回值:</strong></dt>
<dd>一个包含差集成员的列表。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SMEMBERS peter&#39;s_movies
1) &quot;bet man&quot;
2) &quot;start war&quot;
3) &quot;2012&quot;

redis&gt; SMEMBERS joe&#39;s_movies
1) &quot;hi, lady&quot;
2) &quot;Fast Five&quot;
3) &quot;2012&quot;

redis&gt; SDIFF peter&#39;s_movies joe&#39;s_movies
1) &quot;bet man&quot;
2) &quot;start war&quot;
</pre></div>
</div>
</div>
<span id="document-set/sdiffstore"></span><div class="section" id="sdiffstore">
<span id="id1"></span><h4>SDIFFSTORE<a class="headerlink" href="#sdiffstore" title="Permalink to this headline">¶</a></h4>
<p><strong>SDIFFSTORE destination key [key ...]</strong></p>
<p>这个命令的作用和 <a class="reference internal" href="index.html#sdiff"><em>SDIFF</em></a> 类似，但它将结果保存到 <tt class="docutils literal"><span class="pre">destination</span></tt> 集合，而不是简单地返回结果集。</p>
<p>如果 <tt class="docutils literal"><span class="pre">destination</span></tt> 集合已经存在，则将其覆盖。</p>
<p><tt class="docutils literal"><span class="pre">destination</span></tt> 可以是 <tt class="docutils literal"><span class="pre">key</span></tt> 本身。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 是所有给定集合的成员数量之和。</dd>
<dt><strong>返回值:</strong></dt>
<dd>结果集中的元素数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SMEMBERS joe&#39;s_movies
1) &quot;hi, lady&quot;
2) &quot;Fast Five&quot;
3) &quot;2012&quot;

redis&gt; SMEMBERS peter&#39;s_movies
1) &quot;bet man&quot;
2) &quot;start war&quot;
3) &quot;2012&quot;

redis&gt; SDIFFSTORE joe_diff_peter joe&#39;s_movies peter&#39;s_movies
(integer) 2

redis&gt; SMEMBERS joe_diff_peter
1) &quot;hi, lady&quot;
2) &quot;Fast Five&quot;
</pre></div>
</div>
</div>
<span id="document-set/sinter"></span><div class="section" id="sinter">
<span id="id1"></span><h4>SINTER<a class="headerlink" href="#sinter" title="Permalink to this headline">¶</a></h4>
<p><strong>SINTER key [key ...]</strong></p>
<p>返回一个集合的全部成员，该集合是所有给定集合的交集。</p>
<p>不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 被视为空集。</p>
<p>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N * M)， <tt class="docutils literal"><span class="pre">N</span></tt> 为给定集合当中基数最小的集合， <tt class="docutils literal"><span class="pre">M</span></tt> 为给定集合的个数。</dd>
<dt><strong>返回值:</strong></dt>
<dd>交集成员的列表。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SMEMBERS group_1
1) &quot;LI LEI&quot;
2) &quot;TOM&quot;
3) &quot;JACK&quot;

redis&gt; SMEMBERS group_2
1) &quot;HAN MEIMEI&quot;
2) &quot;JACK&quot;

redis&gt; SINTER group_1 group_2
1) &quot;JACK&quot;
</pre></div>
</div>
</div>
<span id="document-set/sinterstore"></span><div class="section" id="sinterstore">
<span id="id1"></span><h4>SINTERSTORE<a class="headerlink" href="#sinterstore" title="Permalink to this headline">¶</a></h4>
<p><strong>SINTERSTORE destination key [key ...]</strong></p>
<p>这个命令类似于 <a class="reference internal" href="index.html#sinter"><em>SINTER</em></a> 命令，但它将结果保存到 <tt class="docutils literal"><span class="pre">destination</span></tt> 集合，而不是简单地返回结果集。</p>
<p>如果 <tt class="docutils literal"><span class="pre">destination</span></tt> 集合已经存在，则将其覆盖。</p>
<p><tt class="docutils literal"><span class="pre">destination</span></tt> 可以是 <tt class="docutils literal"><span class="pre">key</span></tt> 本身。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N * M)， <tt class="docutils literal"><span class="pre">N</span></tt> 为给定集合当中基数最小的集合， <tt class="docutils literal"><span class="pre">M</span></tt> 为给定集合的个数。</dd>
<dt><strong>返回值:</strong></dt>
<dd>结果集中的成员数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SMEMBERS songs
1) &quot;good bye joe&quot;
2) &quot;hello,peter&quot;

redis&gt; SMEMBERS my_songs
1) &quot;good bye joe&quot;
2) &quot;falling&quot;

redis&gt; SINTERSTORE song_interset songs my_songs
(integer) 1

redis&gt; SMEMBERS song_interset
1) &quot;good bye joe&quot;
</pre></div>
</div>
</div>
<span id="document-set/sismember"></span><div class="section" id="sismember">
<span id="id1"></span><h4>SISMEMBER<a class="headerlink" href="#sismember" title="Permalink to this headline">¶</a></h4>
<p><strong>SISMEMBER key member</strong></p>
<p>判断 <tt class="docutils literal"><span class="pre">member</span></tt> 元素是否集合 <tt class="docutils literal"><span class="pre">key</span></tt> 的成员。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果 <tt class="docutils literal"><span class="pre">member</span></tt> 元素是集合的成员，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">member</span></tt> 元素不是集合的成员，或 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SMEMBERS joe&#39;s_movies
1) &quot;hi, lady&quot;
2) &quot;Fast Five&quot;
3) &quot;2012&quot;

redis&gt; SISMEMBER joe&#39;s_movies &quot;bet man&quot;
(integer) 0

redis&gt; SISMEMBER joe&#39;s_movies &quot;Fast Five&quot;
(integer) 1
</pre></div>
</div>
</div>
<span id="document-set/smembers"></span><div class="section" id="smembers">
<span id="id1"></span><h4>SMEMBERS<a class="headerlink" href="#smembers" title="Permalink to this headline">¶</a></h4>
<p><strong>SMEMBERS key</strong></p>
<p>返回集合 <tt class="docutils literal"><span class="pre">key</span></tt> 中的所有成员。</p>
<p>不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 被视为空集合。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为集合的基数。</dd>
<dt><strong>返回值:</strong></dt>
<dd>集合中的所有成员。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># key 不存在或集合为空

redis&gt; EXISTS not_exists_key
(integer) 0

redis&gt; SMEMBERS not_exists_key
(empty list or set)


# 非空集合

redis&gt; SADD language Ruby Python Clojure
(integer) 3

redis&gt; SMEMBERS language
1) &quot;Python&quot;
2) &quot;Ruby&quot;
3) &quot;Clojure&quot;
</pre></div>
</div>
</div>
<span id="document-set/smove"></span><div class="section" id="smove">
<span id="id1"></span><h4>SMOVE<a class="headerlink" href="#smove" title="Permalink to this headline">¶</a></h4>
<p><strong>SMOVE source destination member</strong></p>
<p>将 <tt class="docutils literal"><span class="pre">member</span></tt> 元素从 <tt class="docutils literal"><span class="pre">source</span></tt> 集合移动到 <tt class="docutils literal"><span class="pre">destination</span></tt> 集合。</p>
<p><a class="reference internal" href="#smove">SMOVE</a> 是原子性操作。</p>
<p>如果 <tt class="docutils literal"><span class="pre">source</span></tt> 集合不存在或不包含指定的 <tt class="docutils literal"><span class="pre">member</span></tt> 元素，则 <a class="reference internal" href="#smove">SMOVE</a> 命令不执行任何操作，仅返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。否则， <tt class="docutils literal"><span class="pre">member</span></tt> 元素从 <tt class="docutils literal"><span class="pre">source</span></tt> 集合中被移除，并添加到 <tt class="docutils literal"><span class="pre">destination</span></tt> 集合中去。</p>
<p>当 <tt class="docutils literal"><span class="pre">destination</span></tt> 集合已经包含 <tt class="docutils literal"><span class="pre">member</span></tt> 元素时， <a class="reference internal" href="#smove">SMOVE</a> 命令只是简单地将 <tt class="docutils literal"><span class="pre">source</span></tt> 集合中的 <tt class="docutils literal"><span class="pre">member</span></tt> 元素删除。</p>
<p>当 <tt class="docutils literal"><span class="pre">source</span></tt> 或 <tt class="docutils literal"><span class="pre">destination</span></tt> 不是集合类型时，返回一个错误。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果 <tt class="docutils literal"><span class="pre">member</span></tt> 元素被成功移除，返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。</div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">member</span></tt> 元素不是 <tt class="docutils literal"><span class="pre">source</span></tt> 集合的成员，并且没有任何操作对 <tt class="docutils literal"><span class="pre">destination</span></tt> 集合执行，那么返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SMEMBERS songs
1) &quot;Billie Jean&quot;
2) &quot;Believe Me&quot;

redis&gt; SMEMBERS my_songs
(empty list or set)

redis&gt; SMOVE songs my_songs &quot;Believe Me&quot;
(integer) 1

redis&gt; SMEMBERS songs
1) &quot;Billie Jean&quot;

redis&gt; SMEMBERS my_songs
1) &quot;Believe Me&quot;
</pre></div>
</div>
</div>
<span id="document-set/spop"></span><div class="section" id="spop">
<span id="id1"></span><h4>SPOP<a class="headerlink" href="#spop" title="Permalink to this headline">¶</a></h4>
<p><strong>SPOP key</strong></p>
<p>移除并返回集合中的一个随机元素。</p>
<p>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 <a class="reference internal" href="index.html#srandmember"><em>SRANDMEMBER</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">被移除的随机元素。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在或 <tt class="docutils literal"><span class="pre">key</span></tt> 是空集时，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SMEMBERS db
1) &quot;MySQL&quot;
2) &quot;MongoDB&quot;
3) &quot;Redis&quot;

redis&gt; SPOP db
&quot;Redis&quot;

redis&gt; SMEMBERS db
1) &quot;MySQL&quot;
2) &quot;MongoDB&quot;

redis&gt; SPOP db
&quot;MySQL&quot;

redis&gt; SMEMBERS db
1) &quot;MongoDB&quot;
</pre></div>
</div>
</div>
<span id="document-set/srandmember"></span><div class="section" id="srandmember">
<span id="id1"></span><h4>SRANDMEMBER<a class="headerlink" href="#srandmember" title="Permalink to this headline">¶</a></h4>
<p><strong>SRANDMEMBER key [count]</strong></p>
<p>如果命令执行时，只提供了 <tt class="docutils literal"><span class="pre">key</span></tt> 参数，那么返回集合中的一个随机元素。</p>
<p>从 Redis 2.6 版本开始， <a class="reference internal" href="#srandmember">SRANDMEMBER</a> 命令接受可选的 <tt class="docutils literal"><span class="pre">count</span></tt> 参数：</p>
<ul class="simple">
<li>如果 <tt class="docutils literal"><span class="pre">count</span></tt> 为正数，且小于集合基数，那么命令返回一个包含 <tt class="docutils literal"><span class="pre">count</span></tt> 个元素的数组，数组中的元素<strong>各不相同</strong>。如果 <tt class="docutils literal"><span class="pre">count</span></tt> 大于等于集合基数，那么返回整个集合。</li>
<li>如果 <tt class="docutils literal"><span class="pre">count</span></tt> 为负数，那么命令返回一个数组，数组中的元素<strong>可能会重复出现多次</strong>，而数组的长度为 <tt class="docutils literal"><span class="pre">count</span></tt> 的绝对值。</li>
</ul>
<p>该操作和 <a class="reference internal" href="index.html#spop"><em>SPOP</em></a> 相似，但 <a class="reference internal" href="index.html#spop"><em>SPOP</em></a> 将随机元素从集合中移除并返回，而 <a class="reference internal" href="#srandmember">SRANDMEMBER</a> 则仅仅返回随机元素，而不对集合进行任何改动。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd><div class="first last line-block">
<div class="line">只提供 <tt class="docutils literal"><span class="pre">key</span></tt> 参数时为 O(1) 。</div>
<div class="line">如果提供了 <tt class="docutils literal"><span class="pre">count</span></tt> 参数，那么为 O(N) ，N 为返回数组的元素个数。</div>
</div>
</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">只提供 <tt class="docutils literal"><span class="pre">key</span></tt> 参数时，返回一个元素；如果集合为空，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
<div class="line">如果提供了 <tt class="docutils literal"><span class="pre">count</span></tt> 参数，那么返回一个数组；如果集合为空，返回空数组。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 添加元素

redis&gt; SADD fruit apple banana cherry
(integer) 3

# 只给定 key 参数，返回一个随机元素

redis&gt; SRANDMEMBER fruit
&quot;cherry&quot;

redis&gt; SRANDMEMBER fruit
&quot;apple&quot;

# 给定 3 为 count 参数，返回 3 个随机元素
# 每个随机元素都不相同

redis&gt; SRANDMEMBER fruit 3
1) &quot;apple&quot;
2) &quot;banana&quot;
3) &quot;cherry&quot;

# 给定 -3 为 count 参数，返回 3 个随机元素
# 元素可能会重复出现多次

redis&gt; SRANDMEMBER fruit -3
1) &quot;banana&quot;
2) &quot;cherry&quot;
3) &quot;apple&quot;

redis&gt; SRANDMEMBER fruit -3
1) &quot;apple&quot;
2) &quot;apple&quot;
3) &quot;cherry&quot;

# 如果 count 是整数，且大于等于集合基数，那么返回整个集合

redis&gt; SRANDMEMBER fruit 10
1) &quot;apple&quot;
2) &quot;banana&quot;
3) &quot;cherry&quot;

# 如果 count 是负数，且 count 的绝对值大于集合的基数
# 那么返回的数组的长度为 count 的绝对值

redis&gt; SRANDMEMBER fruit -10
1) &quot;banana&quot;
2) &quot;apple&quot;
3) &quot;banana&quot;
4) &quot;cherry&quot;
5) &quot;apple&quot;
6) &quot;apple&quot;
7) &quot;cherry&quot;
8) &quot;apple&quot;
9) &quot;apple&quot;
10) &quot;banana&quot;

# SRANDMEMBER 并不会修改集合内容

redis&gt; SMEMBERS fruit
1) &quot;apple&quot;
2) &quot;cherry&quot;
3) &quot;banana&quot;

# 集合为空时返回 nil 或者空数组

redis&gt; SRANDMEMBER not-exists
(nil)

redis&gt; SRANDMEMBER not-eixsts 10
(empty list or set)
</pre></div>
</div>
</div>
<span id="document-set/srem"></span><div class="section" id="srem">
<span id="id1"></span><h4>SREM<a class="headerlink" href="#srem" title="Permalink to this headline">¶</a></h4>
<p><strong>SREM key member [member ...]</strong></p>
<p>移除集合 <tt class="docutils literal"><span class="pre">key</span></tt> 中的一个或多个 <tt class="docutils literal"><span class="pre">member</span></tt> 元素，不存在的 <tt class="docutils literal"><span class="pre">member</span></tt> 元素会被忽略。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 不是集合类型，返回一个错误。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在 Redis 2.4 版本以前， <a class="reference internal" href="#srem">SREM</a> 只接受单个 <tt class="docutils literal"><span class="pre">member</span></tt> 值。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为给定 <tt class="docutils literal"><span class="pre">member</span></tt> 元素的数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd>被成功移除的元素的数量，不包括被忽略的元素。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 测试数据

redis&gt; SMEMBERS languages
1) &quot;c&quot;
2) &quot;lisp&quot;
3) &quot;python&quot;
4) &quot;ruby&quot;


# 移除单个元素

redis&gt; SREM languages ruby
(integer) 1


# 移除不存在元素

redis&gt; SREM languages non-exists-language
(integer) 0


# 移除多个元素

redis&gt; SREM languages lisp python c
(integer) 3

redis&gt; SMEMBERS languages
(empty list or set)
</pre></div>
</div>
</div>
<span id="document-set/sunion"></span><div class="section" id="sunion">
<span id="id1"></span><h4>SUNION<a class="headerlink" href="#sunion" title="Permalink to this headline">¶</a></h4>
<p><strong>SUNION key [key ...]</strong></p>
<p>返回一个集合的全部成员，该集合是所有给定集合的并集。</p>
<p>不存在的 <tt class="docutils literal"><span class="pre">key</span></tt> 被视为空集。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 是所有给定集合的成员数量之和。</dd>
<dt><strong>返回值:</strong></dt>
<dd>并集成员的列表。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SMEMBERS songs
1) &quot;Billie Jean&quot;

redis&gt; SMEMBERS my_songs
1) &quot;Believe Me&quot;

redis&gt; SUNION songs my_songs
1) &quot;Billie Jean&quot;
2) &quot;Believe Me&quot;
</pre></div>
</div>
</div>
<span id="document-set/sunionstore"></span><div class="section" id="sunionstore">
<span id="id1"></span><h4>SUNIONSTORE<a class="headerlink" href="#sunionstore" title="Permalink to this headline">¶</a></h4>
<p><strong>SUNIONSTORE destination key [key ...]</strong></p>
<p>这个命令类似于 <a class="reference internal" href="index.html#sunion"><em>SUNION</em></a> 命令，但它将结果保存到 <tt class="docutils literal"><span class="pre">destination</span></tt> 集合，而不是简单地返回结果集。</p>
<p>如果 <tt class="docutils literal"><span class="pre">destination</span></tt> 已经存在，则将其覆盖。</p>
<p><tt class="docutils literal"><span class="pre">destination</span></tt> 可以是 <tt class="docutils literal"><span class="pre">key</span></tt> 本身。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 是所有给定集合的成员数量之和。</dd>
<dt><strong>返回值:</strong></dt>
<dd>结果集中的元素数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SMEMBERS NoSQL
1) &quot;MongoDB&quot;
2) &quot;Redis&quot;

redis&gt; SMEMBERS SQL
1) &quot;sqlite&quot;
2) &quot;MySQL&quot;

redis&gt; SUNIONSTORE db NoSQL SQL
(integer) 4

redis&gt; SMEMBERS db
1) &quot;MySQL&quot;
2) &quot;sqlite&quot;
3) &quot;MongoDB&quot;
4) &quot;Redis&quot;
</pre></div>
</div>
</div>
<span id="document-set/sscan"></span><div class="section" id="sscan">
<span id="id1"></span><h4>SSCAN<a class="headerlink" href="#sscan" title="Permalink to this headline">¶</a></h4>
<p><strong>SSCAN key cursor [MATCH pattern] [COUNT count]</strong></p>
<p>详细信息请参考 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令。</p>
</div>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-sorted_set/index"></span><div class="section" id="sortedset">
<h3>SortedSet（有序集合）<a class="headerlink" href="#sortedset" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-sorted_set/zadd"></span><div class="section" id="zadd">
<span id="id1"></span><h4>ZADD<a class="headerlink" href="#zadd" title="Permalink to this headline">¶</a></h4>
<p><strong>ZADD key score member [[score member] [score member] ...]</strong></p>
<p>将一个或多个 <tt class="docutils literal"><span class="pre">member</span></tt> 元素及其 <tt class="docutils literal"><span class="pre">score</span></tt> 值加入到有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 当中。</p>
<p>如果某个 <tt class="docutils literal"><span class="pre">member</span></tt> 已经是有序集的成员，那么更新这个 <tt class="docutils literal"><span class="pre">member</span></tt> 的 <tt class="docutils literal"><span class="pre">score</span></tt> 值，并通过重新插入这个 <tt class="docutils literal"><span class="pre">member</span></tt> 元素，来保证该 <tt class="docutils literal"><span class="pre">member</span></tt> 在正确的位置上。</p>
<p><tt class="docutils literal"><span class="pre">score</span></tt> 值可以是整数值或双精度浮点数。</p>
<p>如果 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，则创建一个空的有序集并执行 <a class="reference internal" href="#zadd">ZADD</a> 操作。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在但不是有序集类型时，返回一个错误。</p>
<p>对有序集的更多介绍请参见 <a class="reference external" href="http://redis.io/topics/data-types#sorted-sets">sorted set</a> 。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在 Redis 2.4 版本以前， <a class="reference internal" href="#zadd">ZADD</a> 每次只能添加一个元素。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(M*log(N))， <tt class="docutils literal"><span class="pre">N</span></tt> 是有序集的基数， <tt class="docutils literal"><span class="pre">M</span></tt> 为成功添加的新成员的数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 添加单个元素

redis&gt; ZADD page_rank 10 google.com
(integer) 1


# 添加多个元素

redis&gt; ZADD page_rank 9 baidu.com 8 bing.com
(integer) 2

redis&gt; ZRANGE page_rank 0 -1 WITHSCORES
1) &quot;bing.com&quot;
2) &quot;8&quot;
3) &quot;baidu.com&quot;
4) &quot;9&quot;
5) &quot;google.com&quot;
6) &quot;10&quot;


# 添加已存在元素，且 score 值不变

redis&gt; ZADD page_rank 10 google.com
(integer) 0

redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # 没有改变
1) &quot;bing.com&quot;
2) &quot;8&quot;
3) &quot;baidu.com&quot;
4) &quot;9&quot;
5) &quot;google.com&quot;
6) &quot;10&quot;


# 添加已存在元素，但是改变 score 值

redis&gt; ZADD page_rank 6 bing.com
(integer) 0

redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  # bing.com 元素的 score 值被改变
1) &quot;bing.com&quot;
2) &quot;6&quot;
3) &quot;baidu.com&quot;
4) &quot;9&quot;
5) &quot;google.com&quot;
6) &quot;10&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zcard"></span><div class="section" id="zcard">
<span id="id1"></span><h4>ZCARD<a class="headerlink" href="#zcard" title="Permalink to this headline">¶</a></h4>
<p><strong>ZCARD key</strong></p>
<p>返回有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 的基数。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在且是有序集类型时，返回有序集的基数。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis &gt; ZADD salary 2000 tom    # 添加一个成员
(integer) 1

redis &gt; ZCARD salary
(integer) 1

redis &gt; ZADD salary 5000 jack   # 再添加一个成员
(integer) 1

redis &gt; ZCARD salary
(integer) 2

redis &gt; EXISTS non_exists_key   # 对不存在的 key 进行 ZCARD 操作
(integer) 0

redis &gt; ZCARD non_exists_key
(integer) 0
</pre></div>
</div>
</div>
<span id="document-sorted_set/zcount"></span><div class="section" id="zcount">
<span id="id1"></span><h4>ZCOUNT<a class="headerlink" href="#zcount" title="Permalink to this headline">¶</a></h4>
<p><strong>ZCOUNT key min max</strong></p>
<p>返回有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中， <tt class="docutils literal"><span class="pre">score</span></tt> 值在 <tt class="docutils literal"><span class="pre">min</span></tt> 和 <tt class="docutils literal"><span class="pre">max</span></tt> 之间(默认包括 <tt class="docutils literal"><span class="pre">score</span></tt> 值等于 <tt class="docutils literal"><span class="pre">min</span></tt> 或 <tt class="docutils literal"><span class="pre">max</span></tt> )的成员的数量。</p>
<p>关于参数 <tt class="docutils literal"><span class="pre">min</span></tt> 和 <tt class="docutils literal"><span class="pre">max</span></tt> 的详细使用方法，请参考 <a class="reference internal" href="index.html#zrangebyscore"><em>ZRANGEBYSCORE</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N))， <tt class="docutils literal"><span class="pre">N</span></tt> 为有序集的基数。</dd>
<dt><strong>返回值:</strong></dt>
<dd><tt class="docutils literal"><span class="pre">score</span></tt> 值在 <tt class="docutils literal"><span class="pre">min</span></tt> 和 <tt class="docutils literal"><span class="pre">max</span></tt> 之间的成员的数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据
1) &quot;jack&quot;
2) &quot;2000&quot;
3) &quot;peter&quot;
4) &quot;3500&quot;
5) &quot;tom&quot;
6) &quot;5000&quot;

redis&gt; ZCOUNT salary 2000 5000          # 计算薪水在 2000-5000 之间的人数
(integer) 3

redis&gt; ZCOUNT salary 3000 5000          # 计算薪水在 3000-5000 之间的人数
(integer) 2
</pre></div>
</div>
</div>
<span id="document-sorted_set/zincrby"></span><div class="section" id="zincrby">
<span id="id1"></span><h4>ZINCRBY<a class="headerlink" href="#zincrby" title="Permalink to this headline">¶</a></h4>
<p><strong>ZINCRBY key increment member</strong></p>
<p>为有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 的成员 <tt class="docutils literal"><span class="pre">member</span></tt> 的 <tt class="docutils literal"><span class="pre">score</span></tt> 值加上增量 <tt class="docutils literal"><span class="pre">increment</span></tt> 。</p>
<p>可以通过传递一个负数值 <tt class="docutils literal"><span class="pre">increment</span></tt> ，让 <tt class="docutils literal"><span class="pre">score</span></tt> 减去相应的值，比如 <tt class="docutils literal"><span class="pre">ZINCRBY</span> <span class="pre">key</span> <span class="pre">-5</span> <span class="pre">member</span></tt> ，就是让 <tt class="docutils literal"><span class="pre">member</span></tt> 的 <tt class="docutils literal"><span class="pre">score</span></tt> 值减去 <tt class="docutils literal"><span class="pre">5</span></tt> 。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，或 <tt class="docutils literal"><span class="pre">member</span></tt> 不是 <tt class="docutils literal"><span class="pre">key</span></tt> 的成员时， <tt class="docutils literal"><span class="pre">ZINCRBY</span> <span class="pre">key</span> <span class="pre">increment</span> <span class="pre">member</span></tt> 等同于 <tt class="docutils literal"><span class="pre">ZADD</span> <span class="pre">key</span> <span class="pre">increment</span> <span class="pre">member</span></tt> 。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 不是有序集类型时，返回一个错误。</p>
<p><tt class="docutils literal"><span class="pre">score</span></tt> 值可以是整数值或双精度浮点数。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N))</dd>
<dt><strong>返回值:</strong></dt>
<dd><tt class="docutils literal"><span class="pre">member</span></tt> 成员的新 <tt class="docutils literal"><span class="pre">score</span></tt> 值，以字符串形式表示。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ZSCORE salary tom
&quot;2000&quot;

redis&gt; ZINCRBY salary 2000 tom   # tom 加薪啦！
&quot;4000&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zrange"></span><div class="section" id="zrange">
<span id="id1"></span><h4>ZRANGE<a class="headerlink" href="#zrange" title="Permalink to this headline">¶</a></h4>
<p><strong>ZRANGE key start stop [WITHSCORES]</strong></p>
<p>返回有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中，指定区间内的成员。</p>
<p>其中成员的位置按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递增(从小到大)来排序。</p>
<p>具有相同 <tt class="docutils literal"><span class="pre">score</span></tt> 值的成员按字典序(<a class="reference external" href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographical order</a> )来排列。</p>
<p>如果你需要成员按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递减(从大到小)来排列，请使用 <a class="reference internal" href="index.html#zrevrange"><em>ZREVRANGE</em></a> 命令。</p>
<div class="line-block">
<div class="line">下标参数 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">stop</span></tt> 都以 <tt class="docutils literal"><span class="pre">0</span></tt> 为底，也就是说，以 <tt class="docutils literal"><span class="pre">0</span></tt> 表示有序集第一个成员，以 <tt class="docutils literal"><span class="pre">1</span></tt> 表示有序集第二个成员，以此类推。</div>
<div class="line">你也可以使用负数下标，以 <tt class="docutils literal"><span class="pre">-1</span></tt> 表示最后一个成员， <tt class="docutils literal"><span class="pre">-2</span></tt> 表示倒数第二个成员，以此类推。</div>
</div>
<div class="line-block">
<div class="line">超出范围的下标并不会引起错误。</div>
<div class="line">比如说，当 <tt class="docutils literal"><span class="pre">start</span></tt> 的值比有序集的最大下标还要大，或是 <tt class="docutils literal"><span class="pre">start</span> <span class="pre">&gt;</span> <span class="pre">stop</span></tt> 时， <a class="reference internal" href="#zrange">ZRANGE</a> 命令只是简单地返回一个空列表。</div>
<div class="line">另一方面，假如 <tt class="docutils literal"><span class="pre">stop</span></tt> 参数的值比有序集的最大下标还要大，那么 Redis 将 <tt class="docutils literal"><span class="pre">stop</span></tt> 当作最大下标来处理。</div>
</div>
<div class="line-block">
<div class="line">可以通过使用 <tt class="docutils literal"><span class="pre">WITHSCORES</span></tt> 选项，来让成员和它的 <tt class="docutils literal"><span class="pre">score</span></tt> 值一并返回，返回列表以 <tt class="docutils literal"><span class="pre">value1,score1,</span> <span class="pre">...,</span> <span class="pre">valueN,scoreN</span></tt> 的格式表示。</div>
<div class="line">客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</div>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N)+M)， <tt class="docutils literal"><span class="pre">N</span></tt> 为有序集的基数，而 <tt class="docutils literal"><span class="pre">M</span></tt> 为结果集的基数。</dd>
<dt><strong>返回值:</strong></dt>
<dd>指定区间内，带有 <tt class="docutils literal"><span class="pre">score</span></tt> 值(可选)的有序集成员的列表。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis &gt; ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员
1) &quot;jack&quot;
2) &quot;3500&quot;
3) &quot;tom&quot;
4) &quot;5000&quot;
5) &quot;boss&quot;
6) &quot;10086&quot;

redis &gt; ZRANGE salary 1 2 WITHSCORES              # 显示有序集下标区间 1 至 2 的成员
1) &quot;tom&quot;
2) &quot;5000&quot;
3) &quot;boss&quot;
4) &quot;10086&quot;

redis &gt; ZRANGE salary 0 200000 WITHSCORES         # 测试 end 下标超出最大下标时的情况
1) &quot;jack&quot;
2) &quot;3500&quot;
3) &quot;tom&quot;
4) &quot;5000&quot;
5) &quot;boss&quot;
6) &quot;10086&quot;

redis &gt; ZRANGE salary 200000 3000000 WITHSCORES   # 测试当给定区间不存在于有序集时的情况
(empty list or set)
</pre></div>
</div>
</div>
<span id="document-sorted_set/zrangebyscore"></span><div class="section" id="zrangebyscore">
<span id="id1"></span><h4>ZRANGEBYSCORE<a class="headerlink" href="#zrangebyscore" title="Permalink to this headline">¶</a></h4>
<p><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</strong></p>
<p>返回有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中，所有 <tt class="docutils literal"><span class="pre">score</span></tt> 值介于 <tt class="docutils literal"><span class="pre">min</span></tt> 和 <tt class="docutils literal"><span class="pre">max</span></tt> 之间(包括等于 <tt class="docutils literal"><span class="pre">min</span></tt> 或 <tt class="docutils literal"><span class="pre">max</span></tt> )的成员。有序集成员按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递增(从小到大)次序排列。</p>
<p>具有相同 <tt class="docutils literal"><span class="pre">score</span></tt> 值的成员按字典序(<a class="reference external" href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographical order</a>)来排列(该属性是有序集提供的，不需要额外的计算)。</p>
<p>可选的 <tt class="docutils literal"><span class="pre">LIMIT</span></tt> 参数指定返回结果的数量及区间(就像SQL中的 <tt class="docutils literal"><span class="pre">SELECT</span> <span class="pre">LIMIT</span> <span class="pre">offset,</span> <span class="pre">count</span></tt> )，注意当 <tt class="docutils literal"><span class="pre">offset</span></tt> 很大时，定位 <tt class="docutils literal"><span class="pre">offset</span></tt> 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</p>
<div class="line-block">
<div class="line">可选的 <tt class="docutils literal"><span class="pre">WITHSCORES</span></tt> 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 <tt class="docutils literal"><span class="pre">score</span></tt> 值一起返回。</div>
<div class="line">该选项自 Redis 2.0 版本起可用。</div>
</div>
<p><strong>区间及无限</strong></p>
<p><tt class="docutils literal"><span class="pre">min</span></tt> 和 <tt class="docutils literal"><span class="pre">max</span></tt> 可以是 <tt class="docutils literal"><span class="pre">-inf</span></tt> 和 <tt class="docutils literal"><span class="pre">+inf</span></tt> ，这样一来，你就可以在不知道有序集的最低和最高 <tt class="docutils literal"><span class="pre">score</span></tt> 值的情况下，使用 <a class="reference internal" href="#zrangebyscore">ZRANGEBYSCORE</a> 这类命令。</p>
<p>默认情况下，区间的取值使用<a class="reference external" href="http://zh.wikipedia.org/wiki/%E5%8D%80%E9%96%93">闭区间</a> (小于等于或大于等于)，你也可以通过给参数前增加 <tt class="docutils literal"><span class="pre">(</span></tt> 符号来使用可选的<a class="reference external" href="http://zh.wikipedia.org/wiki/%E5%8D%80%E9%96%93">开区间</a> (小于或大于)。</p>
<p>举个例子：</p>
<div class="highlight-python"><div class="highlight"><pre>ZRANGEBYSCORE zset (1 5
</pre></div>
</div>
<p>返回所有符合条件 <tt class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">score</span> <span class="pre">&lt;=</span> <span class="pre">5</span></tt> 的成员，而</p>
<div class="highlight-python"><div class="highlight"><pre>ZRANGEBYSCORE zset (5 (10
</pre></div>
</div>
<p>则返回所有符合条件 <tt class="docutils literal"><span class="pre">5</span> <span class="pre">&lt;</span> <span class="pre">score</span> <span class="pre">&lt;</span> <span class="pre">10</span></tt> 的成员。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.5</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N)+M)， <tt class="docutils literal"><span class="pre">N</span></tt> 为有序集的基数， <tt class="docutils literal"><span class="pre">M</span></tt> 为被结果集的基数。</dd>
<dt><strong>返回值:</strong></dt>
<dd>指定区间内，带有 <tt class="docutils literal"><span class="pre">score</span></tt> 值(可选)的有序集成员的列表。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ZADD salary 2500 jack                        # 测试数据
(integer) 0
redis&gt; ZADD salary 5000 tom
(integer) 0
redis&gt; ZADD salary 12000 peter
(integer) 0

redis&gt; ZRANGEBYSCORE salary -inf +inf               # 显示整个有序集
1) &quot;jack&quot;
2) &quot;tom&quot;
3) &quot;peter&quot;

redis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    # 显示整个有序集及成员的 score 值
1) &quot;jack&quot;
2) &quot;2500&quot;
3) &quot;tom&quot;
4) &quot;5000&quot;
5) &quot;peter&quot;
6) &quot;12000&quot;

redis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    # 显示工资 &lt;=5000 的所有成员
1) &quot;jack&quot;
2) &quot;2500&quot;
3) &quot;tom&quot;
4) &quot;5000&quot;

redis&gt; ZRANGEBYSCORE salary (5000 400000            # 显示工资大于 5000 小于等于 400000 的成员
1) &quot;peter&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zrank"></span><div class="section" id="zrank">
<span id="id1"></span><h4>ZRANK<a class="headerlink" href="#zrank" title="Permalink to this headline">¶</a></h4>
<p><strong>ZRANK key member</strong></p>
<p>返回有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中成员 <tt class="docutils literal"><span class="pre">member</span></tt> 的排名。其中有序集成员按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递增(从小到大)顺序排列。</p>
<p>排名以 <tt class="docutils literal"><span class="pre">0</span></tt> 为底，也就是说， <tt class="docutils literal"><span class="pre">score</span></tt> 值最小的成员排名为 <tt class="docutils literal"><span class="pre">0</span></tt> 。</p>
<p>使用 <a class="reference internal" href="index.html#zrevrank"><em>ZREVRANK</em></a> 命令可以获得成员按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递减(从大到小)排列的排名。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N))</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果 <tt class="docutils literal"><span class="pre">member</span></tt> 是有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 的成员，返回 <tt class="docutils literal"><span class="pre">member</span></tt> 的排名。</div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">member</span></tt> 不是有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 的成员，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 显示所有成员及其 score 值
1) &quot;peter&quot;
2) &quot;3500&quot;
3) &quot;tom&quot;
4) &quot;4000&quot;
5) &quot;jack&quot;
6) &quot;5000&quot;

redis&gt; ZRANK salary tom                     # 显示 tom 的薪水排名，第二
(integer) 1
</pre></div>
</div>
</div>
<span id="document-sorted_set/zrem"></span><div class="section" id="zrem">
<span id="id1"></span><h4>ZREM<a class="headerlink" href="#zrem" title="Permalink to this headline">¶</a></h4>
<p><strong>ZREM key member [member ...]</strong></p>
<p>移除有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中的一个或多个成员，不存在的成员将被忽略。</p>
<p>当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在但不是有序集类型时，返回一个错误。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在 Redis 2.4 版本以前， <a class="reference internal" href="#zrem">ZREM</a> 每次只能删除一个元素。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(M*log(N))， <tt class="docutils literal"><span class="pre">N</span></tt> 为有序集的基数， <tt class="docutils literal"><span class="pre">M</span></tt> 为被成功移除的成员的数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd>被成功移除的成员的数量，不包括被忽略的成员。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 测试数据

redis&gt; ZRANGE page_rank 0 -1 WITHSCORES
1) &quot;bing.com&quot;
2) &quot;8&quot;
3) &quot;baidu.com&quot;
4) &quot;9&quot;
5) &quot;google.com&quot;
6) &quot;10&quot;


# 移除单个元素

redis&gt; ZREM page_rank google.com
(integer) 1

redis&gt; ZRANGE page_rank 0 -1 WITHSCORES
1) &quot;bing.com&quot;
2) &quot;8&quot;
3) &quot;baidu.com&quot;
4) &quot;9&quot;


# 移除多个元素

redis&gt; ZREM page_rank baidu.com bing.com
(integer) 2

redis&gt; ZRANGE page_rank 0 -1 WITHSCORES
(empty list or set)


# 移除不存在元素

redis&gt; ZREM page_rank non-exists-element
(integer) 0
</pre></div>
</div>
</div>
<span id="document-sorted_set/zremrangebyrank"></span><div class="section" id="zremrangebyrank">
<span id="id1"></span><h4>ZREMRANGEBYRANK<a class="headerlink" href="#zremrangebyrank" title="Permalink to this headline">¶</a></h4>
<p><strong>ZREMRANGEBYRANK key start stop</strong></p>
<p>移除有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中，指定排名(rank)区间内的所有成员。</p>
<p>区间分别以下标参数 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">stop</span></tt> 指出，包含 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">stop</span></tt> 在内。</p>
<div class="line-block">
<div class="line">下标参数 <tt class="docutils literal"><span class="pre">start</span></tt> 和 <tt class="docutils literal"><span class="pre">stop</span></tt> 都以 <tt class="docutils literal"><span class="pre">0</span></tt> 为底，也就是说，以 <tt class="docutils literal"><span class="pre">0</span></tt> 表示有序集第一个成员，以 <tt class="docutils literal"><span class="pre">1</span></tt> 表示有序集第二个成员，以此类推。</div>
<div class="line">你也可以使用负数下标，以 <tt class="docutils literal"><span class="pre">-1</span></tt> 表示最后一个成员， <tt class="docutils literal"><span class="pre">-2</span></tt> 表示倒数第二个成员，以此类推。</div>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N)+M)， <tt class="docutils literal"><span class="pre">N</span></tt> 为有序集的基数，而 <tt class="docutils literal"><span class="pre">M</span></tt> 为被移除成员的数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd>被移除成员的数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ZADD salary 2000 jack
(integer) 1
redis&gt; ZADD salary 5000 tom
(integer) 1
redis&gt; ZADD salary 3500 peter
(integer) 1

redis&gt; ZREMRANGEBYRANK salary 0 1       # 移除下标 0 至 1 区间内的成员
(integer) 2

redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 有序集只剩下一个成员
1) &quot;tom&quot;
2) &quot;5000&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zremrangebyscore"></span><div class="section" id="zremrangebyscore">
<span id="id1"></span><h4>ZREMRANGEBYSCORE<a class="headerlink" href="#zremrangebyscore" title="Permalink to this headline">¶</a></h4>
<p><strong>ZREMRANGEBYSCORE key min max</strong></p>
<p>移除有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中，所有 <tt class="docutils literal"><span class="pre">score</span></tt> 值介于 <tt class="docutils literal"><span class="pre">min</span></tt> 和 <tt class="docutils literal"><span class="pre">max</span></tt> 之间(包括等于 <tt class="docutils literal"><span class="pre">min</span></tt> 或 <tt class="docutils literal"><span class="pre">max</span></tt> )的成员。</p>
<p>自版本2.1.6开始， <tt class="docutils literal"><span class="pre">score</span></tt> 值等于 <tt class="docutils literal"><span class="pre">min</span></tt> 或 <tt class="docutils literal"><span class="pre">max</span></tt> 的成员也可以不包括在内，详情请参见 <a class="reference internal" href="index.html#zrangebyscore"><em>ZRANGEBYSCORE</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N)+M)， <tt class="docutils literal"><span class="pre">N</span></tt> 为有序集的基数，而 <tt class="docutils literal"><span class="pre">M</span></tt> 为被移除成员的数量。</dd>
<dt><strong>返回值:</strong></dt>
<dd>被移除成员的数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值
1) &quot;tom&quot;
2) &quot;2000&quot;
3) &quot;peter&quot;
4) &quot;3500&quot;
5) &quot;jack&quot;
6) &quot;5000&quot;

redis&gt; ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工
(integer) 2

redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员
1) &quot;jack&quot;
2) &quot;5000&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zrevrange"></span><div class="section" id="zrevrange">
<span id="id1"></span><h4>ZREVRANGE<a class="headerlink" href="#zrevrange" title="Permalink to this headline">¶</a></h4>
<p><strong>ZREVRANGE key start stop [WITHSCORES]</strong></p>
<p>返回有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中，指定区间内的成员。</p>
<div class="line-block">
<div class="line">其中成员的位置按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递减(从大到小)来排列。</div>
<div class="line">具有相同 <tt class="docutils literal"><span class="pre">score</span></tt> 值的成员按字典序的逆序(<a class="reference external" href="http://en.wikipedia.org/wiki/Lexicographical_order#Reverse_lexicographic_order">reverse lexicographical order</a>)排列。</div>
</div>
<p>除了成员按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递减的次序排列这一点外， <a class="reference internal" href="#zrevrange">ZREVRANGE</a> 命令的其他方面和 <a class="reference internal" href="index.html#zrange"><em>ZRANGE</em></a> 命令一样。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N)+M)， <tt class="docutils literal"><span class="pre">N</span></tt> 为有序集的基数，而 <tt class="docutils literal"><span class="pre">M</span></tt> 为结果集的基数。</dd>
<dt><strong>返回值:</strong></dt>
<dd>指定区间内，带有 <tt class="docutils literal"><span class="pre">score</span></tt> 值(可选)的有序集成员的列表。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ZRANGE salary 0 -1 WITHSCORES        # 递增排列
1) &quot;peter&quot;
2) &quot;3500&quot;
3) &quot;tom&quot;
4) &quot;4000&quot;
5) &quot;jack&quot;
6) &quot;5000&quot;

redis&gt; ZREVRANGE salary 0 -1 WITHSCORES     # 递减排列
1) &quot;jack&quot;
2) &quot;5000&quot;
3) &quot;tom&quot;
4) &quot;4000&quot;
5) &quot;peter&quot;
6) &quot;3500&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zrevrangebyscore"></span><div class="section" id="zrevrangebyscore">
<span id="id1"></span><h4>ZREVRANGEBYSCORE<a class="headerlink" href="#zrevrangebyscore" title="Permalink to this headline">¶</a></h4>
<p><strong>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</strong></p>
<p>返回有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中， <tt class="docutils literal"><span class="pre">score</span></tt> 值介于 <tt class="docutils literal"><span class="pre">max</span></tt> 和 <tt class="docutils literal"><span class="pre">min</span></tt> 之间(默认包括等于 <tt class="docutils literal"><span class="pre">max</span></tt> 或 <tt class="docutils literal"><span class="pre">min</span></tt> )的所有的成员。有序集成员按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递减(从大到小)的次序排列。</p>
<p>具有相同 <tt class="docutils literal"><span class="pre">score</span></tt> 值的成员按字典序的逆序(<a class="reference external" href="http://en.wikipedia.org/wiki/Lexicographical_order">reverse lexicographical order</a> )排列。</p>
<p>除了成员按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递减的次序排列这一点外， <a class="reference internal" href="#zrevrangebyscore">ZREVRANGEBYSCORE</a> 命令的其他方面和 <a class="reference internal" href="index.html#zrangebyscore"><em>ZRANGEBYSCORE</em></a> 命令一样。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N)+M)， <tt class="docutils literal"><span class="pre">N</span></tt> 为有序集的基数， <tt class="docutils literal"><span class="pre">M</span></tt> 为结果集的基数。</dd>
<dt><strong>返回值:</strong></dt>
<dd>指定区间内，带有 <tt class="docutils literal"><span class="pre">score</span></tt> 值(可选)的有序集成员的列表。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis &gt; ZADD salary 10086 jack
(integer) 1
redis &gt; ZADD salary 5000 tom
(integer) 1
redis &gt; ZADD salary 7500 peter
(integer) 1
redis &gt; ZADD salary 3500 joe
(integer) 1

redis &gt; ZREVRANGEBYSCORE salary +inf -inf   # 逆序排列所有成员
1) &quot;jack&quot;
2) &quot;peter&quot;
3) &quot;tom&quot;
4) &quot;joe&quot;

redis &gt; ZREVRANGEBYSCORE salary 10000 2000  # 逆序排列薪水介于 10000 和 2000 之间的成员
1) &quot;peter&quot;
2) &quot;tom&quot;
3) &quot;joe&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zrevrank"></span><div class="section" id="zrevrank">
<span id="id1"></span><h4>ZREVRANK<a class="headerlink" href="#zrevrank" title="Permalink to this headline">¶</a></h4>
<p><strong>ZREVRANK key member</strong></p>
<p>返回有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中成员 <tt class="docutils literal"><span class="pre">member</span></tt> 的排名。其中有序集成员按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递减(从大到小)排序。</p>
<p>排名以 <tt class="docutils literal"><span class="pre">0</span></tt> 为底，也就是说， <tt class="docutils literal"><span class="pre">score</span></tt> 值最大的成员排名为 <tt class="docutils literal"><span class="pre">0</span></tt> 。</p>
<p>使用 <a class="reference internal" href="index.html#zrank"><em>ZRANK</em></a> 命令可以获得成员按 <tt class="docutils literal"><span class="pre">score</span></tt> 值递增(从小到大)排列的排名。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(log(N))</dd>
<dt><strong>返回值:</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果 <tt class="docutils literal"><span class="pre">member</span></tt> 是有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 的成员，返回 <tt class="docutils literal"><span class="pre">member</span></tt> 的排名。</div>
<div class="line">如果 <tt class="docutils literal"><span class="pre">member</span></tt> 不是有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 的成员，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES     # 测试数据
1) &quot;jack&quot;
2) &quot;2000&quot;
3) &quot;peter&quot;
4) &quot;3500&quot;
5) &quot;tom&quot;
6) &quot;5000&quot;

redis&gt; ZREVRANK salary peter     # peter 的工资排第二
(integer) 1

redis&gt; ZREVRANK salary tom       # tom 的工资最高
(integer) 0
</pre></div>
</div>
</div>
<span id="document-sorted_set/zscore"></span><div class="section" id="zscore">
<span id="id1"></span><h4>ZSCORE<a class="headerlink" href="#zscore" title="Permalink to this headline">¶</a></h4>
<p><strong>ZSCORE key member</strong></p>
<p>返回有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 中，成员 <tt class="docutils literal"><span class="pre">member</span></tt> 的 <tt class="docutils literal"><span class="pre">score</span></tt> 值。</p>
<p>如果 <tt class="docutils literal"><span class="pre">member</span></tt> 元素不是有序集 <tt class="docutils literal"><span class="pre">key</span></tt> 的成员，或 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值:</strong></dt>
<dd><tt class="docutils literal"><span class="pre">member</span></tt> 成员的 <tt class="docutils literal"><span class="pre">score</span></tt> 值，以字符串形式表示。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ZRANGE salary 0 -1 WITHSCORES    # 测试数据
1) &quot;tom&quot;
2) &quot;2000&quot;
3) &quot;peter&quot;
4) &quot;3500&quot;
5) &quot;jack&quot;
6) &quot;5000&quot;

redis&gt; ZSCORE salary peter              # 注意返回值是字符串
&quot;3500&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zunionstore"></span><div class="section" id="zunionstore">
<span id="id1"></span><h4>ZUNIONSTORE<a class="headerlink" href="#zunionstore" title="Permalink to this headline">¶</a></h4>
<p><strong>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</strong></p>
<p>计算给定的一个或多个有序集的并集，其中给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的数量必须以 <tt class="docutils literal"><span class="pre">numkeys</span></tt> 参数指定，并将该并集(结果集)储存到 <tt class="docutils literal"><span class="pre">destination</span></tt> 。</p>
<p>默认情况下，结果集中某个成员的 <tt class="docutils literal"><span class="pre">score</span></tt> 值是所有给定集下该成员 <tt class="docutils literal"><span class="pre">score</span></tt> 值之 <em>和</em> 。</p>
<p><strong>WEIGHTS</strong></p>
<p>使用 <tt class="docutils literal"><span class="pre">WEIGHTS</span></tt> 选项，你可以为 <em>每个</em> 给定有序集 <em>分别</em> 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 <tt class="docutils literal"><span class="pre">score</span></tt> 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p>
<p>如果没有指定 <tt class="docutils literal"><span class="pre">WEIGHTS</span></tt> 选项，乘法因子默认设置为 <tt class="docutils literal"><span class="pre">1</span></tt> 。</p>
<p><strong>AGGREGATE</strong></p>
<p>使用 <tt class="docutils literal"><span class="pre">AGGREGATE</span></tt> 选项，你可以指定并集的结果集的聚合方式。</p>
<p>默认使用的参数 <tt class="docutils literal"><span class="pre">SUM</span></tt> ，可以将所有集合中某个成员的 <tt class="docutils literal"><span class="pre">score</span></tt> 值之 <em>和</em> 作为结果集中该成员的 <tt class="docutils literal"><span class="pre">score</span></tt> 值；使用参数 <tt class="docutils literal"><span class="pre">MIN</span></tt> ，可以将所有集合中某个成员的 <em>最小</em>  <tt class="docutils literal"><span class="pre">score</span></tt> 值作为结果集中该成员的 <tt class="docutils literal"><span class="pre">score</span></tt> 值；而参数 <tt class="docutils literal"><span class="pre">MAX</span></tt> 则是将所有集合中某个成员的 <em>最大</em>  <tt class="docutils literal"><span class="pre">score</span></tt> 值作为结果集中该成员的 <tt class="docutils literal"><span class="pre">score</span></tt> 值。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N)+O(M log(M))， <tt class="docutils literal"><span class="pre">N</span></tt> 为给定有序集基数的总和， <tt class="docutils literal"><span class="pre">M</span></tt> 为结果集的基数。</dd>
<dt><strong>返回值:</strong></dt>
<dd>保存到 <tt class="docutils literal"><span class="pre">destination</span></tt> 的结果集的基数。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ZRANGE programmer 0 -1 WITHSCORES
1) &quot;peter&quot;
2) &quot;2000&quot;
3) &quot;jack&quot;
4) &quot;3500&quot;
5) &quot;tom&quot;
6) &quot;5000&quot;

redis&gt; ZRANGE manager 0 -1 WITHSCORES
1) &quot;herry&quot;
2) &quot;2000&quot;
3) &quot;mary&quot;
4) &quot;3500&quot;
5) &quot;bob&quot;
6) &quot;4000&quot;

redis&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   # 公司决定加薪。。。除了程序员。。。
(integer) 6

redis&gt; ZRANGE salary 0 -1 WITHSCORES
1) &quot;peter&quot;
2) &quot;2000&quot;
3) &quot;jack&quot;
4) &quot;3500&quot;
5) &quot;tom&quot;
6) &quot;5000&quot;
7) &quot;herry&quot;
8) &quot;6000&quot;
9) &quot;mary&quot;
10) &quot;10500&quot;
11) &quot;bob&quot;
12) &quot;12000&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zinterstore"></span><div class="section" id="zinterstore">
<span id="id1"></span><h4>ZINTERSTORE<a class="headerlink" href="#zinterstore" title="Permalink to this headline">¶</a></h4>
<p><strong>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</strong></p>
<p>计算给定的一个或多个有序集的交集，其中给定 <tt class="docutils literal"><span class="pre">key</span></tt> 的数量必须以 <tt class="docutils literal"><span class="pre">numkeys</span></tt> 参数指定，并将该交集(结果集)储存到 <tt class="docutils literal"><span class="pre">destination</span></tt> 。</p>
<p>默认情况下，结果集中某个成员的 <tt class="docutils literal"><span class="pre">score</span></tt> 值是所有给定集下该成员 <tt class="docutils literal"><span class="pre">score</span></tt> 值之和.</p>
<p>关于 <tt class="docutils literal"><span class="pre">WEIGHTS</span></tt> 和 <tt class="docutils literal"><span class="pre">AGGREGATE</span></tt> 选项的描述，参见 <a class="reference internal" href="index.html#zunionstore"><em>ZUNIONSTORE</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度:</strong></dt>
<dd>O(N*K)+O(M*log(M))， <tt class="docutils literal"><span class="pre">N</span></tt> 为给定 <tt class="docutils literal"><span class="pre">key</span></tt> 中基数最小的有序集， <tt class="docutils literal"><span class="pre">K</span></tt> 为给定有序集的数量， <tt class="docutils literal"><span class="pre">M</span></tt> 为结果集的基数。</dd>
<dt><strong>返回值:</strong></dt>
<dd>保存到 <tt class="docutils literal"><span class="pre">destination</span></tt> 的结果集的基数。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis &gt; ZADD mid_test 70 &quot;Li Lei&quot;
(integer) 1
redis &gt; ZADD mid_test 70 &quot;Han Meimei&quot;
(integer) 1
redis &gt; ZADD mid_test 99.5 &quot;Tom&quot;
(integer) 1

redis &gt; ZADD fin_test 88 &quot;Li Lei&quot;
(integer) 1
redis &gt; ZADD fin_test 75 &quot;Han Meimei&quot;
(integer) 1
redis &gt; ZADD fin_test 99.5 &quot;Tom&quot;
(integer) 1

redis &gt; ZINTERSTORE sum_point 2 mid_test fin_test
(integer) 3

redis &gt; ZRANGE sum_point 0 -1 WITHSCORES     # 显示有序集内所有成员及其 score 值
1) &quot;Han Meimei&quot;
2) &quot;145&quot;
3) &quot;Li Lei&quot;
4) &quot;158&quot;
5) &quot;Tom&quot;
6) &quot;199&quot;
</pre></div>
</div>
</div>
<span id="document-sorted_set/zscan"></span><div class="section" id="zscan">
<span id="id1"></span><h4>ZSCAN<a class="headerlink" href="#zscan" title="Permalink to this headline">¶</a></h4>
<p><strong>ZSCAN key cursor [MATCH pattern] [COUNT count]</strong></p>
<p>详细信息请参考 <a class="reference internal" href="index.html#scan"><em>SCAN</em></a> 命令。</p>
</div>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-pub_sub/index"></span><div class="section" id="pub-sub">
<h3>Pub/Sub（发布/订阅）<a class="headerlink" href="#pub-sub" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-pub_sub/psubscribe"></span><div class="section" id="psubscribe">
<span id="id1"></span><h4>PSUBSCRIBE<a class="headerlink" href="#psubscribe" title="Permalink to this headline">¶</a></h4>
<p><strong>PSUBSCRIBE pattern [pattern ...]</strong></p>
<p>订阅一个或多个符合给定模式的频道。</p>
<p>每个模式以 <tt class="docutils literal"><span class="pre">*</span></tt> 作为匹配符，比如 <tt class="docutils literal"><span class="pre">it*</span></tt> 匹配所有以 <tt class="docutils literal"><span class="pre">it</span></tt> 开头的频道( <tt class="docutils literal"><span class="pre">it.news</span></tt> 、 <tt class="docutils literal"><span class="pre">it.blog</span></tt> 、 <tt class="docutils literal"><span class="pre">it.tweets</span></tt> 等等)， <tt class="docutils literal"><span class="pre">news.*</span></tt> 匹配所有以 <tt class="docutils literal"><span class="pre">news.</span></tt> 开头的频道( <tt class="docutils literal"><span class="pre">news.it</span></tt> 、 <tt class="docutils literal"><span class="pre">news.global.today</span></tt> 等等)，诸如此类。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 是订阅的模式的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>接收到的信息(请参见下面的代码说明)。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 订阅 news.* 和 tweet.* 两个模式

# 第 1 - 6 行是执行 psubscribe 之后的反馈信息
# 第 7 - 10 才是接收到的第一条信息
# 第 11 - 14 是第二条
# 以此类推。。。

redis&gt; psubscribe news.* tweet.*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;                  # 返回值的类型：显示订阅成功
2) &quot;news.*&quot;                      # 订阅的模式
3) (integer) 1                   # 目前已订阅的模式的数量

1) &quot;psubscribe&quot;
2) &quot;tweet.*&quot;
3) (integer) 2

1) &quot;pmessage&quot;                    # 返回值的类型：信息
2) &quot;news.*&quot;                      # 信息匹配的模式
3) &quot;news.it&quot;                     # 信息本身的目标频道
4) &quot;Google buy Motorola&quot;         # 信息的内容

1) &quot;pmessage&quot;
2) &quot;tweet.*&quot;
3) &quot;tweet.huangz&quot;
4) &quot;hello&quot;

1) &quot;pmessage&quot;
2) &quot;tweet.*&quot;
3) &quot;tweet.joe&quot;
4) &quot;@huangz morning&quot;

1) &quot;pmessage&quot;
2) &quot;news.*&quot;
3) &quot;news.life&quot;
4) &quot;An apple a day, keep doctors away&quot;
</pre></div>
</div>
</div>
<span id="document-pub_sub/publish"></span><div class="section" id="publish">
<span id="id1"></span><h4>PUBLISH<a class="headerlink" href="#publish" title="Permalink to this headline">¶</a></h4>
<p><strong>PUBLISH channel message</strong></p>
<p>将信息 <tt class="docutils literal"><span class="pre">message</span></tt> 发送到指定的频道 <tt class="docutils literal"><span class="pre">channel</span></tt> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N+M)，其中 <tt class="docutils literal"><span class="pre">N</span></tt> 是频道 <tt class="docutils literal"><span class="pre">channel</span></tt> 的订阅者数量，而 <tt class="docutils literal"><span class="pre">M</span></tt> 则是使用模式订阅(subscribed patterns)的客户端的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>接收到信息 <tt class="docutils literal"><span class="pre">message</span></tt> 的订阅者数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 对没有订阅者的频道发送信息

redis&gt; publish bad_channel &quot;can any body hear me?&quot;
(integer) 0


# 向有一个订阅者的频道发送信息

redis&gt; publish msg &quot;good morning&quot;
(integer) 1


# 向有多个订阅者的频道发送信息

redis&gt; publish chat_room &quot;hello~ everyone&quot;
(integer) 3
</pre></div>
</div>
</div>
<span id="document-pub_sub/pubsub"></span><div class="section" id="pubsub">
<span id="id1"></span><h4>PUBSUB<a class="headerlink" href="#pubsub" title="Permalink to this headline">¶</a></h4>
<p><strong>PUBSUB &lt;subcommand&gt; [argument [argument ...]]</strong></p>
<p><a class="reference internal" href="index.html#pubsub"><em>PUBSUB</em></a> 是一个查看订阅与发布系统状态的内省命令，
它由数个不同格式的子命令组成，
以下将分别对这些子命令进行介绍。</p>
<p><strong>可用版本：</strong> &gt;= 2.8.0</p>
<div class="section" id="pubsub-channels-pattern">
<h5>PUBSUB CHANNELS [pattern]<a class="headerlink" href="#pubsub-channels-pattern" title="Permalink to this headline">¶</a></h5>
<p>列出当前的活跃频道。</p>
<p>活跃频道指的是那些至少有一个订阅者的频道，
订阅模式的客户端不计算在内。</p>
<p><tt class="docutils literal"><span class="pre">pattern</span></tt> 参数是可选的：</p>
<ul class="simple">
<li>如果不给出 <tt class="docutils literal"><span class="pre">pattern</span></tt> 参数，那么列出订阅与发布系统中的所有活跃频道。</li>
<li>如果给出 <tt class="docutils literal"><span class="pre">pattern</span></tt> 参数，那么只列出和给定模式 <tt class="docutils literal"><span class="pre">pattern</span></tt> 相匹配的那些活跃频道。</li>
</ul>
<p><strong>复杂度：</strong> O(N) ， <tt class="docutils literal"><span class="pre">N</span></tt> 为活跃频道的数量（对于长度较短的频道和模式来说，将进行模式匹配的复杂度视为常数）。</p>
<p><strong>返回值：</strong> 一个由活跃频道组成的列表。</p>
<div class="highlight-python"><div class="highlight"><pre># client-1 订阅 news.it 和 news.sport 两个频道

client-1&gt; SUBSCRIBE news.it news.sport
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;news.it&quot;
3) (integer) 1
1) &quot;subscribe&quot;
2) &quot;news.sport&quot;
3) (integer) 2

# client-2 订阅 news.it 和 news.internet 两个频道

client-2&gt; SUBSCRIBE news.it news.internet
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;news.it&quot;
3) (integer) 1
1) &quot;subscribe&quot;
2) &quot;news.internet&quot;
3) (integer) 2

# 首先， client-3 打印所有活跃频道
# 注意，即使一个频道有多个订阅者，它也只输出一次，比如 news.it

client-3&gt; PUBSUB CHANNELS
1) &quot;news.sport&quot;
2) &quot;news.internet&quot;
3) &quot;news.it&quot;

# 接下来， client-3 打印那些与模式 news.i* 相匹配的活跃频道
# 因为 news.sport 不匹配 news.i* ，所以它没有被打印

redis&gt; PUBSUB CHANNELS news.i*
1) &quot;news.internet&quot;
2) &quot;news.it&quot;
</pre></div>
</div>
</div>
<div class="section" id="pubsub-numsub-channel-1-channel-n">
<h5>PUBSUB NUMSUB [channel-1 ... channel-N]<a class="headerlink" href="#pubsub-numsub-channel-1-channel-n" title="Permalink to this headline">¶</a></h5>
<p>返回给定频道的订阅者数量，
订阅模式的客户端不计算在内。</p>
<p><strong>复杂度：</strong> O(N) ， <tt class="docutils literal"><span class="pre">N</span></tt> 为给定频道的数量。</p>
<p><strong>返回值：</strong>
一个多条批量回复（Multi-bulk reply），回复中包含给定的频道，以及频道的订阅者数量。
格式为：频道 <tt class="docutils literal"><span class="pre">channel-1</span></tt> ， <tt class="docutils literal"><span class="pre">channel-1</span></tt> 的订阅者数量，频道 <tt class="docutils literal"><span class="pre">channel-2</span></tt> ， <tt class="docutils literal"><span class="pre">channel-2</span></tt> 的订阅者数量，诸如此类。
回复中频道的排列顺序和执行命令时给定频道的排列顺序一致。
不给定任何频道而直接调用这个命令也是可以的，
在这种情况下，
命令只返回一个空列表。</p>
<div class="highlight-python"><div class="highlight"><pre># client-1 订阅 news.it 和 news.sport 两个频道

client-1&gt; SUBSCRIBE news.it news.sport
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;news.it&quot;
3) (integer) 1
1) &quot;subscribe&quot;
2) &quot;news.sport&quot;
3) (integer) 2

# client-2 订阅 news.it 和 news.internet 两个频道

client-2&gt; SUBSCRIBE news.it news.internet
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;news.it&quot;
3) (integer) 1
1) &quot;subscribe&quot;
2) &quot;news.internet&quot;
3) (integer) 2

# client-3 打印各个频道的订阅者数量

client-3&gt; PUBSUB NUMSUB news.it news.internet news.sport news.music
1) &quot;news.it&quot;    # 频道
2) &quot;2&quot;          # 订阅该频道的客户端数量
3) &quot;news.internet&quot;
4) &quot;1&quot;
5) &quot;news.sport&quot;
6) &quot;1&quot;
7) &quot;news.music&quot; # 没有任何订阅者
8) &quot;0&quot;
</pre></div>
</div>
</div>
<div class="section" id="pubsub-numpat">
<h5>PUBSUB NUMPAT<a class="headerlink" href="#pubsub-numpat" title="Permalink to this headline">¶</a></h5>
<p>返回订阅模式的数量。</p>
<p>注意，
这个命令返回的不是订阅模式的客户端的数量，
而是客户端订阅的所有模式的数量总和。</p>
<p><strong>复杂度：</strong> O(1) 。</p>
<p><strong>返回值：</strong> 一个整数回复（Integer reply）。</p>
<div class="highlight-python"><div class="highlight"><pre># client-1 订阅 news.* 和 discount.* 两个模式

client-1&gt; PSUBSCRIBE news.* discount.*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;news.*&quot;
3) (integer) 1
1) &quot;psubscribe&quot;
2) &quot;discount.*&quot;
3) (integer) 2

# client-2 订阅 tweet.* 一个模式

client-2&gt; PSUBSCRIBE tweet.*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;tweet.*&quot;
3) (integer) 1

# client-3 返回当前订阅模式的数量为 3

client-3&gt; PUBSUB NUMPAT
(integer) 3

# 注意，当有多个客户端订阅相同的模式时，相同的订阅也被计算在 PUBSUB NUMPAT 之内
# 比如说，再新建一个客户端 client-4 ，让它也订阅 news.* 频道

client-4&gt; PSUBSCRIBE news.*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;news.*&quot;
3) (integer) 1

# 这时再计算被订阅模式的数量，就会得到数量为 4

client-3&gt; PUBSUB NUMPAT
(integer) 4
</pre></div>
</div>
</div>
</div>
<span id="document-pub_sub/punsubscribe"></span><div class="section" id="punsubscribe">
<span id="id1"></span><h4>PUNSUBSCRIBE<a class="headerlink" href="#punsubscribe" title="Permalink to this headline">¶</a></h4>
<p><strong>PUNSUBSCRIBE [pattern [pattern ...]]</strong></p>
<p>指示客户端退订所有给定模式。</p>
<p>如果没有模式被指定，也即是，一个无参数的 <tt class="docutils literal"><span class="pre">PUNSUBSCRIBE</span></tt> 调用被执行，那么客户端使用 <a class="reference internal" href="index.html#psubscribe"><em>PSUBSCRIBE</em></a> 命令订阅的所有模式都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的模式。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N+M) ，其中 <tt class="docutils literal"><span class="pre">N</span></tt> 是客户端已订阅的模式的数量， <tt class="docutils literal"><span class="pre">M</span></tt> 则是系统中所有客户端订阅的模式的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>这个命令在不同的客户端中有不同的表现。</dd>
</dl>
</div>
<span id="document-pub_sub/subscribe"></span><div class="section" id="subscribe">
<span id="id1"></span><h4>SUBSCRIBE<a class="headerlink" href="#subscribe" title="Permalink to this headline">¶</a></h4>
<p><strong>SUBSCRIBE channel [channel ...]</strong></p>
<p>订阅给定的一个或多个频道的信息。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)，其中 <tt class="docutils literal"><span class="pre">N</span></tt> 是订阅的频道的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>接收到的信息(请参见下面的代码说明)。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 订阅 msg 和 chat_room 两个频道

# 1 - 6 行是执行 subscribe 之后的反馈信息
# 第 7 - 9 行才是接收到的第一条信息
# 第 10 - 12 行是第二条

redis&gt; subscribe msg chat_room
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;       # 返回值的类型：显示订阅成功
2) &quot;msg&quot;             # 订阅的频道名字
3) (integer) 1       # 目前已订阅的频道数量

1) &quot;subscribe&quot;
2) &quot;chat_room&quot;
3) (integer) 2

1) &quot;message&quot;         # 返回值的类型：信息
2) &quot;msg&quot;             # 来源(从那个频道发送过来)
3) &quot;hello moto&quot;      # 信息内容

1) &quot;message&quot;
2) &quot;chat_room&quot;
3) &quot;testing...haha&quot;
</pre></div>
</div>
</div>
<span id="document-pub_sub/unsubscribe"></span><div class="section" id="unsubscribe">
<span id="id1"></span><h4>UNSUBSCRIBE<a class="headerlink" href="#unsubscribe" title="Permalink to this headline">¶</a></h4>
<p><strong>UNSUBSCRIBE [channel [channel ...]]</strong></p>
<p>指示客户端退订给定的频道。</p>
<p>如果没有频道被指定，也即是，一个无参数的 <tt class="docutils literal"><span class="pre">UNSUBSCRIBE</span></tt> 调用被执行，那么客户端使用 <a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 命令订阅的所有频道都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N) ， <tt class="docutils literal"><span class="pre">N</span></tt> 是客户端已订阅的频道的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>这个命令在不同的客户端中有不同的表现。</dd>
</dl>
</div>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-transaction/index"></span><div class="section" id="transaction">
<h3>Transaction（事务）<a class="headerlink" href="#transaction" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-transaction/discard"></span><div class="section" id="discard">
<span id="id1"></span><h4>DISCARD<a class="headerlink" href="#discard" title="Permalink to this headline">¶</a></h4>
<p><strong>DISCARD</strong></p>
<p>取消事务，放弃执行事务块内的所有命令。</p>
<p>如果正在使用 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 <a class="reference internal" href="index.html#unwatch"><em>UNWATCH</em></a> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)。</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; MULTI
OK

redis&gt; PING
QUEUED

redis&gt; SET greeting &quot;hello&quot;
QUEUED

redis&gt; DISCARD
OK
</pre></div>
</div>
</div>
<span id="document-transaction/exec"></span><div class="section" id="exec">
<span id="id1"></span><h4>EXEC<a class="headerlink" href="#exec" title="Permalink to this headline">¶</a></h4>
<p><strong>EXEC</strong></p>
<p>执行所有事务块内的命令。</p>
<p>假如某个(或某些) key 正处于 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 <a class="reference internal" href="#exec">EXEC</a> 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>事务块内所有命令的时间复杂度的总和。</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">事务块内所有命令的返回值，按命令执行的先后顺序排列。</div>
<div class="line">当操作被打断时，返回空值 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 事务被成功执行

redis&gt; MULTI
OK

redis&gt; INCR user_id
QUEUED

redis&gt; INCR user_id
QUEUED

redis&gt; INCR user_id
QUEUED

redis&gt; PING
QUEUED

redis&gt; EXEC
1) (integer) 1
2) (integer) 2
3) (integer) 3
4) PONG


# 监视 key ，且事务成功执行

redis&gt; WATCH lock lock_times
OK

redis&gt; MULTI
OK

redis&gt; SET lock &quot;huangz&quot;
QUEUED

redis&gt; INCR lock_times
QUEUED

redis&gt; EXEC
1) OK
2) (integer) 1


# 监视 key ，且事务被打断

redis&gt; WATCH lock lock_times
OK

redis&gt; MULTI
OK

redis&gt; SET lock &quot;joe&quot;        # 就在这时，另一个客户端修改了 lock_times 的值
QUEUED

redis&gt; INCR lock_times
QUEUED

redis&gt; EXEC                  # 因为 lock_times 被修改， joe 的事务执行失败
(nil)
</pre></div>
</div>
</div>
<span id="document-transaction/multi"></span><div class="section" id="multi">
<span id="id1"></span><h4>MULTI<a class="headerlink" href="#multi" title="Permalink to this headline">¶</a></h4>
<p><strong>MULTI</strong></p>
<p>标记一个事务块的开始。</p>
<p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令原子性(atomic)地执行。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)。</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; MULTI            # 标记事务开始
OK

redis&gt; INCR user_id     # 多条命令按顺序入队
QUEUED

redis&gt; INCR user_id
QUEUED

redis&gt; INCR user_id
QUEUED

redis&gt; PING
QUEUED

redis&gt; EXEC             # 执行
1) (integer) 1
2) (integer) 2
3) (integer) 3
4) PONG
</pre></div>
</div>
</div>
<span id="document-transaction/unwatch"></span><div class="section" id="unwatch">
<span id="id1"></span><h4>UNWATCH<a class="headerlink" href="#unwatch" title="Permalink to this headline">¶</a></h4>
<p><strong>UNWATCH</strong></p>
<p>取消 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 命令对所有 key 的监视。</p>
<p>如果在执行 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 命令之后， <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令或 <a class="reference internal" href="index.html#discard"><em>DISCARD</em></a> 命令先被执行了的话，那么就不需要再执行 <a class="reference internal" href="#unwatch">UNWATCH</a> 了。</p>
<p>因为 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令会执行事务，因此 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 命令的效果已经产生了；而 <a class="reference internal" href="index.html#discard"><em>DISCARD</em></a> 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 <a class="reference internal" href="#unwatch">UNWATCH</a> 了。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; WATCH lock lock_times
OK

redis&gt; UNWATCH
OK
</pre></div>
</div>
</div>
<span id="document-transaction/watch"></span><div class="section" id="watch">
<span id="id1"></span><h4>WATCH<a class="headerlink" href="#watch" title="Permalink to this headline">¶</a></h4>
<p><strong>WATCH key [key ...]</strong></p>
<p>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)。</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; WATCH lock lock_times
OK
</pre></div>
</div>
</div>
</div>
</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="toctree-wrapper first last compound">
<span id="document-script/index"></span><div class="section" id="script">
<h3>Script（脚本）<a class="headerlink" href="#script" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-script/eval"></span><div class="section" id="eval">
<span id="id1"></span><h4>EVAL<a class="headerlink" href="#eval" title="Permalink to this headline">¶</a></h4>
<p><strong>EVAL script numkeys key [key ...] arg [arg ...]</strong></p>
<p>从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 <a class="reference internal" href="#eval">EVAL</a> 命令对 Lua 脚本进行求值。</p>
<p><tt class="docutils literal"><span class="pre">script</span></tt> 参数是一段 Lua 5.1 脚本程序，它会被运行在 Redis 服务器上下文中，这段脚本不必(也不应该)定义为一个 Lua 函数。</p>
<p><tt class="docutils literal"><span class="pre">numkeys</span></tt> 参数用于指定键名参数的个数。</p>
<p>键名参数 <tt class="docutils literal"><span class="pre">key</span> <span class="pre">[key</span> <span class="pre">...]</span></tt> 从 <a class="reference internal" href="#eval">EVAL</a> 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 <tt class="docutils literal"><span class="pre">KEYS</span></tt> 数组，用 <tt class="docutils literal"><span class="pre">1</span></tt> 为基址的形式访问( <tt class="docutils literal"><span class="pre">KEYS[1]</span></tt> ， <tt class="docutils literal"><span class="pre">KEYS[2]</span></tt> ，以此类推)。</p>
<p>在命令的最后，那些不是键名参数的附加参数 <tt class="docutils literal"><span class="pre">arg</span> <span class="pre">[arg</span> <span class="pre">...]</span></tt> ，可以在 Lua 中通过全局变量 <tt class="docutils literal"><span class="pre">ARGV</span></tt> 数组访问，访问的形式和 <tt class="docutils literal"><span class="pre">KEYS</span></tt> 变量类似( <tt class="docutils literal"><span class="pre">ARGV[1]</span></tt> 、 <tt class="docutils literal"><span class="pre">ARGV[2]</span></tt> ，诸如此类)。</p>
<p>上面这几段长长的说明可以用一个简单的例子来概括：</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; eval &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 2 key1 key2 first second
1) &quot;key1&quot;
2) &quot;key2&quot;
3) &quot;first&quot;
4) &quot;second&quot;
</pre></div>
</div>
<p>其中 <tt class="docutils literal"><span class="pre">&quot;return</span> <span class="pre">{KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot;</span></tt> 是被求值的 Lua 脚本，数字 <tt class="docutils literal"><span class="pre">2</span></tt> 指定了键名参数的数量， <tt class="docutils literal"><span class="pre">key1</span></tt> 和 <tt class="docutils literal"><span class="pre">key2</span></tt> 是键名参数，分别使用 <tt class="docutils literal"><span class="pre">KEYS[1]</span></tt> 和 <tt class="docutils literal"><span class="pre">KEYS[2]</span></tt> 访问，而最后的 <tt class="docutils literal"><span class="pre">first</span></tt> 和 <tt class="docutils literal"><span class="pre">second</span></tt> 则是附加参数，可以通过 <tt class="docutils literal"><span class="pre">ARGV[1]</span></tt> 和 <tt class="docutils literal"><span class="pre">ARGV[2]</span></tt> 访问它们。</p>
<p>在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">redis.call()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">redis.pcall()</span></tt></li>
</ul>
<p>这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误，在后面的『错误处理』部分会讲到这一点。</p>
<p><tt class="docutils literal"><span class="pre">redis.call()</span></tt> 和 <tt class="docutils literal"><span class="pre">redis.pcall()</span></tt> 两个函数的参数可以是任何格式良好(well formed)的 Redis 命令：</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; eval &quot;return redis.call(&#39;set&#39;,&#39;foo&#39;,&#39;bar&#39;)&quot; 0
OK
</pre></div>
</div>
<p>需要注意的是，上面这段脚本的确实现了将键 <tt class="docutils literal"><span class="pre">foo</span></tt> 的值设为 <tt class="docutils literal"><span class="pre">bar</span></tt> 的目的，但是，它违反了  <a class="reference internal" href="#eval">EVAL</a> 命令的语义，因为脚本里使用的所有键都应该由 <tt class="docutils literal"><span class="pre">KEYS</span></tt> 数组来传递，就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; eval &quot;return redis.call(&#39;set&#39;,KEYS[1],&#39;bar&#39;)&quot; 1 foo
OK
</pre></div>
</div>
<p>要求使用正确的形式来传递键(key)是有原因的，因为不仅仅是 <a class="reference internal" href="#eval">EVAL</a> 这个命令，所有的 Redis 命令，在执行之前都会被分析，籍此来确定命令会对哪些键进行操作。</p>
<p>因此，对于 <a class="reference internal" href="#eval">EVAL</a> 命令来说，必须使用正确的形式来传递键，才能确保分析工作正确地执行。除此之外，使用正确的形式来传递键还有很多其他好处，它的一个特别重要的用途就是确保 Redis 集群可以将你的请求发送到正确的集群节点。(对 Redis 集群的工作还在进行当中，但是脚本功能被设计成可以与集群功能保持兼容。)不过，这条规矩并不是强制性的，从而使得用户有机会滥用(abuse) Redis 单实例配置(single instance configuration)，代价是这样写出的脚本不能被 Redis 集群所兼容。</p>
<div class="section" id="lua-redis">
<h5>在 Lua 数据类型和 Redis 数据类型之间转换<a class="headerlink" href="#lua-redis" title="Permalink to this headline">¶</a></h5>
<p>当 Lua 通过 <tt class="docutils literal"><span class="pre">call()</span></tt> 或 <tt class="docutils literal"><span class="pre">pcall()</span></tt> 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 <a class="reference internal" href="#eval">EVAL</a> 将值返回给客户端。</p>
<p>数据类型之间的转换遵循这样一个设计原则：如果将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p>
<p>换句话说， Lua 类型和 Redis 类型之间存在着一一对应的转换关系。</p>
<p>以下列出的是详细的转换规则：</p>
<p>从 Redis 转换到 Lua ：</p>
<ul class="simple">
<li>Redis integer reply -&gt; Lua number / Redis 整数转换成 Lua 数字</li>
<li>Redis bulk reply -&gt; Lua string / Redis bulk 回复转换成 Lua 字符串</li>
<li>Redis multi bulk reply -&gt; Lua table (may have other Redis data types nested) / Redis 多条 bulk 回复转换成 Lua 表，表内可能有其他别的 Redis 数据类型</li>
<li>Redis status reply -&gt; Lua table with a single ok field containing the status / Redis 状态回复转换成 Lua 表，表内的 <tt class="docutils literal"><span class="pre">ok</span></tt> 域包含了状态信息</li>
<li>Redis error reply -&gt; Lua table with a single err field containing the error / Redis 错误回复转换成 Lua 表，表内的 <tt class="docutils literal"><span class="pre">err</span></tt> 域包含了错误信息</li>
<li>Redis Nil bulk reply and Nil multi bulk reply -&gt; Lua false boolean type / Redis 的 Nil 回复和 Nil 多条回复转换成 Lua 的布尔值 <tt class="docutils literal"><span class="pre">false</span></tt></li>
</ul>
<p>从 Lua 转换到 Redis：</p>
<ul class="simple">
<li>Lua number -&gt; Redis integer reply / Lua 数字转换成 Redis 整数</li>
<li>Lua string -&gt; Redis bulk reply / Lua 字符串转换成 Redis bulk 回复</li>
<li>Lua table (array) -&gt; Redis multi bulk reply / Lua 表(数组)转换成 Redis 多条 bulk 回复</li>
<li>Lua table with a single ok field -&gt; Redis status reply / 一个带单个 <tt class="docutils literal"><span class="pre">ok</span></tt> 域的 Lua 表，转换成 Redis 状态回复</li>
<li>Lua table with a single err field -&gt; Redis error reply / 一个带单个 <tt class="docutils literal"><span class="pre">err</span></tt> 域的 Lua 表，转换成 Redis 错误回复</li>
<li>Lua boolean false -&gt; Redis Nil bulk reply / Lua 的布尔值 <tt class="docutils literal"><span class="pre">false</span></tt> 转换成 Redis 的 Nil bulk 回复</li>
</ul>
<p>从 Lua 转换到 Redis 有一条额外的规则，这条规则没有和它对应的从 Redis 转换到 Lua 的规则：</p>
<ul class="simple">
<li>Lua boolean true -&gt; Redis integer reply with value of 1 / Lua 布尔值 <tt class="docutils literal"><span class="pre">true</span></tt> 转换成 Redis 整数回复中的 <tt class="docutils literal"><span class="pre">1</span></tt></li>
</ul>
<p>以下是几个类型转换的例子：</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; eval &quot;return 10&quot; 0
(integer) 10

&gt; eval &quot;return {1,2,{3,&#39;Hello World!&#39;}}&quot; 0
1) (integer) 1
2) (integer) 2
3) 1) (integer) 3
   2) &quot;Hello World!&quot;

&gt; eval &quot;return redis.call(&#39;get&#39;,&#39;foo&#39;)&quot; 0
&quot;bar&quot;
</pre></div>
</div>
<p>在上面的三个代码示例里，前两个演示了如何将 Lua 值转换成 Redis 值，最后一个例子更复杂一些，它演示了一个将 Redis 值转换成 Lua 值，然后再将 Lua 值转换成 Redis 值的类型转过程。</p>
</div>
<div class="section" id="id2">
<h5>脚本的原子性<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。这和使用 <a class="reference internal" href="index.html#multi"><em>MULTI</em></a> / <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 包围的事务很类似。在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。</p>
<p>另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难，因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心，因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。</p>
</div>
<div class="section" id="id3">
<h5>错误处理<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>前面的命令介绍部分说过， <tt class="docutils literal"><span class="pre">redis.call()</span></tt> 和 <tt class="docutils literal"><span class="pre">redis.pcall()</span></tt> 的唯一区别在于它们对错误处理的不同。</p>
<p>当 <tt class="docutils literal"><span class="pre">redis.call()</span></tt> 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; lpush foo a
(integer) 1

redis&gt; eval &quot;return redis.call(&#39;get&#39;, &#39;foo&#39;)&quot; 0
(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value
</pre></div>
</div>
<p>和 <tt class="docutils literal"><span class="pre">redis.call()</span></tt> 不同， <tt class="docutils literal"><span class="pre">redis.pcall()</span></tt> 出错时并不引发(raise)错误，而是返回一个带 <tt class="docutils literal"><span class="pre">err</span></tt> 域的 Lua 表(table)，用于表示错误：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; EVAL &quot;return redis.pcall(&#39;get&#39;, &#39;foo&#39;)&quot; 0
(error) ERR Operation against a key holding the wrong kind of value
</pre></div>
</div>
</div>
<div class="section" id="evalsha">
<h5>带宽和 EVALSHA<a class="headerlink" href="#evalsha" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="#eval">EVAL</a> 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p>
<p>为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 <a class="reference internal" href="#eval">EVAL</a> 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。</p>
<p>EVALSHA 命令的表现如下：</p>
<ul class="simple">
<li>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本</li>
<li>如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 <a class="reference internal" href="#eval">EVAL</a> 代替 EVALSHA</li>
</ul>
<p>以下是示例：</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; set foo bar
OK

&gt; eval &quot;return redis.call(&#39;get&#39;,&#39;foo&#39;)&quot; 0
&quot;bar&quot;

&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0
&quot;bar&quot;

&gt; evalsha ffffffffffffffffffffffffffffffffffffffff 0
(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/eval).
</pre></div>
</div>
<p>客户端库的底层实现可以一直乐观地使用 EVALSHA 来代替 <a class="reference internal" href="#eval">EVAL</a> ，并期望着要使用的脚本已经保存在服务器上了，只有当 <tt class="docutils literal"><span class="pre">NOSCRIPT</span></tt> 错误发生时，才使用 <a class="reference internal" href="#eval">EVAL</a> 命令重新发送脚本，这样就可以最大限度地节省带宽。</p>
<p>这也说明了执行 <a class="reference internal" href="#eval">EVAL</a> 命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变，相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用 EVALSHA 命令对脚本进行复用，免去了无谓的带宽消耗。</p>
</div>
<div class="section" id="id4">
<h5>脚本缓存<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当 <a class="reference internal" href="#eval">EVAL</a> 命令在一个 Redis 实例上成功执行某个脚本之后，随后针对这个脚本的所有 EVALSHA 命令都会成功执行。</p>
<p>刷新脚本缓存的唯一办法是显式地调用 <tt class="docutils literal"><span class="pre">SCRIPT</span> <span class="pre">FLUSH</span></tt> 命令，这个命令会清空运行过的所有脚本的缓存。通常只有在云计算环境中，Redis 实例被改作其他客户或者别的应用程序的实例时，才会执行这个命令。</p>
<p>缓存可以长时间储存而不产生内存问题的原因是，它们的体积非常小，而且数量也非常少，即使脚本在概念上类似于实现一个新命令，即使在一个大规模的程序里有成百上千的脚本，即使这些脚本会经常修改，即便如此，储存这些脚本的内存仍然是微不足道的。</p>
<p>事实上，用户会发现 Redis 不移除缓存中的脚本实际上是一个好主意。比如说，对于一个和 Redis 保持持久化链接(persistent connection)的程序来说，它可以确信，执行过一次的脚本会一直保留在内存当中，因此它可以在流水线中使用 EVALSHA 命令而不必担心因为找不到所需的脚本而产生错误(稍候我们会看到在流水线中执行脚本的相关问题)。</p>
</div>
<div class="section" id="script">
<h5>SCRIPT 命令<a class="headerlink" href="#script" title="Permalink to this headline">¶</a></h5>
<p>Redis 提供了以下几个 SCRIPT 命令，用于对脚本子系统(scripting subsystem)进行控制：</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#script-flush"><em>SCRIPT FLUSH</em></a> ：清除所有脚本缓存</li>
<li><a class="reference internal" href="index.html#script-exists"><em>SCRIPT EXISTS</em></a> ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存</li>
<li><a class="reference internal" href="index.html#script-load"><em>SCRIPT LOAD</em></a> ：将一个脚本装入脚本缓存，但并不立即运行它</li>
<li><a class="reference internal" href="index.html#script-kill"><em>SCRIPT KILL</em></a> ：杀死当前正在运行的脚本</li>
</ul>
</div>
<div class="section" id="id5">
<h5>纯函数脚本<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>在编写脚本方面，一个重要的要求就是，脚本应该被写成纯函数(pure function)。</p>
<p>也就是说，脚本应该具有以下属性：</p>
<ul class="simple">
<li>对于同样的数据集输入，给定相同的参数，脚本执行的 Redis 写命令总是相同的。脚本执行的操作不能依赖于任何隐藏(非显式)数据，不能依赖于脚本在执行过程中、或脚本在不同执行时期之间可能变更的状态，并且它也不能依赖于任何来自 I/O 设备的外部输入。</li>
</ul>
<p>使用系统时间(system time)，调用像 <a class="reference internal" href="index.html#randomkey"><em>RANDOMKEY</em></a> 那样的随机命令，或者使用 Lua 的随机数生成器，类似以上的这些操作，都会造成脚本的求值无法每次都得出同样的结果。</p>
<p>为了确保脚本符合上面所说的属性， Redis 做了以下工作：</p>
<ul class="simple">
<li>Lua 没有访问系统时间或者其他内部状态的命令</li>
<li>Redis 会返回一个错误，阻止这样的脚本运行： 这些脚本在执行随机命令之后(比如 <a class="reference internal" href="index.html#randomkey"><em>RANDOMKEY</em></a> 、 <a class="reference internal" href="index.html#srandmember"><em>SRANDMEMBER</em></a> 或 <a class="reference internal" href="index.html#time"><em>TIME</em></a> 等)，还会执行可以修改数据集的 Redis 命令。如果脚本只是执行只读操作，那么就没有这一限制。注意，随机命令并不一定就指那些带 RAND 字眼的命令，任何带有非确定性的命令都会被认为是随机命令，比如 <a class="reference internal" href="index.html#time"><em>TIME</em></a> 命令就是这方面的一个很好的例子。</li>
<li>每当从 Lua 脚本中调用那些返回无序元素的命令时，执行命令所得的数据在返回给 Lua 之前会先执行一个静默(slient)的字典序排序(<a class="reference external" href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographical sorting</a>)。举个例子，因为 Redis 的 Set 保存的是无序的元素，所以在 Redis 命令行客户端中直接执行 <a class="reference internal" href="index.html#smembers"><em>SMEMBERS</em></a> ，返回的元素是无序的，但是，假如在脚本中执行 <tt class="docutils literal"><span class="pre">redis.call(&quot;smembers&quot;,</span> <span class="pre">KEYS[1])</span></tt> ，那么返回的总是排过序的元素。</li>
<li>对 Lua 的伪随机数生成函数 <tt class="docutils literal"><span class="pre">math.random</span></tt> 和 <tt class="docutils literal"><span class="pre">math.randomseed</span></tt> 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值。这意味着，每次运行脚本时，只要不使用 <tt class="docutils literal"><span class="pre">math.randomseed</span></tt> ，那么 <tt class="docutils literal"><span class="pre">math.random</span></tt> 产生的随机数序列总是相同的。</li>
</ul>
<p>尽管有那么多的限制，但用户还是可以用一个简单的技巧写出带随机行为的脚本(如果他们需要的话)。</p>
<p>假设现在我们要编写一个 Redis 脚本，这个脚本从列表中弹出 N 个随机数。一个 Ruby 写的例子如下：</p>
<div class="highlight-python"><div class="highlight"><pre>require &#39;rubygems&#39;
require &#39;redis&#39;

r = Redis.new

RandomPushScript = &lt;&lt;EOF
    local i = tonumber(ARGV[1])
    local res
    while (i &gt; 0) do
        res = redis.call(&#39;lpush&#39;,KEYS[1],math.random())
        i = i-1
    end
    return res
EOF

r.del(:mylist)
puts r.eval(RandomPushScript,[:mylist],[10,rand(2**32)])
</pre></div>
</div>
<p>这个程序每次运行都会生成带有以下元素的列表：</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; lrange mylist 0 -1
1) &quot;0.74509509873814&quot;
2) &quot;0.87390407681181&quot;
3) &quot;0.36876626981831&quot;
4) &quot;0.6921941534114&quot;
5) &quot;0.7857992587545&quot;
6) &quot;0.57730350670279&quot;
7) &quot;0.87046522734243&quot;
8) &quot;0.09637165539729&quot;
9) &quot;0.74990198051087&quot;
10) &quot;0.17082803611217&quot;
</pre></div>
</div>
<p>上面的 Ruby 程序每次都只生成同样的列表，用途并不是太大。那么，该怎样修改这个脚本，使得它仍然是一个纯函数(符合 Redis 的要求)，但是每次调用都可以产生不同的随机元素呢？</p>
<p>一个简单的办法是，为脚本添加一个额外的参数，让这个参数作为 Lua 的随机数生成器的 seed 值，这样的话，只要给脚本传入不同的 seed ，脚本就会生成不同的列表元素。</p>
<p>以下是修改后的脚本：</p>
<div class="highlight-python"><div class="highlight"><pre>RandomPushScript = &lt;&lt;EOF
    local i = tonumber(ARGV[1])
    local res
    math.randomseed(tonumber(ARGV[2]))
    while (i &gt; 0) do
        res = redis.call(&#39;lpush&#39;,KEYS[1],math.random())
        i = i-1
    end
    return res
EOF

r.del(:mylist)
puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))
</pre></div>
</div>
<p>尽管对于同样的 seed ，上面的脚本产生的列表元素是一样的(因为它是一个纯函数)，但是只要每次在执行脚本的时候传入不同的 seed ，我们就可以得到带有不同随机元素的列表。</p>
<p>Seed 会在复制(replication link)和写 AOF 文件时作为一个参数来传播，保证在载入 AOF 文件或附属节点(slave)处理脚本时， seed 仍然可以及时得到更新。</p>
<p>注意，Redis 实现保证 <tt class="docutils literal"><span class="pre">math.random</span></tt> 和 <tt class="docutils literal"><span class="pre">math.randomseed</span></tt> 的输出和运行 Redis 的系统架构无关，无论是 32 位还是 64 位系统，无论是小端(little endian)还是大端(big endian)系统，这两个函数的输出总是相同的。</p>
</div>
<div class="section" id="id6">
<h5>全局变量保护<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h5>
<p>为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。如果一个脚本需要在多次执行之间维持某种状态，它应该使用 Redis key 来进行状态保存。</p>
<p>企图在脚本中访问一个全局变量(不论这个变量是否存在)将引起脚本停止， <a class="reference internal" href="#eval">EVAL</a> 命令会返回一个错误：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; eval &#39;a=10&#39; 0
(error) ERR Error running script (call to f_933044db579a2f8fd45d8065f04a8d0249383e57): user_script:1: Script attempted to create global variable &#39;a&#39;
</pre></div>
</div>
<p>Lua 的 debug 工具，或者其他设施，比如打印（alter）用于实现全局保护的 meta table ，都可以用于实现全局变量保护。</p>
<p>实现全局变量保护并不难，不过有时候还是会不小心而为之。一旦用户在脚本中混入了 Lua 全局状态，那么 AOF 持久化和复制（replication）都会无法保证，所以，请不要使用全局变量。</p>
<p>避免引入全局变量的一个诀窍是：将脚本中用到的所有变量都使用 <tt class="docutils literal"><span class="pre">local</span></tt> 关键字定义为局部变量。</p>
</div>
<div class="section" id="id7">
<h5>库<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h5>
<p>Redis 内置的 Lua 解释器加载了以下 Lua 库：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">base</span></tt></li>
<li><tt class="docutils literal"><span class="pre">table</span></tt></li>
<li><tt class="docutils literal"><span class="pre">string</span></tt></li>
<li><tt class="docutils literal"><span class="pre">math</span></tt></li>
<li><tt class="docutils literal"><span class="pre">debug</span></tt></li>
<li><tt class="docutils literal"><span class="pre">cjson</span></tt></li>
<li><tt class="docutils literal"><span class="pre">cmsgpack</span></tt></li>
</ul>
<p>其中 <tt class="docutils literal"><span class="pre">cjson</span></tt> 库可以让 Lua 以非常快的速度处理 JSON 数据，除此之外，其他别的都是 Lua 的标准库。</p>
<p>每个 Redis 实例都保证会加载上面列举的库，从而确保每个 Redis 脚本的运行环境都是相同的。</p>
</div>
<div class="section" id="redis">
<h5>使用脚本散发 Redis 日志<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h5>
<p>在 Lua 脚本中，可以通过调用 <tt class="docutils literal"><span class="pre">redis.log</span></tt> 函数来写 Redis 日志(log)：</p>
<p><tt class="docutils literal"><span class="pre">redis.log(loglevel,</span> <span class="pre">message)</span></tt></p>
<p>其中， <tt class="docutils literal"><span class="pre">message</span></tt> 参数是一个字符串，而 <tt class="docutils literal"><span class="pre">loglevel</span></tt> 参数可以是以下任意一个值：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">redis.LOG_DEBUG</span></tt></li>
<li><tt class="docutils literal"><span class="pre">redis.LOG_VERBOSE</span></tt></li>
<li><tt class="docutils literal"><span class="pre">redis.LOG_NOTICE</span></tt></li>
<li><tt class="docutils literal"><span class="pre">redis.LOG_WARNING</span></tt></li>
</ul>
<p>上面的这些等级(level)和标准 Redis 日志的等级相对应。</p>
<p>对于脚本散发(emit)的日志，只有那些和当前 Redis 实例所设置的日志等级相同或更高级的日志才会被散发。</p>
<p>以下是一个日志示例：</p>
<p><tt class="docutils literal"><span class="pre">redis.log(redis.LOG_WARNING,</span> <span class="pre">&quot;Something</span> <span class="pre">is</span> <span class="pre">wrong</span> <span class="pre">with</span> <span class="pre">this</span> <span class="pre">script.&quot;)</span></tt></p>
<p>执行上面的函数会产生这样的信息：</p>
<p><tt class="docutils literal"><span class="pre">[32343]</span> <span class="pre">22</span> <span class="pre">Mar</span> <span class="pre">15:21:39</span> <span class="pre">#</span> <span class="pre">Something</span> <span class="pre">is</span> <span class="pre">wrong</span> <span class="pre">with</span> <span class="pre">this</span> <span class="pre">script.</span></tt></p>
</div>
<div class="section" id="sandbox">
<h5>沙箱(sandbox)和最大执行时间<a class="headerlink" href="#sandbox" title="Permalink to this headline">¶</a></h5>
<p>脚本应该仅仅用于传递参数和对 Redis 数据进行处理，它不应该尝试去访问外部系统(比如文件系统)，或者执行任何系统调用。</p>
<p>除此之外，脚本还有一个最大执行时间限制，它的默认值是 5 秒钟，一般正常运作的脚本通常可以在几分之几毫秒之内完成，花不了那么多时间，这个限制主要是为了防止因编程错误而造成的无限循环而设置的。</p>
<p>最大执行时间的长短由 <tt class="docutils literal"><span class="pre">lua-time-limit</span></tt> 选项来控制(以毫秒为单位)，可以通过编辑 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件或者使用 <a class="reference internal" href="index.html#config-get"><em>CONFIG GET</em></a> 和 <a class="reference internal" href="index.html#config-set"><em>CONFIG SET</em></a> 命令来修改它。</p>
<p>当一个脚本达到最大执行时间的时候，它并不会自动被 Redis 结束，因为 Redis 必须保证脚本执行的原子性，而中途停止脚本的运行意味着可能会留下未处理完的数据在数据集(data set)里面。</p>
<p>因此，当脚本运行的时间超过最大执行时间后，以下动作会被执行：</p>
<ul class="simple">
<li>Redis 记录一个脚本正在超时运行</li>
<li>Redis 开始重新接受其他客户端的命令请求，但是只有 <tt class="docutils literal"><span class="pre">SCRIPT</span> <span class="pre">KILL</span></tt> 和 <tt class="docutils literal"><span class="pre">SHUTDOWN</span> <span class="pre">NOSAVE</span></tt> 两个命令会被处理，对于其他命令请求， Redis 服务器只是简单地返回 <tt class="docutils literal"><span class="pre">BUSY</span></tt> 错误。</li>
<li>可以使用 <tt class="docutils literal"><span class="pre">SCRIPT</span> <span class="pre">KILL</span></tt> 命令将一个仅执行只读命令的脚本杀死，因为只读命令并不修改数据，因此杀死这个脚本并不破坏数据的完整性</li>
<li>如果脚本已经执行过写命令，那么唯一允许执行的操作就是 <tt class="docutils literal"><span class="pre">SHUTDOWN</span> <span class="pre">NOSAVE</span></tt> ，它通过停止服务器来阻止当前数据集写入磁盘</li>
</ul>
</div>
<div class="section" id="pipeline-context-evalsha">
<h5>流水线(pipeline)上下文(context)中的 EVALSHA<a class="headerlink" href="#pipeline-context-evalsha" title="Permalink to this headline">¶</a></h5>
<p>在流水线请求的上下文中使用 EVALSHA 命令时，要特别小心，因为在流水线中，必须保证命令的执行顺序。</p>
<p>一旦在流水线中因为 EVALSHA 命令而发生 NOSCRIPT 错误，那么这个流水线就再也没有办法重新执行了，否则的话，命令的执行顺序就会被打乱。</p>
<p>为了防止出现以上所说的问题，客户端库实现应该实施以下的其中一项措施：</p>
<ul class="simple">
<li>总是在流水线中使用 <a class="reference internal" href="#eval">EVAL</a> 命令</li>
<li>检查流水线中要用到的所有命令，找到其中的 <a class="reference internal" href="#eval">EVAL</a> 命令，并使用 <a class="reference internal" href="index.html#script-exists"><em>SCRIPT EXISTS</em></a> 命令检查要用到的脚本是不是全都已经保存在缓存里面了。如果所需的全部脚本都可以在缓存里找到，那么就可以放心地将所有 <a class="reference internal" href="#eval">EVAL</a> 命令改成 EVALSHA 命令，否则的话，就要在流水线的顶端(top)将缺少的脚本用 <a class="reference internal" href="index.html#script-load"><em>SCRIPT LOAD</em></a> 命令加上去。</li>
</ul>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><a class="reference internal" href="#eval">EVAL</a> 和 EVALSHA 可以在 O(1) 复杂度内找到要被执行的脚本，其余的复杂度取决于执行的脚本本身。</dd>
</dl>
</div>
</div>
<span id="document-script/evalsha"></span><div class="section" id="evalsha">
<span id="id1"></span><h4>EVALSHA<a class="headerlink" href="#evalsha" title="Permalink to this headline">¶</a></h4>
<p><strong>EVALSHA sha1 numkeys key [key ...] arg [arg ...]</strong></p>
<p>根据给定的 sha1 校验码，对缓存在服务器中的脚本进行求值。</p>
<p>将脚本缓存到服务器的操作可以通过 <a class="reference internal" href="index.html#script-load"><em>SCRIPT LOAD</em></a> 命令进行。</p>
<p>这个命令的其他地方，比如参数的传入方式，都和 <a class="reference internal" href="index.html#eval"><em>EVAL</em></a> 命令一样。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>根据脚本的复杂度而定。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SCRIPT LOAD &quot;return &#39;hello moto&#39;&quot;
&quot;232fd51614574cf0867b83d384a5e898cfd24e5a&quot;

redis&gt; EVALSHA &quot;232fd51614574cf0867b83d384a5e898cfd24e5a&quot; 0
&quot;hello moto&quot;
</pre></div>
</div>
</div>
<span id="document-script/script_exists"></span><div class="section" id="script-exists">
<span id="id1"></span><h4>SCRIPT EXISTS<a class="headerlink" href="#script-exists" title="Permalink to this headline">¶</a></h4>
<p><strong>SCRIPT EXISTS script [script ...]</strong></p>
<p>给定一个或多个脚本的 SHA1 校验和，返回一个包含 <tt class="docutils literal"><span class="pre">0</span></tt> 和 <tt class="docutils literal"><span class="pre">1</span></tt> 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中。</p>
<p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 <a class="reference internal" href="index.html#eval"><em>EVAL</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N) , <tt class="docutils literal"><span class="pre">N</span></tt> 为给定的 SHA1 校验和的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">一个列表，包含 <tt class="docutils literal"><span class="pre">0</span></tt> 和 <tt class="docutils literal"><span class="pre">1</span></tt> ，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。</div>
<div class="line">列表中的元素和给定的 SHA1 校验和保持对应关系，比如列表的第三个元素的值就表示第三个 SHA1 校验和所指定的脚本在缓存中的状态。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SCRIPT LOAD &quot;return &#39;hello moto&#39;&quot;    # 载入一个脚本
&quot;232fd51614574cf0867b83d384a5e898cfd24e5a&quot;

redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a
1) (integer) 1

redis&gt; SCRIPT FLUSH     # 清空缓存
OK

redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a
1) (integer) 0
</pre></div>
</div>
</div>
<span id="document-script/script_flush"></span><div class="section" id="script-flush">
<span id="id1"></span><h4>SCRIPT FLUSH<a class="headerlink" href="#script-flush" title="Permalink to this headline">¶</a></h4>
<p><strong>SCRIPT FLUSH</strong></p>
<p>清除所有 Lua 脚本缓存。</p>
<p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 <a class="reference internal" href="index.html#eval"><em>EVAL</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>复杂度：</strong></dt>
<dd>O(N) ， <tt class="docutils literal"><span class="pre">N</span></tt> 为缓存中脚本的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt></dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SCRIPT FLUSH
OK
</pre></div>
</div>
</div>
<span id="document-script/script_kill"></span><div class="section" id="script-kill">
<span id="id1"></span><h4>SCRIPT KILL<a class="headerlink" href="#script-kill" title="Permalink to this headline">¶</a></h4>
<p><strong>SCRIPT KILL</strong></p>
<p>杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。</p>
<p>这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p>
<p><a class="reference internal" href="#id1">SCRIPT KILL</a> 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 <a class="reference internal" href="index.html#eval"><em>EVAL</em></a> 命令的阻塞当中退出，并收到一个错误作为返回值。</p>
<p>另一方面，假如当前正在运行的脚本已经执行过写操作，那么即使执行 <a class="reference internal" href="#id1">SCRIPT KILL</a> ，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用 <tt class="docutils literal"><span class="pre">SHUTDOWN</span> <span class="pre">NOSAVE</span></tt> 命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p>
<p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 <a class="reference internal" href="index.html#eval"><em>EVAL</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>执行成功返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，否则返回一个错误。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 没有脚本在执行时

redis&gt; SCRIPT KILL
(error) ERR No scripts in execution right now.

# 成功杀死脚本时

redis&gt; SCRIPT KILL
OK
(1.30s)

# 尝试杀死一个已经执行过写操作的脚本，失败

redis&gt; SCRIPT KILL
(error) ERR Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in an hard way using the SHUTDOWN NOSAVE command.
(1.69s)
</pre></div>
</div>
<p>以下是脚本被杀死之后，返回给执行脚本的客户端的错误：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; EVAL &quot;while true do end&quot; 0
(error) ERR Error running script (call to f_694a5fe1ddb97a4c6a1bf299d9537c7d3d0f84e7): Script killed by user with SCRIPT KILL...
(5.00s)
</pre></div>
</div>
</div>
<span id="document-script/script_load"></span><div class="section" id="script-load">
<span id="id1"></span><h4>SCRIPT LOAD<a class="headerlink" href="#script-load" title="Permalink to this headline">¶</a></h4>
<p><strong>SCRIPT LOAD script</strong></p>
<p>将脚本 <tt class="docutils literal"><span class="pre">script</span></tt> 添加到脚本缓存中，但并不立即执行这个脚本。</p>
<p><a class="reference internal" href="index.html#eval"><em>EVAL</em></a> 命令也会将脚本添加到脚本缓存中，但是它会立即对输入的脚本进行求值。</p>
<p>如果给定的脚本已经在缓存里面了，那么不做动作。</p>
<p>在脚本被加入到缓存之后，通过 EVALSHA 命令，可以使用脚本的 SHA1 校验和来调用这个脚本。</p>
<p>脚本可以在缓存中保留无限长的时间，直到执行 <a class="reference internal" href="index.html#script-flush"><em>SCRIPT FLUSH</em></a> 为止。</p>
<p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 <a class="reference internal" href="index.html#eval"><em>EVAL</em></a> 命令。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N) , <tt class="docutils literal"><span class="pre">N</span></tt> 为脚本的长度(以字节为单位)。</dd>
<dt><strong>返回值：</strong></dt>
<dd>给定 <tt class="docutils literal"><span class="pre">script</span></tt> 的 SHA1 校验和</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SCRIPT LOAD &quot;return &#39;hello moto&#39;&quot;
&quot;232fd51614574cf0867b83d384a5e898cfd24e5a&quot;

redis&gt; EVALSHA 232fd51614574cf0867b83d384a5e898cfd24e5a 0
&quot;hello moto&quot;
</pre></div>
</div>
</div>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-connection/index"></span><div class="section" id="connection">
<h3>Connection（连接）<a class="headerlink" href="#connection" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-connection/auth"></span><div class="section" id="auth">
<span id="id1"></span><h4>AUTH<a class="headerlink" href="#auth" title="Permalink to this headline">¶</a></h4>
<p><strong>AUTH password</strong></p>
<p>通过设置配置文件中 <tt class="docutils literal"><span class="pre">requirepass</span></tt> 项的值(使用命令 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span> <span class="pre">requirepass</span> <span class="pre">password</span></tt> )，可以使用密码来保护 Redis 服务器。</p>
<p>如果开启了密码保护的话，在每次连接 Redis 服务器之后，就要使用 <tt class="docutils literal"><span class="pre">AUTH</span></tt> 命令解锁，解锁之后才能使用其他 Redis 命令。</p>
<p>如果 <tt class="docutils literal"><span class="pre">AUTH</span></tt> 命令给定的密码 <tt class="docutils literal"><span class="pre">password</span></tt> 和配置文件中的密码相符的话，服务器会返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 并开始接受命令输入。</p>
<p>另一方面，假如密码不匹配的话，服务器将返回一个错误，并要求客户端需重新输入密码。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">因为 Redis 高性能的特点，在很短时间内尝试猜测非常多个密码是有可能的，因此请确保使用的密码足够复杂和足够长，以免遭受密码猜测攻击。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>密码匹配时返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，否则返回一个错误。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 设置密码

redis&gt; CONFIG SET requirepass secret_password   # 将密码设置为 secret_password
OK

redis&gt; QUIT                                     # 退出再连接，让新密码对客户端生效

[huangz@mypad]$ redis

redis&gt; PING                                     # 未验证密码，操作被拒绝
(error) ERR operation not permitted

redis&gt; AUTH wrong_password_testing              # 尝试输入错误的密码
(error) ERR invalid password

redis&gt; AUTH secret_password                     # 输入正确的密码
OK

redis&gt; PING                                     # 密码验证成功，可以正常操作命令了
PONG


# 清空密码

redis&gt; CONFIG SET requirepass &quot;&quot;   # 通过将密码设为空字符来清空密码
OK

redis&gt; QUIT

$ redis                            # 重新进入客户端

redis&gt; PING                        # 执行命令不再需要密码，清空密码操作成功
PONG
</pre></div>
</div>
</div>
<span id="document-connection/echo"></span><div class="section" id="echo">
<span id="id1"></span><h4>ECHO<a class="headerlink" href="#echo" title="Permalink to this headline">¶</a></h4>
<p><strong>ECHO message</strong></p>
<p>打印一个特定的信息 <tt class="docutils literal"><span class="pre">message</span></tt> ，测试时使用。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><tt class="docutils literal"><span class="pre">message</span></tt> 自身。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; ECHO &quot;Hello Moto&quot;
&quot;Hello Moto&quot;

redis&gt; ECHO &quot;Goodbye Moto&quot;
&quot;Goodbye Moto&quot;
</pre></div>
</div>
</div>
<span id="document-connection/ping"></span><div class="section" id="ping">
<span id="id1"></span><h4>PING<a class="headerlink" href="#ping" title="Permalink to this headline">¶</a></h4>
<p><strong>PING</strong></p>
<p>使用客户端向 Redis 服务器发送一个 <tt class="docutils literal"><span class="pre">PING</span></tt> ，如果服务器运作正常的话，会返回一个 <tt class="docutils literal"><span class="pre">PONG</span></tt> 。</p>
<p>通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>如果连接正常就返回一个 <tt class="docutils literal"><span class="pre">PONG</span></tt> ，否则返回一个连接错误。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 客户端和服务器连接正常

redis&gt; PING
PONG

# 客户端和服务器连接不正常(网络不正常或服务器未能正常运行)

redis 127.0.0.1:6379&gt; PING
Could not connect to Redis at 127.0.0.1:6379: Connection refused
</pre></div>
</div>
</div>
<span id="document-connection/quit"></span><div class="section" id="quit">
<span id="id1"></span><h4>QUIT<a class="headerlink" href="#quit" title="Permalink to this headline">¶</a></h4>
<p><strong>QUIT</strong></p>
<p>请求服务器关闭与当前客户端的连接。</p>
<p>一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> (但是不会被打印显示，因为当时 Redis-cli 已经退出)。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>$ redis

redis&gt; QUIT

$
</pre></div>
</div>
</div>
<span id="document-connection/select"></span><div class="section" id="select">
<span id="id1"></span><h4>SELECT<a class="headerlink" href="#select" title="Permalink to this headline">¶</a></h4>
<p><strong>SELECT index</strong></p>
<p>切换到指定的数据库，数据库索引号 <tt class="docutils literal"><span class="pre">index</span></tt> 用数字值指定，以 <tt class="docutils literal"><span class="pre">0</span></tt> 作为起始索引值。</p>
<p>默认使用 <tt class="docutils literal"><span class="pre">0</span></tt> 号数据库。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><tt class="docutils literal"><span class="pre">OK</span></tt></dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET db_number 0         # 默认使用 0 号数据库
OK

redis&gt; SELECT 1                # 使用 1 号数据库
OK

redis[1]&gt; GET db_number        # 已经切换到 1 号数据库，注意 Redis 现在的命令提示符多了个 [1]
(nil)

redis[1]&gt; SET db_number 1
OK

redis[1]&gt; GET db_number
&quot;1&quot;

redis[1]&gt; SELECT 3             # 再切换到 3 号数据库
OK

redis[3]&gt;                      # 提示符从 [1] 改变成了 [3]
</pre></div>
</div>
</div>
</div>
</div>
</div>
</td>
<td colspan="2"><div class="toctree-wrapper first last compound">
<span id="document-server/index"></span><div class="section" id="server">
<h3>Server（服务器）<a class="headerlink" href="#server" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-server/bgrewriteaof"></span><div class="section" id="bgrewriteaof">
<span id="id1"></span><h4>BGREWRITEAOF<a class="headerlink" href="#bgrewriteaof" title="Permalink to this headline">¶</a></h4>
<p><strong>BGREWRITEAOF</strong></p>
<p>执行一个 <a class="reference external" href="http://redis.io/topics/persistence#append-only-file">AOF文件</a> 重写操作。重写会创建一个当前 AOF 文件的体积优化版本。</p>
<p>即使 <a class="reference internal" href="#bgrewriteaof">BGREWRITEAOF</a> 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 <a class="reference internal" href="#bgrewriteaof">BGREWRITEAOF</a> 成功之前不会被修改。</p>
<p>重写操作只会在没有其他持久化工作在后台执行时被触发，也就是说：</p>
<ul class="simple">
<li>如果 Redis 的子进程正在执行快照的保存工作，那么 AOF 重写的操作会被预定(scheduled)，等到保存工作完成之后再执行 AOF 重写。在这种情况下， <a class="reference internal" href="#bgrewriteaof">BGREWRITEAOF</a> 的返回值仍然是 <tt class="docutils literal"><span class="pre">OK</span></tt> ，但还会加上一条额外的信息，说明 <a class="reference internal" href="#bgrewriteaof">BGREWRITEAOF</a> 要等到保存操作完成之后才能执行。在 Redis 2.6 或以上的版本，可以使用 <a class="reference internal" href="index.html#info"><em>INFO</em></a> 命令查看 <a class="reference internal" href="#bgrewriteaof">BGREWRITEAOF</a> 是否被预定。</li>
<li>如果已经有别的 AOF 文件重写在执行，那么 <a class="reference internal" href="#bgrewriteaof">BGREWRITEAOF</a> 返回一个错误，并且这个新的 <a class="reference internal" href="#bgrewriteaof">BGREWRITEAOF</a> 请求也不会被预定到下次执行。</li>
</ul>
<p>从 Redis 2.4 开始， AOF 重写由 Redis 自行触发， <a class="reference internal" href="#bgrewriteaof">BGREWRITEAOF</a> 仅仅用于手动触发重写操作。</p>
<p>请移步 <a class="reference external" href="http://redis.io/topics/persistence">持久化文档(英文)</a> 查看更多相关细节。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为要追加到 AOF 文件中的数据数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>反馈信息。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; BGREWRITEAOF
Background append only file rewriting started
</pre></div>
</div>
</div>
<span id="document-server/bgsave"></span><div class="section" id="bgsave">
<span id="id1"></span><h4>BGSAVE<a class="headerlink" href="#bgsave" title="Permalink to this headline">¶</a></h4>
<p>在后台异步(Asynchronously)保存当前数据库的数据到磁盘。</p>
<p><a class="reference internal" href="#bgsave">BGSAVE</a> 命令执行之后立即返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</p>
<p>客户端可以通过 <a class="reference internal" href="index.html#lastsave"><em>LASTSAVE</em></a> 命令查看相关信息，判断 <a class="reference internal" href="#bgsave">BGSAVE</a> 命令是否执行成功。</p>
<p>请移步 <a class="reference external" href="http://redis.io/topics/persistence">持久化文档</a> 查看更多相关细节。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为要保存到数据库中的 key 的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>反馈信息。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; BGSAVE
Background saving started
</pre></div>
</div>
</div>
<span id="document-server/client_getname"></span><div class="section" id="client-getname">
<span id="id1"></span><h4>CLIENT GETNAME<a class="headerlink" href="#client-getname" title="Permalink to this headline">¶</a></h4>
<p><strong>CLIENT GETNAME</strong></p>
<p>返回 <a class="reference internal" href="index.html#client-setname"><em>CLIENT SETNAME</em></a> 命令为连接设置的名字。</p>
<p>因为新创建的连接默认是没有名字的，
对于没有名字的连接，
<a class="reference internal" href="index.html#client-getname"><em>CLIENT GETNAME</em></a> 返回空白回复。</p>
<dl class="docutils">
<dt><strong>可用版本</strong></dt>
<dd>&gt;= 2.6.9</dd>
<dt><strong>时间复杂度</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值</strong></dt>
<dd><div class="first last line-block">
<div class="line">如果连接没有设置名字，那么返回空白回复；</div>
<div class="line">如果有设置名字，那么返回名字。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 新连接默认没有名字

redis 127.0.0.1:6379&gt; CLIENT GETNAME
(nil)

# 设置名字

redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection
OK

# 返回名字

redis 127.0.0.1:6379&gt; CLIENT GETNAME
&quot;hello-world-connection&quot;
</pre></div>
</div>
</div>
<span id="document-server/client_kill"></span><div class="section" id="client-kill">
<span id="id1"></span><h4>CLIENT KILL<a class="headerlink" href="#client-kill" title="Permalink to this headline">¶</a></h4>
<p><strong>CLIENT KILL ip:port</strong></p>
<p>关闭地址为 <tt class="docutils literal"><span class="pre">ip:port</span></tt> 的客户端。</p>
<p><tt class="docutils literal"><span class="pre">ip:port</span></tt> 应该和 <a class="reference internal" href="index.html#client-list"><em>CLIENT LIST</em></a> 命令输出的其中一行匹配。</p>
<p>因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。</p>
<p>如果要被断开连接的客户端正在执行命令，那么当这个命令执行之后，在发送下一个命令的时候，它就会收到一个网络错误，告知它自身的连接已被关闭。</p>
<dl class="docutils">
<dt><strong>可用版本</strong></dt>
<dd>&gt;= 2.4.0</dd>
<dt><strong>时间复杂度</strong></dt>
<dd>O(N) ， N 为已连接的客户端数量。</dd>
<dt><strong>返回值</strong></dt>
<dd>当指定的客户端存在，且被成功关闭时，返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 列出所有已连接客户端

redis 127.0.0.1:6379&gt; CLIENT LIST
addr=127.0.0.1:43501 fd=5 age=10 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client

# 杀死当前客户端的连接

redis 127.0.0.1:6379&gt; CLIENT KILL 127.0.0.1:43501
OK

# 之前的连接已经被关闭，CLI 客户端又重新建立了连接
# 之前的端口是 43501 ，现在是 43504

redis 127.0.0.1:6379&gt; CLIENT LIST
addr=127.0.0.1:43504 fd=5 age=0 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client
</pre></div>
</div>
</div>
<span id="document-server/client_list"></span><div class="section" id="client-list">
<span id="id1"></span><h4>CLIENT LIST<a class="headerlink" href="#client-list" title="Permalink to this headline">¶</a></h4>
<p><strong>CLIENT LIST</strong></p>
<p>以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; CLIENT LIST
addr=127.0.0.1:43143 fd=6 age=183 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client
addr=127.0.0.1:43163 fd=5 age=35 idle=15 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping
addr=127.0.0.1:43167 fd=7 age=24 idle=6 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=get
</pre></div>
</div>
<dl class="docutils">
<dt><strong>可用版本</strong></dt>
<dd>&gt;= 2.4.0</dd>
<dt><strong>时间复杂度</strong></dt>
<dd>O(N) ， N 为连接到服务器的客户端数量。</dd>
<dt><strong>返回值</strong></dt>
<dd><p class="first">命令返回多行字符串，这些字符串按以下形式被格式化：</p>
<ul class="simple">
<li>每个已连接客户端对应一行（以 <tt class="docutils literal"><span class="pre">LF</span></tt> 分割）</li>
<li>每行字符串由一系列 <tt class="docutils literal"><span class="pre">属性=值</span></tt> 形式的域组成，每个域之间以空格分开</li>
</ul>
<p>以下是域的含义：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">addr</span></tt> ： 客户端的地址和端口</li>
<li><tt class="docutils literal"><span class="pre">fd</span></tt> ： 套接字所使用的文件描述符</li>
<li><tt class="docutils literal"><span class="pre">age</span></tt> ： 以秒计算的已连接时长</li>
<li><tt class="docutils literal"><span class="pre">idle</span></tt> ： 以秒计算的空闲时长</li>
<li><tt class="docutils literal"><span class="pre">flags</span></tt> ： 客户端 flag （见下文）</li>
<li><tt class="docutils literal"><span class="pre">db</span></tt> ： 该客户端正在使用的数据库 ID</li>
<li><tt class="docutils literal"><span class="pre">sub</span></tt> ： 已订阅频道的数量</li>
<li><tt class="docutils literal"><span class="pre">psub</span></tt> ： 已订阅模式的数量</li>
<li><tt class="docutils literal"><span class="pre">multi</span></tt> ： 在事务中被执行的命令数量</li>
<li><tt class="docutils literal"><span class="pre">qbuf</span></tt> ： 查询缓冲区的长度（字节为单位， <tt class="docutils literal"><span class="pre">0</span></tt> 表示没有分配查询缓冲区）</li>
<li><tt class="docutils literal"><span class="pre">qbuf-free</span></tt> ： 查询缓冲区剩余空间的长度（字节为单位， <tt class="docutils literal"><span class="pre">0</span></tt> 表示没有剩余空间）</li>
<li><tt class="docutils literal"><span class="pre">obl</span></tt> ： 输出缓冲区的长度（字节为单位， <tt class="docutils literal"><span class="pre">0</span></tt> 表示没有分配输出缓冲区）</li>
<li><tt class="docutils literal"><span class="pre">oll</span></tt> ： 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）</li>
<li><tt class="docutils literal"><span class="pre">omem</span></tt> ： 输出缓冲区和输出列表占用的内存总量</li>
<li><tt class="docutils literal"><span class="pre">events</span></tt> ： 文件描述符事件（见下文）</li>
<li><tt class="docutils literal"><span class="pre">cmd</span></tt> ： 最近一次执行的命令</li>
</ul>
<p>客户端 flag 可以由以下部分组成：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">O</span></tt> ： 客户端是 MONITOR 模式下的附属节点（slave）</li>
<li><tt class="docutils literal"><span class="pre">S</span></tt> ： 客户端是一般模式下（normal）的附属节点</li>
<li><tt class="docutils literal"><span class="pre">M</span></tt> ： 客户端是主节点（master）</li>
<li><tt class="docutils literal"><span class="pre">x</span></tt> ： 客户端正在执行事务</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt> ： 客户端正在等待阻塞事件</li>
<li><tt class="docutils literal"><span class="pre">i</span></tt> ： 客户端正在等待 VM I/O 操作（已废弃）</li>
<li><tt class="docutils literal"><span class="pre">d</span></tt> ： 一个受监视（watched）的键已被修改， <tt class="docutils literal"><span class="pre">EXEC</span></tt> 命令将失败</li>
<li><tt class="docutils literal"><span class="pre">c</span></tt> : 在将回复完整地写出之后，关闭链接</li>
<li><tt class="docutils literal"><span class="pre">u</span></tt> : 客户端未被阻塞（unblocked）</li>
<li><tt class="docutils literal"><span class="pre">A</span></tt> : 尽可能快地关闭连接</li>
<li><tt class="docutils literal"><span class="pre">N</span></tt> : 未设置任何 flag</li>
</ul>
<p>文件描述符事件可以是：</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">r</span></tt> : 客户端套接字（在事件 loop 中）是可读的（readable）</li>
<li><tt class="docutils literal"><span class="pre">w</span></tt> : 客户端套接字（在事件 loop 中）是可写的（writeable）</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 <tt class="docutils literal"><span class="pre">CLIENT</span> <span class="pre">LIST</span></tt> 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。</p>
</div>
</div>
<span id="document-server/client_setname"></span><div class="section" id="client-setname">
<span id="id1"></span><h4>CLIENT SETNAME<a class="headerlink" href="#client-setname" title="Permalink to this headline">¶</a></h4>
<p><strong>CLIENT SETNAME connection-name</strong></p>
<p>为当前连接分配一个名字。</p>
<p>这个名字会显示在 <a class="reference internal" href="index.html#client-list"><em>CLIENT LIST</em></a> 命令的结果中，
用于识别当前正在与服务器进行连接的客户端。</p>
<p>举个例子，
在使用 Redis 构建队列（queue）时，
可以根据连接负责的任务（role），
为信息生产者（producer）和信息消费者（consumer）分别设置不同的名字。</p>
<p>名字使用 Redis 的字符串类型来保存，
最大可以占用 512 MB 。
另外，
为了避免和 <a class="reference internal" href="index.html#client-list"><em>CLIENT LIST</em></a> 命令的输出格式发生冲突，
名字里不允许使用空格。</p>
<p>要移除一个连接的名字，
可以将连接的名字设为空字符串 <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> 。</p>
<p>使用 <a class="reference internal" href="index.html#client-getname"><em>CLIENT GETNAME</em></a> 命令可以取出连接的名字。</p>
<p>新创建的连接默认是没有名字的。</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本</strong></dt>
<dd>&gt;= 2.6.9</dd>
<dt><strong>时间复杂度</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值</strong></dt>
<dd>设置成功时返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 新连接默认没有名字

redis 127.0.0.1:6379&gt; CLIENT GETNAME
(nil)

# 设置名字

redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection
OK

# 返回名字

redis 127.0.0.1:6379&gt; CLIENT GETNAME
&quot;hello-world-connection&quot;

# 在客户端列表中查看

redis 127.0.0.1:6379&gt; CLIENT LIST
addr=127.0.0.1:36851
fd=5
name=hello-world-connection     # &lt;- 名字
age=51
...

# 清除名字

redis 127.0.0.1:6379&gt; CLIENT SETNAME        # 只用空格是不行的！
(error) ERR Syntax error, try CLIENT (LIST | KILL ip:port)

redis 127.0.0.1:6379&gt; CLIENT SETNAME &quot;&quot;     # 必须双引号显示包围
OK

redis 127.0.0.1:6379&gt; CLIENT GETNAME        # 清除完毕
(nil)
</pre></div>
</div>
</div>
<span id="document-server/config_get"></span><div class="section" id="config-get">
<span id="id1"></span><h4>CONFIG GET<a class="headerlink" href="#config-get" title="Permalink to this headline">¶</a></h4>
<p><strong>CONFIG GET parameter</strong></p>
<p><a class="reference internal" href="#id1">CONFIG GET</a> 命令用于取得运行中的 Redis 服务器的配置参数(configuration parameters)，在 Redis 2.4 版本中， 有部分参数没有办法用 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span></tt> 访问，但是在最新的 Redis 2.6 版本中，所有配置参数都已经可以用 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span></tt> 访问了。</p>
<p><a class="reference internal" href="#id1">CONFIG GET</a> 接受单个参数 <tt class="docutils literal"><span class="pre">parameter</span></tt> 作为搜索关键字，查找所有匹配的配置参数，其中参数和值以“键-值对”(key-value pairs)的方式排列。</p>
<p>比如执行 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span> <span class="pre">s*</span></tt> 命令，服务器就会返回所有以 <tt class="docutils literal"><span class="pre">s</span></tt> 开头的配置参数及参数的值：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; CONFIG GET s*
1) &quot;save&quot;                       # 参数名：save
2) &quot;900 1 300 10 60 10000&quot;      # save 参数的值
3) &quot;slave-serve-stale-data&quot;     # 参数名： slave-serve-stale-data
4) &quot;yes&quot;                        # slave-serve-stale-data 参数的值
5) &quot;set-max-intset-entries&quot;     # ...
6) &quot;512&quot;
7) &quot;slowlog-log-slower-than&quot;
8) &quot;1000&quot;
9) &quot;slowlog-max-len&quot;
10) &quot;1000&quot;
</pre></div>
</div>
<p>如果你只是寻找特定的某个参数的话，你当然也可以直接指定参数的名字：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; CONFIG GET slowlog-max-len
1) &quot;slowlog-max-len&quot;
2) &quot;1000&quot;
</pre></div>
</div>
<p>使用命令 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span> <span class="pre">*</span></tt> ，可以列出 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span></tt> 命令支持的所有参数：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; CONFIG GET *
1) &quot;dir&quot;
2) &quot;/var/lib/redis&quot;
3) &quot;dbfilename&quot;
4) &quot;dump.rdb&quot;
5) &quot;requirepass&quot;
6) (nil)
7) &quot;masterauth&quot;
8) (nil)
9) &quot;maxmemory&quot;
10) &quot;0&quot;
11) &quot;maxmemory-policy&quot;
12) &quot;volatile-lru&quot;
13) &quot;maxmemory-samples&quot;
14) &quot;3&quot;
15) &quot;timeout&quot;
16) &quot;0&quot;
17) &quot;appendonly&quot;
18) &quot;no&quot;
# ...
49) &quot;loglevel&quot;
50) &quot;verbose&quot;
</pre></div>
</div>
<p>所有被 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span></tt> 所支持的配置参数都可以在配置文件 redis.conf 中找到，不过 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span></tt> 和 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span></tt> 使用的格式和 redis.conf 文件所使用的格式有以下两点不同：</p>
<ul>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">10kb</span></tt> 、 <tt class="docutils literal"><span class="pre">2gb</span></tt> 这些在配置文件中所使用的储存单位缩写，不可以用在 <tt class="docutils literal"><span class="pre">CONFIG</span></tt> 命令中， <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span></tt> 的值只能通过数字值显式地设定。</div>
<div class="line"><br /></div>
<div class="line">像 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span> <span class="pre">xxx</span> <span class="pre">1k</span></tt> 这样的命令是错误的，正确的格式是 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span> <span class="pre">xxx</span> <span class="pre">1000</span></tt> 。</div>
</div>
</li>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">save</span></tt> 选项在 redis.conf 中是用多行文字储存的，但在 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span></tt> 命令中，它只打印一行文字。</div>
<div class="line"><br /></div>
<div class="line">以下是 <tt class="docutils literal"><span class="pre">save</span></tt> 选项在 redis.conf 文件中的表示：</div>
<div class="line"><br /></div>
<div class="line"><tt class="docutils literal"><span class="pre">save</span> <span class="pre">900</span> <span class="pre">1</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">save</span> <span class="pre">300</span> <span class="pre">10</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">save</span> <span class="pre">60</span> <span class="pre">10000</span></tt></div>
<div class="line"><br /></div>
<div class="line">但是 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span></tt> 命令的输出只有一行：</div>
<div class="line"><br /></div>
<div class="line"><tt class="docutils literal"><span class="pre">redis&gt;</span> <span class="pre">CONFIG</span> <span class="pre">GET</span> <span class="pre">save</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">1)</span> <span class="pre">&quot;save&quot;</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">2)</span> <span class="pre">&quot;900</span> <span class="pre">1</span> <span class="pre">300</span> <span class="pre">10</span> <span class="pre">60</span> <span class="pre">10000&quot;</span></tt></div>
<div class="line"><br /></div>
<div class="line">上面 <tt class="docutils literal"><span class="pre">save</span></tt> 参数的三个值表示：在 900 秒内最少有 1 个 key 被改动，或者 300 秒内最少有 10 个 key 被改动，又或者 60 秒内最少有 1000 个 key 被改动，以上三个条件随便满足一个，就触发一次保存操作。</div>
</div>
</li>
</ul>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>不明确</dd>
<dt><strong>返回值：</strong></dt>
<dd>给定配置参数的值。</dd>
</dl>
</div>
<span id="document-server/config_resetstat"></span><div class="section" id="config-resetstat">
<span id="id1"></span><h4>CONFIG RESETSTAT<a class="headerlink" href="#config-resetstat" title="Permalink to this headline">¶</a></h4>
<p><strong>CONFIG RESETSTAT</strong></p>
<p>重置 <a class="reference internal" href="index.html#info"><em>INFO</em></a> 命令中的某些统计数据，包括：</p>
<ul class="simple">
<li>Keyspace hits (键空间命中次数)</li>
<li>Keyspace misses (键空间不命中次数)</li>
<li>Number of commands processed (执行命令的次数)</li>
<li>Number of connections received (连接服务器的次数)</li>
<li>Number of expired keys (过期key的数量)</li>
<li>Number of rejected connections (被拒绝的连接数量)</li>
<li>Latest fork(2) time(最后执行 fork(2) 的时间)</li>
<li>The <tt class="docutils literal"><span class="pre">aof_delayed_fsync</span></tt> counter(<tt class="docutils literal"><span class="pre">aof_delayed_fsync</span></tt> 计数器的值)</li>
</ul>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre># 重置前

redis 127.0.0.1:6379&gt; INFO
# Server
redis_version:2.5.3
redis_git_sha1:d0407c2d
redis_git_dirty:0
arch_bits:32
multiplexing_api:epoll
gcc_version:4.6.3
process_id:11095
run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2
tcp_port:6379
uptime_in_seconds:6
uptime_in_days:0
lru_clock:1205426

# Clients
connected_clients:1
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0

# Memory
used_memory:331076
used_memory_human:323.32K
used_memory_rss:1568768
used_memory_peak:293424
used_memory_peak_human:286.55K
used_memory_lua:16384
mem_fragmentation_ratio:4.74
mem_allocator:jemalloc-2.2.5

# Persistence
loading:0
aof_enabled:0
changes_since_last_save:0
bgsave_in_progress:0
last_save_time:1333260015
last_bgsave_status:ok
bgrewriteaof_in_progress:0

# Stats
total_connections_received:1
total_commands_processed:0
instantaneous_ops_per_sec:0
rejected_connections:0
expired_keys:0
evicted_keys:0
keyspace_hits:0
keyspace_misses:0
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:0

# Replication
role:master
connected_slaves:0

# CPU
used_cpu_sys:0.01
used_cpu_user:0.00
used_cpu_sys_children:0.00
used_cpu_user_children:0.00

# Keyspace
db0:keys=20,expires=0


# 重置

redis 127.0.0.1:6379&gt; CONFIG RESETSTAT
OK


# 重置后

redis 127.0.0.1:6379&gt; INFO
# Server
redis_version:2.5.3
redis_git_sha1:d0407c2d
redis_git_dirty:0
arch_bits:32
multiplexing_api:epoll
gcc_version:4.6.3
process_id:11095
run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2
tcp_port:6379
uptime_in_seconds:134
uptime_in_days:0
lru_clock:1205438

# Clients
connected_clients:1
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0

# Memory
used_memory:331076
used_memory_human:323.32K
used_memory_rss:1568768
used_memory_peak:330280
used_memory_peak_human:322.54K
used_memory_lua:16384
mem_fragmentation_ratio:4.74
mem_allocator:jemalloc-2.2.5

# Persistence
loading:0
aof_enabled:0
changes_since_last_save:0
bgsave_in_progress:0
last_save_time:1333260015
last_bgsave_status:ok
bgrewriteaof_in_progress:0

# Stats
total_connections_received:0
total_commands_processed:1
instantaneous_ops_per_sec:0
rejected_connections:0
expired_keys:0
evicted_keys:0
keyspace_hits:0
keyspace_misses:0
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:0

# Replication
role:master
connected_slaves:0

# CPU
used_cpu_sys:0.05
used_cpu_user:0.02
used_cpu_sys_children:0.00
used_cpu_user_children:0.00

# Keyspace
db0:keys=20,expires=0
</pre></div>
</div>
</div>
<span id="document-server/config_rewrite"></span><div class="section" id="config-rewrite">
<span id="id1"></span><h4>CONFIG REWRITE<a class="headerlink" href="#config-rewrite" title="Permalink to this headline">¶</a></h4>
<p><strong>CONFIG REWRITE</strong></p>
<p><a class="reference internal" href="index.html#config-rewrite"><em>CONFIG REWRITE</em></a> 命令对启动 Redis 服务器时所指定的 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件进行改写：
因为 <a class="reference internal" href="index.html#config-set"><em>CONFIG SET</em></a> 命令可以对服务器的当前配置进行修改，
而修改后的配置可能和 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中所描述的配置不一样，
<a class="reference internal" href="index.html#config-rewrite"><em>CONFIG REWRITE</em></a> 的作用就是通过尽可能少的修改，
将服务器当前所使用的配置记录到 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中。</p>
<p>重写会以非常保守的方式进行：</p>
<ul class="simple">
<li>原有 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件的整体结构和注释会被尽可能地保留。</li>
<li>如果一个选项已经存在于原有 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中 ，
那么对该选项的重写会在选项原本所在的位置（行号）上进行。</li>
<li>如果一个选项不存在于原有 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中，
并且该选项被设置为默认值，
那么重写程序不会将这个选项添加到重写后的 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中。</li>
<li>如果一个选项不存在于原有 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中，
并且该选项被设置为非默认值，
那么这个选项将被添加到重写后的 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件的末尾。</li>
<li>未使用的行会被留白。
比如说，
如果你在原有 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件上设置了数个关于 <tt class="docutils literal"><span class="pre">save</span></tt> 选项的参数，
但现在你将这些 <tt class="docutils literal"><span class="pre">save</span></tt> 参数的一个或全部都关闭了，
那么这些不再使用的参数原本所在的行就会变成空白的。</li>
</ul>
<p>即使启动服务器时所指定的 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件已经不再存在，
<a class="reference internal" href="index.html#config-rewrite"><em>CONFIG REWRITE</em></a> 命令也可以重新构建并生成出一个新的 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件。</p>
<p>另一方面，
如果启动服务器时没有载入 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件，
那么执行 <a class="reference internal" href="index.html#config-rewrite"><em>CONFIG REWRITE</em></a> 命令将引发一个错误。</p>
<div class="section" id="id2">
<h5>原子性重写<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>对 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件的重写是原子性的，
并且是一致的：
如果重写出错或重写期间服务器崩溃，
那么重写失败，
原有 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件不会被修改。
如果重写成功，
那么 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件为重写后的新文件。</p>
</div>
<div class="section" id="id3">
<h5>可用版本<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>&gt;= 2.8.0</p>
</div>
<div class="section" id="id4">
<h5>返回值<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>一个状态值：如果配置重写成功则返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，失败则返回一个错误。</p>
</div>
<div class="section" id="id5">
<h5>测试<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>以下是执行 <a class="reference internal" href="index.html#config-rewrite"><em>CONFIG REWRITE</em></a> 前，
被载入到 Redis 服务器的 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中关于 <tt class="docutils literal"><span class="pre">appendonly</span></tt> 选项的设置：</p>
<div class="highlight-python"><div class="highlight"><pre># ... 其他选项

appendonly no

# ... 其他选项
</pre></div>
</div>
<p>在执行以下命令之后：</p>
<div class="highlight-python"><div class="highlight"><pre>127.0.0.1:6379&gt; CONFIG GET appendonly           # appendonly 处于关闭状态
1) &quot;appendonly&quot;
2) &quot;no&quot;

127.0.0.1:6379&gt; CONFIG SET appendonly yes       # 打开 appendonly
OK

127.0.0.1:6379&gt; CONFIG GET appendonly
1) &quot;appendonly&quot;
2) &quot;yes&quot;

127.0.0.1:6379&gt; CONFIG REWRITE                  # 将 appendonly 的修改写入到 redis.conf 中
OK
</pre></div>
</div>
<p>重写后的 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中的 <tt class="docutils literal"><span class="pre">appendonly</span></tt> 选项将被改写：</p>
<div class="highlight-python"><div class="highlight"><pre># ... 其他选项

appendonly yes

# ... 其他选项
</pre></div>
</div>
</div>
</div>
<span id="document-server/config_set"></span><div class="section" id="config-set">
<span id="id1"></span><h4>CONFIG SET<a class="headerlink" href="#config-set" title="Permalink to this headline">¶</a></h4>
<p><strong>CONFIG SET parameter value</strong></p>
<p><a class="reference internal" href="#id1">CONFIG SET</a> 命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启。</p>
<p>你可以使用它修改配置参数，或者改变 Redis 的持久化(Persistence)方式。</p>
<p><a class="reference internal" href="#id1">CONFIG SET</a> 可以修改的配置参数可以使用命令 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span> <span class="pre">*</span></tt> 来列出，所有被 <a class="reference internal" href="#id1">CONFIG SET</a> 修改的配置参数都会立即生效。</p>
<p>关于 <a class="reference internal" href="#id1">CONFIG SET</a> 命令的更多消息，请参见命令 <a class="reference internal" href="index.html#config-get"><em>CONFIG GET</em></a> 的说明。</p>
<p>关于如何使用 <a class="reference internal" href="#id1">CONFIG SET</a> 命令修改 Redis 持久化方式，请参见 <a class="reference external" href="http://redis.io/topics/persistence">Redis Persistence</a> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>不明确</dd>
<dt><strong>返回值：</strong></dt>
<dd>当设置成功时返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，否则返回一个错误。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; CONFIG GET slowlog-max-len
1) &quot;slowlog-max-len&quot;
2) &quot;1024&quot;

redis&gt; CONFIG SET slowlog-max-len 10086
OK

redis&gt; CONFIG GET slowlog-max-len
1) &quot;slowlog-max-len&quot;
2) &quot;10086&quot;
</pre></div>
</div>
</div>
<span id="document-server/dbsize"></span><div class="section" id="dbsize">
<span id="id1"></span><h4>DBSIZE<a class="headerlink" href="#dbsize" title="Permalink to this headline">¶</a></h4>
<p><strong>DBSIZE</strong></p>
<p>返回当前数据库的 key 的数量。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>当前数据库的 key 的数量。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; DBSIZE
(integer) 5

redis&gt; SET new_key &quot;hello_moto&quot;     # 增加一个 key 试试
OK

redis&gt; DBSIZE
(integer) 6
</pre></div>
</div>
</div>
<span id="document-server/debug_object"></span><div class="section" id="debug-object">
<span id="id1"></span><h4>DEBUG OBJECT<a class="headerlink" href="#debug-object" title="Permalink to this headline">¶</a></h4>
<p><strong>DEBUG OBJECT key</strong></p>
<p><a class="reference internal" href="#id1">DEBUG OBJECT</a> 是一个调试命令，它不应被客户端所使用。</p>
<p>查看 <a class="reference internal" href="index.html#object"><em>OBJECT</em></a> 命令获取更多信息。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 存在时，返回有关信息。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">key</span></tt> 不存在时，返回一个错误。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; DEBUG OBJECT my_pc
Value at:0xb6838d20 refcount:1 encoding:raw serializedlength:9 lru:283790 lru_seconds_idle:150

redis&gt; DEBUG OBJECT your_mac
(error) ERR no such key
</pre></div>
</div>
</div>
<span id="document-server/debug_segfault"></span><div class="section" id="debug-segfault">
<span id="id1"></span><h4>DEBUG SEGFAULT<a class="headerlink" href="#debug-segfault" title="Permalink to this headline">¶</a></h4>
<p><strong>DEBUG SEGFAULT</strong></p>
<p>执行一个不合法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 模拟。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>不明确</dd>
<dt><strong>返回值：</strong></dt>
<dd>无</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; DEBUG SEGFAULT
Could not connect to Redis at: Connection refused

not connected&gt;
</pre></div>
</div>
</div>
<span id="document-server/flushall"></span><div class="section" id="flushall">
<span id="id1"></span><h4>FLUSHALL<a class="headerlink" href="#flushall" title="Permalink to this headline">¶</a></h4>
<p><strong>FLUSHALL</strong></p>
<p>清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。</p>
<p>此命令从不失败。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>尚未明确</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; DBSIZE            # 0 号数据库的 key 数量
(integer) 9

redis&gt; SELECT 1          # 切换到 1 号数据库
OK

redis[1]&gt; DBSIZE         # 1 号数据库的 key 数量
(integer) 6

redis[1]&gt; flushall       # 清空所有数据库的所有 key
OK

redis[1]&gt; DBSIZE         # 不但 1 号数据库被清空了
(integer) 0

redis[1]&gt; SELECT 0       # 0 号数据库(以及其他所有数据库)也一样
OK

redis&gt; DBSIZE
(integer) 0
</pre></div>
</div>
</div>
<span id="document-server/flushdb"></span><div class="section" id="flushdb">
<span id="id1"></span><h4>FLUSHDB<a class="headerlink" href="#flushdb" title="Permalink to this headline">¶</a></h4>
<p><strong>FLUSHDB</strong></p>
<p>清空当前数据库中的所有 key。</p>
<p>此命令从不失败。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; DBSIZE    # 清空前的 key 数量
(integer) 4

redis&gt; FLUSHDB
OK

redis&gt; DBSIZE    # 清空后的 key 数量
(integer) 0
</pre></div>
</div>
</div>
<span id="document-server/info"></span><div class="section" id="info">
<span id="id1"></span><h4>INFO<a class="headerlink" href="#info" title="Permalink to this headline">¶</a></h4>
<p><strong>INFO [section]</strong></p>
<p>以一种易于解释（parse）且易于阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。</p>
<p>通过给定可选的参数 <tt class="docutils literal"><span class="pre">section</span></tt> ，可以让命令只返回某一部分的信息：</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">server</span></tt> : 一般 Redis 服务器信息，包含以下域：</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">redis_version</span></tt> : Redis 服务器版本</li>
<li><tt class="docutils literal"><span class="pre">redis_git_sha1</span></tt> : Git SHA1</li>
<li><tt class="docutils literal"><span class="pre">redis_git_dirty</span></tt> : Git dirty flag</li>
<li><tt class="docutils literal"><span class="pre">os</span></tt> : Redis 服务器的宿主操作系统</li>
<li><tt class="docutils literal"><span class="pre">arch_bits</span></tt> : 架构（32 或 64 位）</li>
<li><tt class="docutils literal"><span class="pre">multiplexing_api</span></tt> : Redis 所使用的事件处理机制</li>
<li><tt class="docutils literal"><span class="pre">gcc_version</span></tt> : 编译 Redis 时所使用的 GCC 版本</li>
<li><tt class="docutils literal"><span class="pre">process_id</span></tt> : 服务器进程的 PID</li>
<li><tt class="docutils literal"><span class="pre">run_id</span></tt> : Redis 服务器的随机标识符（用于 Sentinel 和集群）</li>
<li><tt class="docutils literal"><span class="pre">tcp_port</span></tt> : TCP/IP 监听端口</li>
<li><tt class="docutils literal"><span class="pre">uptime_in_seconds</span></tt> : 自 Redis 服务器启动以来，经过的秒数</li>
<li><tt class="docutils literal"><span class="pre">uptime_in_days</span></tt> : 自 Redis 服务器启动以来，经过的天数</li>
<li><tt class="docutils literal"><span class="pre">lru_clock</span></tt> : 以分钟为单位进行自增的时钟，用于 LRU 管理</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">clients</span></tt> : 已连接客户端信息，包含以下域：</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">connected_clients</span></tt> : 已连接客户端的数量（不包括通过从属服务器连接的客户端）</li>
<li><tt class="docutils literal"><span class="pre">client_longest_output_list</span></tt> : 当前连接的客户端当中，最长的输出列表</li>
<li><tt class="docutils literal"><span class="pre">client_longest_input_buf</span></tt> : 当前连接的客户端当中，最大输入缓存</li>
<li><tt class="docutils literal"><span class="pre">blocked_clients</span></tt> : 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">memory</span></tt> : 内存信息，包含以下域：</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">used_memory</span></tt> : 由 Redis 分配器分配的内存总量，以字节（byte）为单位</li>
<li><tt class="docutils literal"><span class="pre">used_memory_human</span></tt> : 以人类可读的格式返回 Redis 分配的内存总量</li>
<li><tt class="docutils literal"><span class="pre">used_memory_rss</span></tt> : 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 <tt class="docutils literal"><span class="pre">top</span></tt> 、 <tt class="docutils literal"><span class="pre">ps</span></tt> 等命令的输出一致。</li>
<li><tt class="docutils literal"><span class="pre">used_memory_peak</span></tt> : Redis 的内存消耗峰值（以字节为单位）</li>
<li><tt class="docutils literal"><span class="pre">used_memory_peak_human</span></tt> : 以人类可读的格式返回 Redis 的内存消耗峰值</li>
<li><tt class="docutils literal"><span class="pre">used_memory_lua</span></tt> : Lua 引擎所使用的内存大小（以字节为单位）</li>
<li><tt class="docutils literal"><span class="pre">mem_fragmentation_ratio</span></tt> : <tt class="docutils literal"><span class="pre">used_memory_rss</span></tt> 和 <tt class="docutils literal"><span class="pre">used_memory</span></tt> 之间的比率</li>
<li><tt class="docutils literal"><span class="pre">mem_allocator</span></tt> : 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。</li>
</ul>
<div class="line-block">
<div class="line">在理想情况下， <tt class="docutils literal"><span class="pre">used_memory_rss</span></tt> 的值应该只比 <tt class="docutils literal"><span class="pre">used_memory</span></tt> 稍微高一点儿。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">rss</span> <span class="pre">&gt;</span> <span class="pre">used</span></tt> ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。</div>
<div class="line">内存碎片的比率可以通过 <tt class="docutils literal"><span class="pre">mem_fragmentation_ratio</span></tt> 的值看出。</div>
<div class="line">当 <tt class="docutils literal"><span class="pre">used</span> <span class="pre">&gt;</span> <span class="pre">rss</span></tt> 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。</div>
</div>
<p>Because Redis does not have control over how its allocations are mapped to memory pages, high <tt class="docutils literal"><span class="pre">used_memory_rss</span></tt> is often the result of a spike in memory usage.</p>
<div class="line-block">
<div class="line">当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。</div>
<div class="line">如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 <tt class="docutils literal"><span class="pre">used_memory</span></tt> 的值可能和操作系统显示的 Redis 内存占用并不一致。</div>
<div class="line">查看 <tt class="docutils literal"><span class="pre">used_memory_peak</span></tt> 的值可以验证这种情况是否发生。</div>
</div>
</div></blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">persistence</span></tt> : <tt class="docutils literal"><span class="pre">RDB</span></tt> 和 <tt class="docutils literal"><span class="pre">AOF</span></tt> 的相关信息</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">stats</span></tt> : 一般统计信息</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">replication</span></tt> : 主/从复制信息</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">cpu</span></tt> : CPU 计算量统计信息</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">commandstats</span></tt> : Redis 命令统计信息</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">cluster</span></tt> : Redis 集群信息</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">keyspace</span></tt> : 数据库相关的统计信息</p>
</li>
</ul>
<p>除上面给出的这些值以外，参数还可以是下面这两个：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">all</span></tt> : 返回所有信息</li>
<li><tt class="docutils literal"><span class="pre">default</span></tt> : 返回默认选择的信息</li>
</ul>
<p>当不带参数直接调用 <a class="reference internal" href="#info">INFO</a> 命令时，使用 <tt class="docutils literal"><span class="pre">default</span></tt> 作为默认参数。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>不同版本的 Redis 可能对返回的一些域进行了增加或删减。</p>
<p class="last">因此，一个健壮的客户端程序在对 <a class="reference internal" href="index.html#info"><em>INFO</em></a> 命令的输出进行分析时，应该能够跳过不认识的域，并且妥善地处理丢失不见的域。</p>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>具体请参见下面的测试代码。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; INFO
# Server
redis_version:2.5.9
redis_git_sha1:473f3090
redis_git_dirty:0
os:Linux 3.3.7-1-ARCH i686
arch_bits:32
multiplexing_api:epoll
gcc_version:4.7.0
process_id:8104
run_id:bc9e20c6f0aac67d0d396ab950940ae4d1479ad1
tcp_port:6379
uptime_in_seconds:7
uptime_in_days:0
lru_clock:1680564

# Clients
connected_clients:1
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0

# Memory
used_memory:439304
used_memory_human:429.01K
used_memory_rss:13897728
used_memory_peak:401776
used_memory_peak_human:392.36K
used_memory_lua:20480
mem_fragmentation_ratio:31.64
mem_allocator:jemalloc-3.0.0

# Persistence
loading:0
rdb_changes_since_last_save:0
rdb_bgsave_in_progress:0
rdb_last_save_time:1338011402
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:-1
rdb_current_bgsave_time_sec:-1
aof_enabled:0
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:-1
aof_current_rewrite_time_sec:-1

# Stats
total_connections_received:1
total_commands_processed:0
instantaneous_ops_per_sec:0
rejected_connections:0
expired_keys:0
evicted_keys:0
keyspace_hits:0
keyspace_misses:0
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:0

# Replication
role:master
connected_slaves:0

# CPU
used_cpu_sys:0.03
used_cpu_user:0.01
used_cpu_sys_children:0.00
used_cpu_user_children:0.00

# Keyspace
</pre></div>
</div>
</div>
<span id="document-server/lastsave"></span><div class="section" id="lastsave">
<span id="id1"></span><h4>LASTSAVE<a class="headerlink" href="#lastsave" title="Permalink to this headline">¶</a></h4>
<p><strong>LASTSAVE</strong></p>
<p>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>一个 UNIX 时间戳。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; LASTSAVE
(integer) 1324043588
</pre></div>
</div>
</div>
<span id="document-server/monitor"></span><div class="section" id="monitor">
<span id="id1"></span><h4>MONITOR<a class="headerlink" href="#monitor" title="Permalink to this headline">¶</a></h4>
<p><strong>MONITOR</strong></p>
<p>实时打印出 Redis 服务器接收到的命令，调试用。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>不明确</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>127.0.0.1:6379&gt; MONITOR
OK
# 以第一个打印值为例
# 1378822099.421623 是时间戳
# [0 127.0.0.1:56604] 中的 0 是数据库号码， 127... 是 IP 地址和端口
# &quot;PING&quot; 是被执行的命令
1378822099.421623 [0 127.0.0.1:56604] &quot;PING&quot;
1378822105.089572 [0 127.0.0.1:56604] &quot;SET&quot; &quot;msg&quot; &quot;hello world&quot;
1378822109.036925 [0 127.0.0.1:56604] &quot;SET&quot; &quot;number&quot; &quot;123&quot;
1378822140.649496 [0 127.0.0.1:56604] &quot;SADD&quot; &quot;fruits&quot; &quot;Apple&quot; &quot;Banana&quot; &quot;Cherry&quot;
1378822154.117160 [0 127.0.0.1:56604] &quot;EXPIRE&quot; &quot;msg&quot; &quot;10086&quot;
1378822257.329412 [0 127.0.0.1:56604] &quot;KEYS&quot; &quot;*&quot;
1378822258.690131 [0 127.0.0.1:56604] &quot;DBSIZE&quot;
</pre></div>
</div>
</div>
<span id="document-server/psync"></span><div class="section" id="psync">
<span id="id1"></span><h4>PSYNC<a class="headerlink" href="#psync" title="Permalink to this headline">¶</a></h4>
<p><strong>PSYNC &lt;MASTER_RUN_ID&gt; &lt;OFFSET&gt;</strong></p>
<p>用于复制功能(replication)的内部命令。</p>
<p>更多信息请参考 <a class="reference internal" href="index.html#replication-topic"><em>复制（Replication）</em></a> 文档。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.8.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>不明确</dd>
<dt><strong>返回值：</strong></dt>
<dd>不明确</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>127.0.0.1:6379&gt; PSYNC ? -1
&quot;REDIS0006\xfe\x00\x00\x02kk\x02vv\x00\x03msg\x05hello\xff\xc3\x96P\x12h\bK\xef&quot;
</pre></div>
</div>
</div>
<span id="document-server/save"></span><div class="section" id="save">
<span id="id1"></span><h4>SAVE<a class="headerlink" href="#save" title="Permalink to this headline">¶</a></h4>
<p><strong>SAVE</strong></p>
<p><a class="reference internal" href="#save">SAVE</a> 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。</p>
<p>一般来说，在生产环境很少执行 <a class="reference internal" href="#save">SAVE</a> 操作，因为它会阻塞所有客户端，保存数据库的任务通常由 <a class="reference internal" href="index.html#bgsave"><em>BGSAVE</em></a> 命令异步地执行。然而，如果负责保存数据的后台子进程不幸出现问题时， <a class="reference internal" href="#save">SAVE</a> 可以作为保存数据的最后手段来使用。</p>
<p>请参考文档： <a class="reference external" href="http://redis.io/topics/persistence">Redis 的持久化运作方式(英文)</a> 以获取更多消息。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为要保存到数据库中的 key 的数量。</dd>
<dt><strong>返回值：</strong></dt>
<dd>保存成功时返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SAVE</span>
<span class="n">OK</span>
</pre></div>
</div>
</div>
<span id="document-server/shutdown"></span><div class="section" id="shutdown">
<span id="id1"></span><h4>SHUTDOWN<a class="headerlink" href="#shutdown" title="Permalink to this headline">¶</a></h4>
<p><strong>SHUTDOWN</strong></p>
<p><a class="reference internal" href="#shutdown">SHUTDOWN</a> 命令执行以下操作：</p>
<ul class="simple">
<li>停止所有客户端</li>
<li>如果有至少一个保存点在等待，执行 <a class="reference internal" href="index.html#save"><em>SAVE</em></a> 命令</li>
<li>如果 AOF 选项被打开，更新 AOF 文件</li>
<li>关闭 redis 服务器(server)</li>
</ul>
<p>如果持久化被打开的话， <a class="reference internal" href="#shutdown">SHUTDOWN</a> 命令会保证服务器正常关闭而不丢失任何数据。</p>
<p>另一方面，假如只是单纯地执行 <a class="reference internal" href="index.html#save"><em>SAVE</em></a> 命令，然后再执行 <a class="reference internal" href="index.html#quit"><em>QUIT</em></a> 命令，则没有这一保证 —— 因为在执行 <a class="reference internal" href="index.html#save"><em>SAVE</em></a> 之后、执行 <a class="reference internal" href="index.html#quit"><em>QUIT</em></a> 之前的这段时间中间，其他客户端可能正在和服务器进行通讯，这时如果执行 <a class="reference internal" href="index.html#quit"><em>QUIT</em></a> 就会造成数据丢失。</p>
<p><strong>SAVE 和 NOSAVE 修饰符</strong></p>
<p>通过使用可选的修饰符，可以修改 <a class="reference internal" href="#shutdown">SHUTDOWN</a> 命令的表现。比如说：</p>
<ul class="simple">
<li>执行 <tt class="docutils literal"><span class="pre">SHUTDOWN</span> <span class="pre">SAVE</span></tt> 会强制让数据库执行保存操作，即使没有设定(configure)保存点</li>
<li>执行 <tt class="docutils literal"><span class="pre">SHUTDOWN</span> <span class="pre">NOSAVE</span></tt> 会阻止数据库执行保存操作，即使已经设定有一个或多个保存点(你可以将这一用法看作是强制停止服务器的一个假想的 ABORT 命令)</li>
</ul>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>不明确</dd>
<dt><strong>返回值：</strong></dt>
<dd><div class="first last line-block">
<div class="line">执行失败时返回错误。</div>
<div class="line">执行成功时不返回任何信息，服务器和客户端的连接断开，客户端自动退出。</div>
</div>
</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; PING
PONG

redis&gt; SHUTDOWN

$

$ redis
Could not connect to Redis at: Connection refused
not connected&gt;
</pre></div>
</div>
</div>
<span id="document-server/slaveof"></span><div class="section" id="slaveof">
<span id="id1"></span><h4>SLAVEOF<a class="headerlink" href="#slaveof" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt>
<tt class="descname">SLAVEOF host port</tt></dt>
<dd></dd></dl>

<p><a class="reference internal" href="#slaveof">SLAVEOF</a> 命令用于在 Redis 运行时动态地修改复制(replication)功能的行为。</p>
<p>通过执行 <tt class="docutils literal"><span class="pre">SLAVEOF</span> <span class="pre">host</span> <span class="pre">port</span></tt> 命令，可以将当前服务器转变为指定服务器的从属服务器(slave server)。</p>
<p>如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行 <tt class="docutils literal"><span class="pre">SLAVEOF</span> <span class="pre">host</span> <span class="pre">port</span></tt> 将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。</p>
<p>另外，对一个从属服务器执行命令 <tt class="docutils literal"><span class="pre">SLAVEOF</span> <span class="pre">NO</span> <span class="pre">ONE</span></tt> 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集<em>不会</em>被丢弃。</p>
<p>利用『 <tt class="docutils literal"><span class="pre">SLAVEOF</span> <span class="pre">NO</span> <span class="pre">ONE</span></tt> 不会丢弃同步所得数据集』这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">SLAVEOF</span> <span class="pre">host</span> <span class="pre">port</span></tt> ，O(N)， <tt class="docutils literal"><span class="pre">N</span></tt> 为要同步的数据数量。</div>
<div class="line"><tt class="docutils literal"><span class="pre">SLAVEOF</span> <span class="pre">NO</span> <span class="pre">ONE</span></tt> ， O(1) 。</div>
</div>
</dd>
<dt><strong>返回值：</strong></dt>
<dd>总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SLAVEOF 127.0.0.1 6379
OK

redis&gt; SLAVEOF NO ONE
OK
</pre></div>
</div>
</div>
<span id="document-server/slowlog"></span><div class="section" id="slowlog">
<span id="id1"></span><h4>SLOWLOG<a class="headerlink" href="#slowlog" title="Permalink to this headline">¶</a></h4>
<p><strong>SLOWLOG subcommand [argument]</strong></p>
<p><strong>什么是 SLOWLOG</strong></p>
<p>Slow log 是 Redis 用来记录查询执行时间的日志系统。</p>
<p>查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。</p>
<p>另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</p>
<p><strong>设置 SLOWLOG</strong></p>
<p>Slow log 的行为由两个配置参数(configuration parameter)指定，可以通过改写 redis.conf 文件或者用 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span></tt> 和 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span></tt> 命令对它们动态地进行修改。</p>
<p>第一个选项是 <tt class="docutils literal"><span class="pre">slowlog-log-slower-than</span></tt> ，它决定要对执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录。</p>
<p>比如执行以下命令将让 slow log 记录所有查询时间大于等于 100 微秒的查询：</p>
<p><tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span> <span class="pre">slowlog-log-slower-than</span> <span class="pre">100</span></tt></p>
<p>而以下命令记录所有查询时间大于 1000 微秒的查询：</p>
<p><tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span> <span class="pre">slowlog-log-slower-than</span> <span class="pre">1000</span></tt></p>
<p>另一个选项是 <tt class="docutils literal"><span class="pre">slowlog-max-len</span></tt> ，它决定 slow log <em>最多</em>能保存多少条日志， slow log 本身是一个 FIFO 队列，当队列大小超过 <tt class="docutils literal"><span class="pre">slowlog-max-len</span></tt> 时，最旧的一条日志将被删除，而最新的一条日志加入到 slow log ，以此类推。</p>
<p>以下命令让 slow log 最多保存 1000 条日志：</p>
<p><tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span> <span class="pre">slowlog-max-len</span> <span class="pre">1000</span></tt></p>
<p>使用 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">GET</span></tt> 命令可以查询两个选项的当前值：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; CONFIG GET slowlog-log-slower-than
1) &quot;slowlog-log-slower-than&quot;
2) &quot;1000&quot;

redis&gt; CONFIG GET slowlog-max-len
1) &quot;slowlog-max-len&quot;
2) &quot;1000&quot;
</pre></div>
</div>
<p><strong>查看 slow log</strong></p>
<p>要查看 slow log ，可以使用 <tt class="docutils literal"><span class="pre">SLOWLOG</span> <span class="pre">GET</span></tt> 或者 <tt class="docutils literal"><span class="pre">SLOWLOG</span> <span class="pre">GET</span> <span class="pre">number</span></tt> 命令，前者打印所有 slow log ，最大长度取决于 <tt class="docutils literal"><span class="pre">slowlog-max-len</span></tt> 选项的值，而 <tt class="docutils literal"><span class="pre">SLOWLOG</span> <span class="pre">GET</span> <span class="pre">number</span></tt> 则只打印指定数量的日志。</p>
<p>最新的日志会最先被打印：</p>
<div class="highlight-python"><div class="highlight"><pre># 为测试需要，将 slowlog-log-slower-than 设成了 10 微秒

redis&gt; SLOWLOG GET
1) 1) (integer) 12                      # 唯一性(unique)的日志标识符
   2) (integer) 1324097834              # 被记录命令的执行时间点，以 UNIX 时间戳格式表示
   3) (integer) 16                      # 查询执行时间，以微秒为单位
   4) 1) &quot;CONFIG&quot;                       # 执行的命令，以数组的形式排列
      2) &quot;GET&quot;                          # 这里完整的命令是 CONFIG GET slowlog-log-slower-than
      3) &quot;slowlog-log-slower-than&quot;

2) 1) (integer) 11
   2) (integer) 1324097825
   3) (integer) 42
   4) 1) &quot;CONFIG&quot;
      2) &quot;GET&quot;
      3) &quot;*&quot;

3) 1) (integer) 10
   2) (integer) 1324097820
   3) (integer) 11
   4) 1) &quot;CONFIG&quot;
      2) &quot;GET&quot;
      3) &quot;slowlog-log-slower-than&quot;

# ...
</pre></div>
</div>
<p>日志的唯一 id 只有在 Redis 服务器重启的时候才会重置，这样可以避免对日志的重复处理(比如你可能会想在每次发现新的慢查询时发邮件通知你)。</p>
<p><strong>查看当前日志的数量</strong></p>
<p>使用命令 <tt class="docutils literal"><span class="pre">SLOWLOG</span> <span class="pre">LEN</span></tt> 可以查看当前日志的数量。</p>
<p>请注意这个值和 <tt class="docutils literal"><span class="pre">slower-max-len</span></tt> 的区别，它们一个是当前日志的数量，一个是允许记录的最大日志的数量。</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SLOWLOG LEN
(integer) 14
</pre></div>
</div>
<p><strong>清空日志</strong></p>
<p>使用命令 <tt class="docutils literal"><span class="pre">SLOWLOG</span> <span class="pre">RESET</span></tt> 可以清空 slow log 。</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SLOWLOG LEN
(integer) 14

redis&gt; SLOWLOG RESET
OK

redis&gt; SLOWLOG LEN
(integer) 0
</pre></div>
</div>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.2.12</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>取决于不同命令，返回不同的值。</dd>
</dl>
</div>
<span id="document-server/sync"></span><div class="section" id="sync">
<span id="id1"></span><h4>SYNC<a class="headerlink" href="#sync" title="Permalink to this headline">¶</a></h4>
<p><strong>SYNC</strong></p>
<p>用于复制功能(replication)的内部命令。</p>
<p>更多信息请参考 <a class="reference external" href="http://redis.io/topics/replication">Redis 官网的 Replication 章节</a> 。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 1.0.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>不明确</dd>
<dt><strong>返回值：</strong></dt>
<dd>不明确</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SYNC
&quot;REDIS0002\xfe\x00\x00\auser_id\xc0\x03\x00\anumbers\xc2\xf3\xe0\x01\x00\x00\tdb_number\xc0\x00\x00\x04name\x06huangz\x00\anew_key\nhello_moto\x00\bgreeting\nhello moto\x00\x05my_pc\bthinkpad\x00\x04lock\xc0\x01\x00\nlock_times\xc0\x04\xfe\x01\t\x04info\x19\x02\x04name\b\x00zhangyue\x03age\x02\x0022\xff\t\aooredis,\x03\x04name\a\x00ooredis\aversion\x03\x001.0\x06author\x06\x00huangz\xff\x00\tdb_number\xc0\x01\x00\x05greet\x0bhello world\x02\nmy_friends\x02\x05marry\x04jack\x00\x04name\x05value\xfe\x02\x0c\x01s\x12\x12\x00\x00\x00\r\x00\x00\x00\x02\x00\x00\x01a\x03\xc0f&#39;\xff\xff&quot;
(1.90s)
</pre></div>
</div>
</div>
<span id="document-server/time"></span><div class="section" id="time">
<span id="id1"></span><h4>TIME<a class="headerlink" href="#time" title="Permalink to this headline">¶</a></h4>
<p><strong>TIME</strong></p>
<p>返回当前服务器时间。</p>
<dl class="docutils">
<dt><strong>可用版本：</strong></dt>
<dd>&gt;= 2.6.0</dd>
<dt><strong>时间复杂度：</strong></dt>
<dd>O(1)</dd>
<dt><strong>返回值：</strong></dt>
<dd>一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数。</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; TIME
1) &quot;1332395997&quot;
2) &quot;952581&quot;
redis&gt; TIME
1) &quot;1332395997&quot;
2) &quot;953148&quot;
</pre></div>
</div>
</div>
</div>
</div>
</div>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<a class="reference internal image-reference" href="_images/redis-logo.jpg"><img alt="_images/redis-logo.jpg" class="align-left" src="_images/redis-logo.jpg" style="width: 240.0px; height: 135.0px;" /></a>
<p>由本文档翻译者 huangz 主讲的 Redis 课程 —— 《Redis 从入门到精通》现正接受报名： <a class="reference external" href="http://www.chinahadoop.cn/course/53">http://www.chinahadoop.cn/course/53</a> 。</p>
<p class="last">课程的内容由浅入深，
覆盖了 Redis 的应用、配置、管理和运行原理等各个方面，
旨在帮助 Redis 的初、中级使用者全面地了解 Redis ，
欢迎各位踊跃报名。</p>
</div>
</div>
<div class="section" id="id1">
<h2>文档<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>以下文章翻译自 <a class="reference external" href="http://redis.io/documentation">redis.io/documentation</a> 文档。</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="37%" />
<col width="32%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><div class="toctree-wrapper first last compound">
<span id="document-topic/notification"></span><div class="section" id="keyspace-notification">
<h3>键空间通知（keyspace notification）<a class="headerlink" href="#keyspace-notification" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本文档翻译自： <a class="reference external" href="http://redis.io/topics/notifications">http://redis.io/topics/notifications</a> 。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">键空间通知功能目前仍在开发中，这个文档所描述的内容，以及功能的具体实现，可能会在未来数周内改变，敬请知悉。</p>
</div>
<div class="section" id="id1">
<h4>功能概览<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>键空间通知使得客户端可以通过订阅频道或模式，
来接收那些以某种方式改动了 Redis 数据集的事件。</p>
<p>以下是一些键空间通知发送的事件的例子：</p>
<ul class="simple">
<li>所有修改键的命令。</li>
<li>所有接收到 <a class="reference internal" href="index.html#lpush"><em>LPUSH</em></a> 命令的键。</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> 号数据库中所有已过期的键。</li>
</ul>
<p>事件通过 Redis 的订阅与发布功能（pub/sub）来进行分发，
因此所有支持订阅与发布功能的客户端都可以在无须做任何修改的情况下，
直接使用键空间通知功能。</p>
<p>因为 Redis 目前的订阅与发布功能采取的是发送即忘（fire and forget）策略，
所以如果你的程序需要可靠事件通知（reliable notification of events），
那么目前的键空间通知可能并不适合你：
当订阅事件的客户端断线时，
它会丢失所有在断线期间分发给它的事件。</p>
<p>未来将会支持更可靠的事件分发，
这种支持可能会通过让订阅与发布功能本身变得更可靠来实现，
也可能会在 Lua 脚本中对消息（message）的订阅与发布进行监听，
从而实现类似将事件推入到列表这样的操作。</p>
</div>
<div class="section" id="id2">
<h4>事件的类型<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件。</p>
<p>比如说，对 <tt class="docutils literal"><span class="pre">0</span></tt> 号数据库的键 <tt class="docutils literal"><span class="pre">mykey</span></tt> 执行 <a class="reference internal" href="index.html#del"><em>DEL</em></a> 命令时，
系统将分发两条消息，
相当于执行以下两个 <a class="reference internal" href="index.html#publish"><em>PUBLISH</em></a> 命令：</p>
<div class="highlight-python"><div class="highlight"><pre>PUBLISH __keyspace@0__:mykey del
PUBLISH __keyevent@0__:del mykey
</pre></div>
</div>
<p>订阅第一个频道 <tt class="docutils literal"><span class="pre">__keyspace&#64;0__:mykey</span></tt> 可以接收 <tt class="docutils literal"><span class="pre">0</span></tt> 号数据库中所有修改键 <tt class="docutils literal"><span class="pre">mykey</span></tt> 的事件，
而订阅第二个频道 <tt class="docutils literal"><span class="pre">__keyevent&#64;0__:del</span></tt> 则可以接收 <tt class="docutils literal"><span class="pre">0</span></tt> 号数据库中所有执行 <tt class="docutils literal"><span class="pre">del</span></tt> 命令的键。</p>
<p>以 <tt class="docutils literal"><span class="pre">keyspace</span></tt> 为前缀的频道被称为键空间通知（key-space notification），
而以 <tt class="docutils literal"><span class="pre">keyevent</span></tt> 为前缀的频道则被称为键事件通知（key-event notification）。</p>
<p>当 <tt class="docutils literal"><span class="pre">del</span> <span class="pre">mykey</span></tt> 命令执行时：</p>
<ul class="simple">
<li>键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 <tt class="docutils literal"><span class="pre">del</span></tt> 。</li>
<li>键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 <tt class="docutils literal"><span class="pre">mykey</span></tt> 。</li>
</ul>
</div>
<div class="section" id="id3">
<h4>配置<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>因为开启键空间通知功能需要消耗一些 CPU ，
所以在默认配置下，
该功能处于关闭状态。</p>
<p>可以通过修改 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件，
或者直接使用 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span></tt> 命令来开启或关闭键空间通知功能：</p>
<ul class="simple">
<li>当 <tt class="docutils literal"><span class="pre">notify-keyspace-events</span></tt> 选项的参数为空字符串时，功能关闭。</li>
<li>另一方面，当参数不是空字符串时，功能开启。</li>
</ul>
<p><tt class="docutils literal"><span class="pre">notify-keyspace-events</span></tt> 的参数可以是以下字符的任意组合，
它指定了服务器该发送哪些类型的通知：</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">字符</th>
<th class="head">发送的通知</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">K</span></tt></td>
<td>键空间通知，所有通知以 <tt class="docutils literal"><span class="pre">__keyspace&#64;&lt;db&gt;__</span></tt> 为前缀</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">E</span></tt></td>
<td>键事件通知，所有通知以 <tt class="docutils literal"><span class="pre">__keyevent&#64;&lt;db&gt;__</span></tt> 为前缀</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">g</span></tt></td>
<td><tt class="docutils literal"><span class="pre">DEL</span></tt> 、 <tt class="docutils literal"><span class="pre">EXPIRE</span></tt> 、 <tt class="docutils literal"><span class="pre">RENAME</span></tt> 等类型无关的通用命令的通知</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">$</span></tt></td>
<td>字符串命令的通知</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">l</span></tt></td>
<td>列表命令的通知</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">s</span></tt></td>
<td>集合命令的通知</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">h</span></tt></td>
<td>哈希命令的通知</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">z</span></tt></td>
<td>有序集合命令的通知</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">x</span></tt></td>
<td>过期事件：每当有过期键被删除时发送</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">e</span></tt></td>
<td>驱逐(evict)事件：每当有键因为 <tt class="docutils literal"><span class="pre">maxmemory</span></tt> 政策而被删除时发送</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">A</span></tt></td>
<td>参数 <tt class="docutils literal"><span class="pre">g$lshzxe</span></tt> 的别名</td>
</tr>
</tbody>
</table>
<p>输入的参数中至少要有一个 <tt class="docutils literal"><span class="pre">K</span></tt> 或者 <tt class="docutils literal"><span class="pre">E</span></tt> ，
否则的话，
不管其余的参数是什么，
都不会有任何通知被分发。</p>
<p>举个例子，
如果只想订阅键空间中和列表相关的通知，
那么参数就应该设为 <tt class="docutils literal"><span class="pre">Kl</span></tt> ，
诸如此类。</p>
<p>将参数设为字符串 <tt class="docutils literal"><span class="pre">&quot;AKE&quot;</span></tt> 表示发送所有类型的通知。</p>
</div>
<div class="section" id="id4">
<h4>命令产生的通知<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>以下列表记录了不同命令所产生的不同通知：</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#del"><em>DEL</em></a> 命令为每个被删除的键产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#rename"><em>RENAME</em></a> 产生两个通知：为来源键（source key）产生一个 <tt class="docutils literal"><span class="pre">rename_from</span></tt> 通知，并为目标键（destination key）产生一个 <tt class="docutils literal"><span class="pre">rename_to</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 和 <a class="reference internal" href="index.html#expireat"><em>EXPIREAT</em></a> 在键被正确设置过期时间时产生一个 <tt class="docutils literal"><span class="pre">expire</span></tt> 通知。当 <a class="reference internal" href="index.html#expireat"><em>EXPIREAT</em></a> 设置的时间已经过期，或者 <a class="reference internal" href="index.html#expire"><em>EXPIRE</em></a> 传入的时间为负数值时，键被删除，并产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#sort"><em>SORT</em></a> 在命令带有 <tt class="docutils literal"><span class="pre">STORE</span></tt> 参数时产生一个 <tt class="docutils literal"><span class="pre">sortstore</span></tt> 事件。如果 <tt class="docutils literal"><span class="pre">STORE</span></tt> 指示的用于保存排序结果的键已经存在，那么程序还会发送一个 <tt class="docutils literal"><span class="pre">del</span></tt> 事件。</li>
<li><a class="reference internal" href="index.html#set"><em>SET</em></a> 以及它的所有变种（<a class="reference internal" href="index.html#setex"><em>SETEX</em></a> 、 <a class="reference internal" href="index.html#setnx"><em>SETNX</em></a> 和 <a class="reference internal" href="index.html#getset"><em>GETSET</em></a>）都产生 <tt class="docutils literal"><span class="pre">set</span></tt> 通知。其中 <a class="reference internal" href="index.html#setex"><em>SETEX</em></a> 还会产生 <tt class="docutils literal"><span class="pre">expire</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#mset"><em>MSET</em></a> 为每个键产生一个 <tt class="docutils literal"><span class="pre">set</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#setrange"><em>SETRANGE</em></a> 产生一个 <tt class="docutils literal"><span class="pre">setrange</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#incr"><em>INCR</em></a> 、 <a class="reference internal" href="index.html#decr"><em>DECR</em></a> 、 <a class="reference internal" href="index.html#incrby"><em>INCRBY</em></a> 和 <a class="reference internal" href="index.html#decrby"><em>DECRBY</em></a> 都产生 <tt class="docutils literal"><span class="pre">incrby</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#incrbyfloat"><em>INCRBYFLOAT</em></a> 产生 <tt class="docutils literal"><span class="pre">incrbyfloat</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#append"><em>APPEND</em></a> 产生 <tt class="docutils literal"><span class="pre">append</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#lpush"><em>LPUSH</em></a> 和 <a class="reference internal" href="index.html#lpushx"><em>LPUSHX</em></a> 都产生单个 <tt class="docutils literal"><span class="pre">lpush</span></tt> 通知，即使有多个输入元素时，也是如此。</li>
<li><a class="reference internal" href="index.html#rpush"><em>RPUSH</em></a> 和 <a class="reference internal" href="index.html#rpushx"><em>RPUSHX</em></a> 都产生单个 <tt class="docutils literal"><span class="pre">rpush</span></tt> 通知，即使有多个输入元素时，也是如此。</li>
<li><a class="reference internal" href="index.html#rpop"><em>RPOP</em></a> 产生 <tt class="docutils literal"><span class="pre">rpop</span></tt> 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#lpop"><em>LPOP</em></a> 产生 <tt class="docutils literal"><span class="pre">lpop</span></tt> 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#linsert"><em>LINSERT</em></a> 产生一个 <tt class="docutils literal"><span class="pre">linsert</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#lset"><em>LSET</em></a> 产生一个 <tt class="docutils literal"><span class="pre">lset</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#ltrim"><em>LTRIM</em></a> 产生一个 <tt class="docutils literal"><span class="pre">ltrim</span></tt> 通知。如果 <a class="reference internal" href="index.html#ltrim"><em>LTRIM</em></a> 执行之后，列表键被清空，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#rpoplpush"><em>RPOPLPUSH</em></a> 和 <a class="reference internal" href="index.html#brpoplpush"><em>BRPOPLPUSH</em></a> 产生一个 <tt class="docutils literal"><span class="pre">rpop</span></tt> 通知，以及一个 <tt class="docutils literal"><span class="pre">lpush</span></tt> 通知。两个命令都会保证 <tt class="docutils literal"><span class="pre">rpop</span></tt> 的通知在 <tt class="docutils literal"><span class="pre">lpush</span></tt> 的通知之前分发。如果从键弹出元素之后，被弹出的列表键被清空，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#hset"><em>HSET</em></a> 、 <a class="reference internal" href="index.html#hsetnx"><em>HSETNX</em></a> 和 <a class="reference internal" href="index.html#hmset"><em>HMSET</em></a> 都只产生一个 <tt class="docutils literal"><span class="pre">hset</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#hincrby"><em>HINCRBY</em></a> 产生一个 <tt class="docutils literal"><span class="pre">hincrby</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#hincrbyfloat"><em>HINCRBYFLOAT</em></a> 产生一个 <tt class="docutils literal"><span class="pre">hincrbyfloat</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#hdel"><em>HDEL</em></a> 产生一个 <tt class="docutils literal"><span class="pre">hdel</span></tt> 通知。如果执行 <a class="reference internal" href="index.html#hdel"><em>HDEL</em></a> 之后，哈希键被清空，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#sadd"><em>SADD</em></a> 产生一个 <tt class="docutils literal"><span class="pre">sadd</span></tt> 通知，即使有多个输入元素时，也是如此。</li>
<li><a class="reference internal" href="index.html#srem"><em>SREM</em></a> 产生一个 <tt class="docutils literal"><span class="pre">srem</span></tt> 通知，如果执行 <a class="reference internal" href="index.html#srem"><em>SREM</em></a> 之后，集合键被清空，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#smove"><em>SMOVE</em></a> 为来源键（source key）产生一个 <tt class="docutils literal"><span class="pre">srem</span></tt> 通知，并为目标键（destination key）产生一个 <tt class="docutils literal"><span class="pre">sadd</span></tt> 事件。</li>
<li><a class="reference internal" href="index.html#spop"><em>SPOP</em></a> 产生一个 <tt class="docutils literal"><span class="pre">spop</span></tt> 事件。如果执行 <a class="reference internal" href="index.html#spop"><em>SPOP</em></a> 之后，集合键被清空，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#sinterstore"><em>SINTERSTORE</em></a> 、 <a class="reference internal" href="index.html#sunionstore"><em>SUNIONSTORE</em></a> 和 <a class="reference internal" href="index.html#sdiffstore"><em>SDIFFSTORE</em></a> 分别产生 <tt class="docutils literal"><span class="pre">sinterstore</span></tt> 、 <tt class="docutils literal"><span class="pre">sunionostore</span></tt> 和 <tt class="docutils literal"><span class="pre">sdiffstore</span></tt> 三种通知。如果用于保存结果的键已经存在，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#zincrby"><em>ZINCRBY</em></a> 产生一个 <tt class="docutils literal"><span class="pre">zincr</span></tt> 通知。（译注：非对称，请注意。）</li>
<li><a class="reference internal" href="index.html#zadd"><em>ZADD</em></a> 产生一个 <tt class="docutils literal"><span class="pre">zadd</span></tt> 通知，即使有多个输入元素时，也是如此。</li>
<li><a class="reference internal" href="index.html#zrem"><em>ZREM</em></a> 产生一个 <tt class="docutils literal"><span class="pre">zrem</span></tt> 通知，即使有多个输入元素时，也是如此。如果执行 <a class="reference internal" href="index.html#zrem"><em>ZREM</em></a> 之后，有序集合键被清空，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#zremrangebyscore"><em>ZREMRANGEBYSCORE</em></a> 产生一个 <tt class="docutils literal"><span class="pre">zrembyscore</span></tt> 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#zremrangebyrank"><em>ZREMRANGEBYRANK</em></a> 产生一个 <tt class="docutils literal"><span class="pre">zrembyrank</span></tt> 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li><a class="reference internal" href="index.html#zinterstore"><em>ZINTERSTORE</em></a> 和 <a class="reference internal" href="index.html#zunionstore"><em>ZUNIONSTORE</em></a> 分别产生 <tt class="docutils literal"><span class="pre">zinterstore</span></tt> 和 <tt class="docutils literal"><span class="pre">zunionstore</span></tt> 两种通知。如果用于保存结果的键已经存在，那么还会产生一个 <tt class="docutils literal"><span class="pre">del</span></tt> 通知。</li>
<li>每当一个键因为过期而被删除时，产生一个 <tt class="docutils literal"><span class="pre">expired</span></tt> 通知。</li>
<li>每当一个键因为 <tt class="docutils literal"><span class="pre">maxmemory</span></tt> 政策而被删除以回收内存时，产生一个 <tt class="docutils literal"><span class="pre">evicted</span></tt> 通知。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>所有命令都只在键<strong>真的</strong>被改动了之后，才会产生通知。</p>
<p class="last">比如说，当 <a class="reference internal" href="index.html#srem"><em>SREM</em></a> 试图删除不存在于集合的元素时，删除操作会执行失败，因为没有真正的改动键，所以这一操作不会发送通知。</p>
</div>
<p>如果对命令所产生的通知有疑问，
最好还是使用以下命令，
自己来验证一下：</p>
<div class="highlight-python"><div class="highlight"><pre>$ redis-cli config set notify-keyspace-events KEA
$ redis-cli --csv psubscribe &#39;__key*__:*&#39;
Reading messages... (press Ctrl-C to quit)
&quot;psubscribe&quot;,&quot;__key*__:*&quot;,1
</pre></div>
</div>
<p>然后，
只要在其他终端里用 Redis 客户端发送命令，
就可以看到产生的通知了：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;pmessage&quot;</span><span class="p">,</span><span class="s">&quot;__key*__:*&quot;</span><span class="p">,</span><span class="s">&quot;__keyspace@0__:foo&quot;</span><span class="p">,</span><span class="s">&quot;set&quot;</span>
<span class="s">&quot;pmessage&quot;</span><span class="p">,</span><span class="s">&quot;__key*__:*&quot;</span><span class="p">,</span><span class="s">&quot;__keyevent@0__:set&quot;</span><span class="p">,</span><span class="s">&quot;foo&quot;</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>过期通知的发送时间<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>Redis 使用以下两种方式删除过期的键：</p>
<ul class="simple">
<li>当一个键被访问时，程序会对这个键进行检查，如果键已经过期，那么该键将被删除。</li>
<li>底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是不会被访问到的键。</li>
</ul>
<p>当过期键被以上两个程序的任意一个发现、
并且将键从数据库中删除时，
Redis 会产生一个 <tt class="docutils literal"><span class="pre">expired</span></tt> 通知。</p>
<p>Redis 并不保证生存时间（TTL）变为 <tt class="docutils literal"><span class="pre">0</span></tt> 的键会立即被删除：
如果程序没有访问这个过期键，
或者带有生存时间的键非常多的话，
那么在键的生存时间变为 <tt class="docutils literal"><span class="pre">0</span></tt> ，
直到键真正被删除这中间，
可能会有一段比较显著的时间间隔。</p>
<p>因此，
Redis 产生 <tt class="docutils literal"><span class="pre">expired</span></tt> 通知的时间为过期键被删除的时候，
而不是键的生存时间变为 <tt class="docutils literal"><span class="pre">0</span></tt> 的时候。</p>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-topic/transaction"></span><div class="section" id="transaction">
<h3>事务（transaction）<a class="headerlink" href="#transaction" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本文档翻译自： <a class="reference external" href="http://redis.io/topics/transactions">http://redis.io/topics/transactions</a> 。</p>
</div>
<p><a class="reference internal" href="index.html#multi"><em>MULTI</em></a> 、 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 、 <a class="reference internal" href="index.html#discard"><em>DISCARD</em></a> 和 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 是 Redis 事务的基础。</p>
<p>事务可以一次执行多个命令，
并且带有以下两个重要的保证：</p>
<ul>
<li><p class="first">事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p class="first">事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p><a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令负责触发并执行事务中的所有命令：</p>
<ul class="simple">
<li>如果客户端在使用 <a class="reference internal" href="index.html#multi"><em>MULTI</em></a> 开启了一个事务之后，却因为断线而没有成功执行 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> ，那么事务中的所有命令都会被执行。</li>
</ul>
<p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 <tt class="docutils literal"><span class="pre">write(2)</span></tt> 命令将事务写入到磁盘中。</p>
<p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p>
<p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p>
<p>使用 <tt class="docutils literal"><span class="pre">redis-check-aof</span></tt> 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p>
</li>
</ul>
<p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p>
<div class="section" id="id1">
<h4>用法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="index.html#multi"><em>MULTI</em></a> 命令用于开启一个事务，它总是返回 <tt class="docutils literal"><span class="pre">OK</span></tt> 。</p>
<p><a class="reference internal" href="index.html#multi"><em>MULTI</em></a> 执行之后，
客户端可以继续向服务器发送任意多条命令，
这些命令不会立即被执行，
而是被放到一个队列中，
当 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令被调用时，
所有队列中的命令才会被执行。</p>
<p>另一方面，
通过调用 <a class="reference internal" href="index.html#discard"><em>DISCARD</em></a> ，
客户端可以清空事务队列，
并放弃执行事务。</p>
<p>以下是一个事务例子，
它原子地增加了 <tt class="docutils literal"><span class="pre">foo</span></tt> 和 <tt class="docutils literal"><span class="pre">bar</span></tt> 两个键的值：</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; MULTI
OK

&gt; INCR foo
QUEUED

&gt; INCR bar
QUEUED

&gt; EXEC
1) (integer) 1
2) (integer) 1
</pre></div>
</div>
<p><a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令的回复是一个数组，
数组中的每个元素都是执行事务中的命令所产生的回复。
其中，
回复元素的先后顺序和命令发送的先后顺序一致。</p>
<p>当客户端处于事务状态时，
所有传入的命令都会返回一个内容为 <tt class="docutils literal"><span class="pre">QUEUED</span></tt> 的状态回复（status reply），
这些被入队的命令将在 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令被调用时执行。</p>
</div>
<div class="section" id="id2">
<h4>事务中的错误<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>使用事务时可能会遇上以下两种错误：</p>
<ul class="simple">
<li>事务在执行 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 <tt class="docutils literal"><span class="pre">maxmemory</span></tt> 设置了最大内存限制的话）。</li>
<li>命令可能在 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</li>
</ul>
<p>对于发生在 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 <tt class="docutils literal"><span class="pre">QUEUED</span></tt> ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</p>
<p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令时，拒绝执行并自动放弃这个事务。</p>
<p>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。
而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</p>
<p>至于那些在 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令执行之后所产生的错误，
并没有对它们进行特别处理：
即使事务中有某个/某些命令在执行时产生了错误，
事务中的其他命令仍然会继续执行。</p>
<p>从协议的角度来看这个问题，会更容易理解一些。
以下例子中，
<a class="reference internal" href="index.html#lpop"><em>LPOP</em></a> 命令的执行将出错，
尽管调用它的语法是正确的：</p>
<div class="highlight-python"><div class="highlight"><pre>Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.

MULTI
+OK

SET a 3
abc

+QUEUED
LPOP a

+QUEUED
EXEC

*2
+OK
-ERR Operation against a key holding the wrong kind of value
</pre></div>
</div>
<p><a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 返回两条批量回复（bulk reply）：
第一条是 <tt class="docutils literal"><span class="pre">OK</span></tt> ，而第二条是 <tt class="docutils literal"><span class="pre">-ERR</span></tt> 。
至于怎样用合适的方法来表示事务中的错误，
则是由客户端自己决定的。</p>
<p>最重要的是记住这样一条，
即使事务中有某条/某些命令执行失败了，
事务队列中的其他命令仍然会继续执行 ——
Redis 不会停止执行事务中的命令。</p>
<p>以下例子展示的是另一种情况，
当命令在入队时产生错误，
错误会立即被返回给客户端：</p>
<div class="highlight-python"><div class="highlight"><pre>MULTI
+OK

INCR a b c
-ERR wrong number of arguments for &#39;incr&#39; command
</pre></div>
</div>
<p>因为调用 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令的参数格式不正确，
所以这个 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令入队失败。</p>
</div>
<div class="section" id="redis-roll-back">
<h4>为什么 Redis 不支持回滚（roll back）<a class="headerlink" href="#redis-roll-back" title="Permalink to this headline">¶</a></h4>
<p>如果你有使用关系式数据库的经验，
那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p>
<p>以下是这种做法的优点：</p>
<ul class="simple">
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>有种观点认为 Redis 处理事务的做法会产生 bug ，
然而需要注意的是，
在通常情况下，
回滚并不能解决编程错误带来的问题。
举个例子，
如果你本来想通过 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令将键的值加上 <tt class="docutils literal"><span class="pre">1</span></tt> ，
却不小心加上了 <tt class="docutils literal"><span class="pre">2</span></tt> ，
又或者对错误类型的键执行了 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> ，
回滚是没有办法处理这些情况的。</p>
<p>鉴于没有任何机制能避免程序员自己造成的错误，
并且这类错误通常不会在生产环境中出现，
所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>
</div>
<div class="section" id="id3">
<h4>放弃事务<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>当执行 <a class="reference internal" href="index.html#discard"><em>DISCARD</em></a> 命令时，
事务会被放弃，
事务队列会被清空，
并且客户端会从事务状态中退出：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SET foo 1
OK

redis&gt; MULTI
OK

redis&gt; INCR foo
QUEUED

redis&gt; DISCARD
OK

redis&gt; GET foo
&quot;1&quot;
</pre></div>
</div>
</div>
<div class="section" id="check-and-set">
<h4>使用 check-and-set 操作实现乐观锁<a class="headerlink" href="#check-and-set" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 的键会被监视，并会发觉这些键是否被改动过了。
如果有至少一个被监视的键在 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 执行之前被修改了，
那么整个事务都会被取消，
<a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 返回空多条批量回复（null multi-bulk reply）来表示事务已经失败。</p>
<p>举个例子，
假设我们需要原子性地为某个值进行增 <tt class="docutils literal"><span class="pre">1</span></tt> 操作（假设 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 不存在）。</p>
<p>首先我们可能会这样做：</p>
<div class="highlight-python"><div class="highlight"><pre>val = GET mykey
val = val + 1
SET mykey $val
</pre></div>
</div>
<p>上面的这个实现在只有一个客户端的时候可以执行得很好。
但是，
当多个客户端同时对同一个键进行这样的操作时，
就会产生竞争条件。</p>
<p>举个例子，
如果客户端 A 和 B 都读取了键原来的值，
比如 <tt class="docutils literal"><span class="pre">10</span></tt> ，
那么两个客户端都会将键的值设为 <tt class="docutils literal"><span class="pre">11</span></tt> ，
但正确的结果应该是 <tt class="docutils literal"><span class="pre">12</span></tt> 才对。</p>
<p>有了 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> ，
我们就可以轻松地解决这类问题了：</p>
<div class="highlight-python"><div class="highlight"><pre>WATCH mykey

val = GET mykey
val = val + 1

MULTI
SET mykey $val
EXEC
</pre></div>
</div>
<p>使用上面的代码，
如果在 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 执行之后，
<a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 执行之前，
有其他客户端修改了 <tt class="docutils literal"><span class="pre">mykey</span></tt> 的值，
那么当前客户端的事务就会失败。
程序需要做的，
就是不断重试这个操作，
直到没有发生碰撞为止。</p>
<p>这种形式的锁被称作乐观锁，
它是一种非常强大的锁机制。
并且因为大多数情况下，
不同的客户端会访问不同的键，
碰撞的情况一般都很少，
所以通常并不需要进行重试。</p>
</div>
<div class="section" id="watch">
<h4>了解 WATCH<a class="headerlink" href="#watch" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 使得 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 命令需要有条件地执行：
事务只能在所有被监视键都没有被修改的前提下执行，
如果这个前提不能满足的话，事务就不会被执行。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">如果你使用 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 监视了一个带过期时间的键，
那么即使这个键过期了，
事务仍然可以正常执行，
关于这方面的详细情况，请看这个帖子： <a class="reference external" href="http://code.google.com/p/redis/issues/detail?id=270">http://code.google.com/p/redis/issues/detail?id=270</a></p>
</div>
<p><a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 命令可以被调用多次。
对键的监视从 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 执行之后开始生效，
直到调用 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 为止。</p>
<p>用户还可以在单个 <a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 命令中监视任意多个键，
就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; WATCH key1 key2 key3
OK
</pre></div>
</div>
<p>当 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 被调用时，
不管事务是否成功执行，
对所有键的监视都会被取消。</p>
<p>另外，
当客户端断开连接时，
该客户端对键的监视也会被取消。</p>
<p>使用无参数的 <a class="reference internal" href="index.html#unwatch"><em>UNWATCH</em></a> 命令可以手动取消对所有键的监视。
对于一些需要改动多个键的事务，
有时候程序需要同时对多个键进行加锁，
然后检查这些键的当前值是否符合程序的要求。
当值达不到要求时，
就可以使用 <a class="reference internal" href="index.html#unwatch"><em>UNWATCH</em></a> 命令来取消目前对键的监视，
中途放弃这个事务，
并等待事务的下次尝试。</p>
</div>
<div class="section" id="watch-zpop">
<h4>使用 WATCH 实现 ZPOP<a class="headerlink" href="#watch-zpop" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="index.html#watch"><em>WATCH</em></a> 可以用于创建 Redis 没有内置的原子操作。</p>
<p>举个例子，
以下代码实现了原创的 <tt class="docutils literal"><span class="pre">ZPOP</span></tt> 命令，
它可以原子地弹出有序集合中分值（score）最小的元素：</p>
<div class="highlight-python"><div class="highlight"><pre>WATCH zset
element = ZRANGE zset 0 0
MULTI
    ZREM zset element
EXEC
</pre></div>
</div>
<p>程序只要重复执行这段代码，
直到 <a class="reference internal" href="index.html#exec"><em>EXEC</em></a> 的返回值不是空多条回复（null multi-bulk reply）即可。</p>
</div>
<div class="section" id="redis">
<h4>Redis 脚本和事务<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h4>
<p>从定义上来说，
Redis 中的脚本本身就是一种事务，
所以任何在事务里可以完成的事，
在脚本里面也能完成。
并且一般来说，
使用脚本要来得更简单，并且速度更快。</p>
<p>因为脚本功能是 Redis 2.6 才引入的，
而事务功能则更早之前就存在了，
所以 Redis 才会同时存在两种处理事务的方法。</p>
<p>不过我们并不打算在短时间内就移除事务功能，
因为事务提供了一种即使不使用脚本，
也可以避免竞争条件的方法，
而且事务本身的实现并不复杂。</p>
<p>不过在不远的将来，
可能所有用户都会只使用脚本来实现事务也说不定。
如果真的发生这种情况的话，
那么我们将废弃并最终移除事务功能。</p>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-topic/pubsub"></span><div class="section" id="pub-sub">
<h3>发布与订阅（pub/sub）<a class="headerlink" href="#pub-sub" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本文档翻译自： <a class="reference external" href="http://redis.io/topics/pubsub">http://redis.io/topics/pubsub</a> 。</p>
</div>
<p><a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 、 <a class="reference internal" href="index.html#unsubscribe"><em>UNSUBSCRIBE</em></a> 和 <a class="reference internal" href="index.html#publish"><em>PUBLISH</em></a> 三个命令实现了<a class="reference external" href="http://en.wikipedia.org/wiki/Publish/subscribe">发布与订阅信息泛型</a>（Publish/Subscribe messaging paradigm），
在这个实现中，
发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端），
而是将信息发送给频道（channel），
然后由频道将信息转发给所有对这个频道感兴趣的订阅者。</p>
<p>发送者无须知道任何关于订阅者的信息，
而订阅者也无须知道是那个客户端给它发送信息，
它只要关注自己感兴趣的频道即可。</p>
<p>对发布者和订阅者进行解构（decoupling），
可以极大地提高系统的扩展性（scalability），
并得到一个更动态的网络拓扑（network topology）。</p>
<p>比如说，
要订阅频道 <tt class="docutils literal"><span class="pre">foo</span></tt> 和 <tt class="docutils literal"><span class="pre">bar</span></tt> ，
客户端可以使用频道名字作为参数来调用 <a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 命令：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SUBSCRIBE foo bar
</pre></div>
</div>
<p>当有客户端发送信息到这些频道时，
Redis 会将传入的信息推送到所有订阅这些频道的客户端里面。</p>
<p>正在订阅频道的客户端不应该发送除 <a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 和 <a class="reference internal" href="index.html#unsubscribe"><em>UNSUBSCRIBE</em></a> 之外的其他命令。
其中，
<a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 可以用于订阅更多频道，
而 <a class="reference internal" href="index.html#unsubscribe"><em>UNSUBSCRIBE</em></a> 则可以用于退订已订阅的一个或多个频道。</p>
<p><a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 和 <a class="reference internal" href="index.html#unsubscribe"><em>UNSUBSCRIBE</em></a> 的执行结果会以信息的形式返回，
客户端可以通过分析所接收信息的第一个元素，
从而判断所收到的内容是一条真正的信息，
还是 <a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 或 <a class="reference internal" href="index.html#unsubscribe"><em>UNSUBSCRIBE</em></a> 命令的操作结果。</p>
<div class="section" id="id2">
<h4>信息的格式<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>频道转发的每条信息都是一条带有三个元素的多条批量回复（multi-bulk reply）。</p>
<p>信息的第一个元素标识了信息的类型：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">subscribe</span></tt> ：
表示当前客户端成功地订阅了信息第二个元素所指示的频道。
而信息的第三个元素则记录了目前客户端已订阅频道的总数。</li>
<li><tt class="docutils literal"><span class="pre">unsubscribe</span></tt> ：
表示当前客户端成功地退订了信息第二个元素所指示的频道。
信息的第三个元素记录了客户端目前仍在订阅的频道数量。
当客户端订阅的频道数量降为 <tt class="docutils literal"><span class="pre">0</span></tt> 时，
客户端不再订阅任何频道，
它可以像往常一样，
执行任何 Redis 命令。</li>
<li><tt class="docutils literal"><span class="pre">message</span></tt> ：
表示这条信息是由某个客户端执行 <a class="reference internal" href="index.html#publish"><em>PUBLISH</em></a> 命令所发送的，
真正的信息。
信息的第二个元素是信息来源的频道，
而第三个元素则是信息的内容。</li>
</ul>
<p>举个例子，
如果客户端执行以下命令：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; SUBSCRIBE first second
</pre></div>
</div>
<p>那么它将收到以下回复：</p>
<div class="highlight-python"><div class="highlight"><pre>1) &quot;subscribe&quot;
2) &quot;first&quot;
3) (integer) 1

1) &quot;subscribe&quot;
2) &quot;second&quot;
3) (integer) 2
</pre></div>
</div>
<p>如果在这时，
另一个客户端执行以下 <a class="reference internal" href="index.html#publish"><em>PUBLISH</em></a> 命令：</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; PUBLISH second Hello
</pre></div>
</div>
<p>那么之前订阅了 <tt class="docutils literal"><span class="pre">second</span></tt> 频道的客户端将收到以下信息：</p>
<div class="highlight-python"><div class="highlight"><pre>1) &quot;message&quot;
2) &quot;second&quot;
3) &quot;hello&quot;
</pre></div>
</div>
<p>当订阅者决定退订所有频道时，
它可以执行一个无参数的 <a class="reference internal" href="index.html#unsubscribe"><em>UNSUBSCRIBE</em></a> 命令：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">UNSUBSCRIBE</span>
</pre></div>
</div>
<p>这个命令将接到以下回复：</p>
<div class="highlight-python"><div class="highlight"><pre>1) &quot;unsubscribe&quot;
2) &quot;second&quot;
3) (integer) 1

1) &quot;unsubscribe&quot;
2) &quot;first&quot;
3) (integer) 0
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>订阅模式<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Redis 的发布与订阅实现支持模式匹配（pattern matching）：
客户端可以订阅一个带 <tt class="docutils literal"><span class="pre">*</span></tt> 号的模式，
如果某个/某些频道的名字和这个模式匹配，
那么当有信息发送给这个/这些频道的时候，
客户端也会收到这个/这些频道的信息。</p>
<p>比如说，执行命令</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; PSUBSCRIBE news.*
</pre></div>
</div>
<p>的客户端将收到来自 <tt class="docutils literal"><span class="pre">news.art.figurative</span></tt> 、 <tt class="docutils literal"><span class="pre">news.music.jazz</span></tt> 等频道的信息。</p>
<p>客户端订阅的模式里面可以包含多个 glob 风格的通配符，
比如 <tt class="docutils literal"><span class="pre">*</span></tt> 、 <tt class="docutils literal"><span class="pre">?</span></tt> 和 <tt class="docutils literal"><span class="pre">[...]</span></tt> ，
等等。</p>
<p>执行命令</p>
<div class="highlight-python"><div class="highlight"><pre>redis&gt; PUNSUBSCRIBE news.*
</pre></div>
</div>
<p>将退订 <tt class="docutils literal"><span class="pre">news.*</span></tt> 模式，
其他已订阅的模式不会被影响。</p>
<p>通过订阅模式接收到的信息，
和通过订阅频道接收到的信息，
这两者的格式不太一样：</p>
<ul class="simple">
<li>通过订阅模式而接收到的信息的类型为 <tt class="docutils literal"><span class="pre">pmessage</span></tt> ：
这代表有某个客户端通过 <a class="reference internal" href="index.html#publish"><em>PUBLISH</em></a> 向某个频道发送了信息，
而这个频道刚好匹配了当前客户端所订阅的某个模式。
信息的第二个元素记录了被匹配的模式，
第三个元素记录了被匹配的频道的名字，
最后一个元素则记录了信息的实际内容。</li>
</ul>
<p>客户端处理 <a class="reference internal" href="index.html#psubscribe"><em>PSUBSCRIBE</em></a> 和 <a class="reference internal" href="index.html#punsubscribe"><em>PUNSUBSCRIBE</em></a> 返回值的方式，
和客户端处理 <a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 和 <a class="reference internal" href="index.html#unsubscribe"><em>UNSUBSCRIBE</em></a> 的方式类似：
通过对信息的第一个元素进行分析，
客户端可以判断接收到的信息是一个真正的信息，
还是 <a class="reference internal" href="index.html#psubscribe"><em>PSUBSCRIBE</em></a> 或 <a class="reference internal" href="index.html#punsubscribe"><em>PUNSUBSCRIBE</em></a> 命令的返回值。</p>
</div>
<div class="section" id="id4">
<h4>通过频道和模式接收同一条信息<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>如果客户端订阅的多个模式匹配了同一个频道，
或者客户端同时订阅了某个频道、以及匹配这个频道的某个模式，
那么它可能会多次接收到同一条信息。</p>
<p>举个例子，
如果客户端执行了以下命令：</p>
<div class="highlight-python"><div class="highlight"><pre>SUBSCRIBE foo
PSUBSCRIBE f*
</pre></div>
</div>
<p>那么当有信息发送到频道 <tt class="docutils literal"><span class="pre">foo</span></tt> 时，
客户端将收到两条信息：
一条来自频道 <tt class="docutils literal"><span class="pre">foo</span></tt> ，信息类型为 <tt class="docutils literal"><span class="pre">message</span></tt> ；
另一条来自模式 <tt class="docutils literal"><span class="pre">f*</span></tt> ，信息类型为 <tt class="docutils literal"><span class="pre">pmessage</span></tt> 。</p>
</div>
<div class="section" id="id5">
<h4>订阅总数<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>在执行 <a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 、 <a class="reference internal" href="index.html#unsubscribe"><em>UNSUBSCRIBE</em></a> 、 <a class="reference internal" href="index.html#psubscribe"><em>PSUBSCRIBE</em></a> 和 <a class="reference internal" href="index.html#punsubscribe"><em>PUNSUBSCRIBE</em></a> 命令时，
返回结果的最后一个元素是客户端目前仍在订阅的频道和模式总数。</p>
<p>当客户端退订所有频道和模式，
也即是这个总数值下降为 <tt class="docutils literal"><span class="pre">0</span></tt> 的时候，
客户端将退出订阅与发布状态。</p>
</div>
<div class="section" id="id6">
<h4>编程示例<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>Pieter Noordhuis 提供了一个使用 EventMachine 和 Redis 编写的 <a class="reference external" href="https://gist.github.com/348262">高性能多用户网页聊天软件</a> ，
这个软件很好地展示了发布与订阅功能的用法。</p>
</div>
<div class="section" id="id8">
<h4>客户端库实现提示<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>因为所有接收到的信息都会包含一个信息来源：</p>
<ul class="simple">
<li>当信息来自频道时，来源是某个频道；</li>
<li>当信息来自模式时，来源是某个模式。</li>
</ul>
<p>因此，
客户端可以用一个哈希表，
将特定来源和处理该来源的回调函数关联起来。
当有新信息到达时，
程序就可以根据信息的来源，
在 O(1) 复杂度内，
将信息交给正确的回调函数来处理。</p>
</div>
</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="toctree-wrapper first last compound">
<span id="document-topic/replication"></span><div class="section" id="replication">
<span id="replication-topic"></span><h3>复制（Replication）<a class="headerlink" href="#replication" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本文档翻译自： <a class="reference external" href="http://redis.io/topics/replication">http://redis.io/topics/replication</a> 。</p>
</div>
<p>Redis 支持简单且易用的主从复制（master-slave replication）功能，
该功能可以让从服务器(slave server)成为主服务器(master server)的精确复制品。</p>
<p>以下是关于 Redis 复制功能的几个重要方面：</p>
<ul>
<li><p class="first">Redis 使用异步复制。
从 Redis 2.8 开始，
从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p>
</li>
<li><p class="first">一个主服务器可以有多个从服务器。</p>
</li>
<li><p class="first">不仅主服务器可以有从服务器，
从服务器也可以有自己的从服务器，
多个从服务器之间可以构成一个图状结构。</p>
</li>
<li><p class="first">复制功能不会阻塞主服务器：
即使有一个或多个从服务器正在进行初次同步，
主服务器也可以继续处理命令请求。</p>
</li>
<li><p class="first">复制功能也不会阻塞从服务器：
只要在 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中进行了相应的设置，
即使从服务器正在进行初次同步，
服务器也可以使用旧版本的数据集来处理命令查询。</p>
<p>不过，
在从服务器删除旧版本数据集并载入新版本数据集的那段时间内，
连接请求会被阻塞。</p>
<p>你还可以配置从服务器，
让它在与主服务器之间的连接断开时，
向客户端发送一个错误。</p>
</li>
<li><p class="first">复制功能可以单纯地用于数据冗余（data redundancy），
也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）：
比如说，
繁重的 <a class="reference internal" href="index.html#sort"><em>SORT</em></a> 命令可以交给附属节点去运行。</p>
</li>
<li><p class="first">可以通过复制功能来让主服务器免于执行持久化操作：
只要关闭主服务器的持久化功能，
然后由从服务器去执行持久化操作即可。</p>
</li>
</ul>
<div class="section" id="id1">
<h4>复制功能的运作原理<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>无论是初次连接还是重新连接，
当建立一个从服务器时，
从服务器都将向主服务器发送一个 <a class="reference internal" href="index.html#sync"><em>SYNC</em></a> 命令。</p>
<p>接到 <a class="reference internal" href="index.html#sync"><em>SYNC</em></a> 命令的主服务器将开始执行 <a class="reference internal" href="index.html#bgsave"><em>BGSAVE</em></a> ，
并在保存操作执行期间，
将所有新执行的写入命令都保存到一个缓冲区里面。</p>
<p>当 <a class="reference internal" href="index.html#bgsave"><em>BGSAVE</em></a> 执行完毕后，
主服务器将执行保存操作所得的 <tt class="docutils literal"><span class="pre">.rdb</span></tt> 文件发送给从服务器，
从服务器接收这个 <tt class="docutils literal"><span class="pre">.rdb</span></tt> 文件，
并将文件中的数据载入到内存中。</p>
<p>之后主服务器会以 Redis 命令协议的格式，
将写命令缓冲区中积累的所有内容都发送给从服务器。</p>
<p>你可以通过 telnet 命令来亲自验证这个同步过程：
首先连上一个正在处理命令请求的 Redis 服务器，
然后向它发送 <a class="reference internal" href="index.html#sync"><em>SYNC</em></a> 命令，
过一阵子，
你将看到 telnet 会话（session）接收到服务器发来的大段数据（<tt class="docutils literal"><span class="pre">.rdb</span></tt> 文件），
之后还会看到，
所有在服务器执行过的写命令，
都会重新发送到 telnet 会话来。</p>
<p>即使有多个从服务器同时向主服务器发送 <a class="reference internal" href="index.html#sync"><em>SYNC</em></a> ，
主服务器也只需执行一次 <a class="reference internal" href="index.html#bgsave"><em>BGSAVE</em></a> 命令，
就可以处理所有这些从服务器的同步请求。</p>
<p>从服务器可以在主从服务器之间的连接断开时进行自动重连，
在 Redis 2.8 版本之前，
断线之后重连的从服务器总要执行一次完整重同步（full resynchronization）操作，
但是从 Redis 2.8 版本开始，
从服务器可以根据主服务器的情况来选择执行完整重同步还是部分重同步（partial resynchronization）。</p>
</div>
<div class="section" id="id2">
<h4>部分重同步<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>从 Redis 2.8 开始，
在网络连接短暂性失效之后，
主从服务器可以尝试继续执行原有的复制进程（process），
而不一定要执行完整重同步操作。</p>
<p>这个特性需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog），
并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset）和一个主服务器 ID （master run id），
当出现网络连接断开时，
从服务器会重新连接，
并且向主服务器请求继续执行原来的复制进程：</p>
<ul class="simple">
<li>如果从服务器记录的主服务器 ID 和当前要连接的主服务器的 ID 相同，
并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里面，
那么主服务器会向从服务器发送断线时缺失的那部分数据，
然后复制工作可以继续执行。</li>
<li>否则的话，
从服务器就要执行完整重同步操作。</li>
</ul>
<p>Redis 2.8 的这个部分重同步特性会用到一个新增的 <a class="reference internal" href="index.html#psync"><em>PSYNC</em></a> 内部命令，
而 Redis 2.8 以前的旧版本只有 <a class="reference internal" href="index.html#sync"><em>SYNC</em></a> 命令，
不过，
只要从服务器是 Redis 2.8 或以上的版本，
它就会根据主服务器的版本来决定到底是使用 <a class="reference internal" href="index.html#psync"><em>PSYNC</em></a> 还是 <a class="reference internal" href="index.html#sync"><em>SYNC</em></a> ：</p>
<ul class="simple">
<li>如果主服务器是 Redis 2.8 或以上版本，那么从服务器使用 <a class="reference internal" href="index.html#psync"><em>PSYNC</em></a> 命令来进行同步。</li>
<li>如果主服务器是 Redis 2.8 之前的版本，那么从服务器使用 <a class="reference internal" href="index.html#sync"><em>SYNC</em></a> 命令来进行同步。</li>
</ul>
</div>
<div class="section" id="id3">
<h4>配置<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>配置一个从服务器非常简单，
只要在配置文件中增加以下的这一行就可以了：</p>
<div class="highlight-python"><div class="highlight"><pre>slaveof 192.168.1.1 6379
</pre></div>
</div>
<p>当然，
你需要将代码中的 <tt class="docutils literal"><span class="pre">192.168.1.1</span></tt> 和 <tt class="docutils literal"><span class="pre">6379</span></tt> 替换成你的主服务器的 IP 和端口号。</p>
<p>另外一种方法是调用 <a class="reference internal" href="index.html#slaveof"><em>SLAVEOF</em></a> 命令，
输入主服务器的 IP 和端口，
然后同步就会开始：</p>
<div class="highlight-python"><div class="highlight"><pre>127.0.0.1:6379&gt; SLAVEOF 192.168.1.1 10086
OK
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>只读从服务器<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>从 Redis 2.6 开始，
从服务器支持只读模式，
并且该模式为从服务器的默认模式。</p>
<p>只读模式由 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中的 <tt class="docutils literal"><span class="pre">slave-read-only</span></tt> 选项控制，
也可以通过 <a class="reference internal" href="index.html#config-set"><em>CONFIG SET</em></a> 命令来开启或关闭这个模式。</p>
<p>只读从服务器会拒绝执行任何写命令，
所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</p>
<p>即使从服务器是只读的，
<tt class="docutils literal"><span class="pre">DEBUG</span></tt> 和 <tt class="docutils literal"><span class="pre">CONFIG</span></tt> 等管理式命令仍然是可以使用的，
所以我们还是不应该将服务器暴露给互联网或者任何不可信网络。
不过，
使用 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 中的命令改名选项，
我们可以通过禁止执行某些命令来提升只读从服务器的安全性。</p>
<p>你可能会感到好奇，
既然从服务器上的写数据会被重同步数据覆盖，
也可能在从服务器重启时丢失，
那么为什么要让一个从服务器变得可写呢？</p>
<p>原因是，
一些不重要的临时数据，
仍然是可以保存在从服务器上面的。
比如说，
客户端可以在从服务器上保存主服务器的可达性（reachability）信息，
从而实现故障转移（failover）策略。</p>
</div>
<div class="section" id="id5">
<h4>从服务器相关配置<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>如果主服务器通过 <tt class="docutils literal"><span class="pre">requirepass</span></tt> 选项设置了密码，
那么为了让从服务器的同步操作可以顺利进行，
我们也必须为从服务器进行相应的身份验证设置。</p>
<p>对于一个正在运行的服务器，
可以使用客户端输入以下命令：</p>
<div class="highlight-python"><div class="highlight"><pre>config set masterauth &lt;password&gt;
</pre></div>
</div>
<p>要永久地设置这个密码，
那么可以将它加入到配置文件中：</p>
<div class="highlight-python"><div class="highlight"><pre>masterauth &lt;password&gt;
</pre></div>
</div>
<p>另外还有几个选项，
它们和主服务器执行部分重同步时所使用的复制流缓冲区有关，
详细的信息可以参考 Redis 源码中附带的 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 示例文件。</p>
</div>
<div class="section" id="n">
<h4>主服务器只在有至少 N 个从服务器的情况下，才执行写操作<a class="headerlink" href="#n" title="Permalink to this headline">¶</a></h4>
<p>从 Redis 2.8 开始，
为了保证数据的安全性，
可以通过配置，
让主服务器只在有至少 N 个当前已连接从服务器的情况下，
才执行写命令。</p>
<p>不过，
因为 Redis 使用异步复制，
所以主服务器发送的写数据并不一定会被从服务器接收到，
因此，
数据丢失的可能性仍然是存在的。</p>
<p>以下是这个特性的运作原理：</p>
<ul class="simple">
<li>从服务器以每秒一次的频率 PING 主服务器一次，
并报告复制流的处理情况。</li>
<li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li>
<li>用户可以通过配置，
指定网络延迟的最大值 <tt class="docutils literal"><span class="pre">min-slaves-max-lag</span></tt> ，
以及执行写操作所需的至少从服务器数量 <tt class="docutils literal"><span class="pre">min-slaves-to-write</span></tt> 。</li>
</ul>
<p>如果至少有 <tt class="docutils literal"><span class="pre">min-slaves-to-write</span></tt> 个从服务器，
并且这些服务器的延迟值都少于 <tt class="docutils literal"><span class="pre">min-slaves-max-lag</span></tt> 秒，
那么主服务器就会执行客户端请求的写操作。</p>
<p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本：
尽管不能保证写操作的持久性，
但起码丢失数据的窗口会被严格限制在指定的秒数中。</p>
<p>另一方面，
如果条件达不到 <tt class="docutils literal"><span class="pre">min-slaves-to-write</span></tt> 和 <tt class="docutils literal"><span class="pre">min-slaves-max-lag</span></tt> 所指定的条件，
那么写操作就不会被执行，
主服务器会向请求执行写操作的客户端返回一个错误。</p>
<p>以下是这个特性的两个选项和它们所需的参数：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">min-slaves-to-write</span> <span class="pre">&lt;number</span> <span class="pre">of</span> <span class="pre">slaves&gt;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">min-slaves-max-lag</span> <span class="pre">&lt;number</span> <span class="pre">of</span> <span class="pre">seconds&gt;</span></tt></li>
</ul>
<p>详细的信息可以参考 Redis 源码中附带的 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 示例文件。</p>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-topic/protocol"></span><div class="section" id="protocol">
<h3>通信协议（protocol）<a class="headerlink" href="#protocol" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本文档翻译自： <a class="reference external" href="http://redis.io/topics/protocol">http://redis.io/topics/protocol</a> 。</p>
</div>
<p>Redis 协议在以下三个目标之间进行折中：</p>
<ul class="simple">
<li>易于实现</li>
<li>可以高效地被计算机分析（parse）</li>
<li>可以很容易地被人类读懂</li>
</ul>
<div class="section" id="id1">
<h4>网络层<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>客户端和服务器通过 TCP 连接来进行数据交互，
服务器默认的端口号为 6379 。</p>
<p>客户端和服务器发送的命令或数据一律以 <tt class="docutils literal"><span class="pre">\r\n</span></tt> （CRLF）结尾。</p>
</div>
<div class="section" id="id2">
<h4>请求<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Redis 服务器接受命令以及命令的参数。</p>
<p>服务器会在接到命令之后，对命令进行处理，并将命令的回复传送回客户端。</p>
</div>
<div class="section" id="id3">
<h4>新版统一请求协议<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>新版统一请求协议在 Redis 1.2 版本中引入，
并最终在 Redis 2.0 版本成为 Redis 服务器通信的标准方式。</p>
<p>你的 Redis 客户端应该按照这个新版协议来进行实现。</p>
<p>在这个协议中，
所有发送至 Redis 服务器的参数都是二进制安全（binary safe）的。</p>
<p>以下是这个协议的一般形式：</p>
<div class="highlight-python"><div class="highlight"><pre>*&lt;参数数量&gt; CR LF
$&lt;参数 1 的字节数量&gt; CR LF
&lt;参数 1 的数据&gt; CR LF
...
$&lt;参数 N 的字节数量&gt; CR LF
&lt;参数 N 的数据&gt; CR LF
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">译注：命令本身也作为协议的其中一个参数来发送。</p>
</div>
<p>举个例子，
以下是一个命令协议的打印版本：</p>
<div class="highlight-python"><div class="highlight"><pre>*3
$3
SET
$5
mykey
$7
myvalue
</pre></div>
</div>
<p>这个命令的实际协议值如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;*3</span><span class="se">\r\n</span><span class="s">$3</span><span class="se">\r\n</span><span class="s">SET</span><span class="se">\r\n</span><span class="s">$5</span><span class="se">\r\n</span><span class="s">mykey</span><span class="se">\r\n</span><span class="s">$7</span><span class="se">\r\n</span><span class="s">myvalue</span><span class="se">\r\n</span><span class="s">&quot;</span>
</pre></div>
</div>
<p>稍后我们会看到，
这种格式除了用作命令请求协议之外，
也用在命令的回复协议中：
这种只有一个参数的回复格式被称为<strong>批量回复（Bulk Reply）</strong>。</p>
<p>统一协议请求原本是用在回复协议中，
用于将列表的多个项返回给客户端的，
这种回复格式被称为<strong>多条批量回复（Multi Bulk Reply）</strong>。</p>
<p>一个多条批量回复以 <tt class="docutils literal"><span class="pre">*&lt;argc&gt;\r\n</span></tt> 为前缀，
后跟多条不同的批量回复，
其中 <tt class="docutils literal"><span class="pre">argc</span></tt> 为这些批量回复的数量。</p>
</div>
<div class="section" id="id4">
<h4>回复<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Redis 命令会返回多种不同类型的回复。</p>
<p>通过检查服务器发回数据的第一个字节，
可以确定这个回复是什么类型：</p>
<ul class="simple">
<li>状态回复（status reply）的第一个字节是 <tt class="docutils literal"><span class="pre">&quot;+&quot;</span></tt></li>
<li>错误回复（error reply）的第一个字节是 <tt class="docutils literal"><span class="pre">&quot;-&quot;</span></tt></li>
<li>整数回复（integer reply）的第一个字节是 <tt class="docutils literal"><span class="pre">&quot;:&quot;</span></tt></li>
<li>批量回复（bulk reply）的第一个字节是 <tt class="docutils literal"><span class="pre">&quot;$&quot;</span></tt></li>
<li>多条批量回复（multi bulk reply）的第一个字节是 <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt></li>
</ul>
</div>
<div class="section" id="id5">
<h4>状态回复<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>一个状态回复（或者单行回复，single line reply）是一段以 <tt class="docutils literal"><span class="pre">&quot;+&quot;</span></tt> 开始、 <tt class="docutils literal"><span class="pre">&quot;\r\n&quot;</span></tt> 结尾的单行字符串。</p>
<p>以下是一个状态回复的例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">+</span><span class="n">OK</span>
</pre></div>
</div>
<p>客户端库应该返回 <tt class="docutils literal"><span class="pre">&quot;+&quot;</span></tt> 号之后的所有内容。
比如在在上面的这个例子中，
客户端就应该返回字符串 <tt class="docutils literal"><span class="pre">&quot;OK&quot;</span></tt> 。</p>
<p>状态回复通常由那些不需要返回数据的命令返回，这种回复不是二进制安全的，它也不能包含新行。</p>
<p>状态回复的额外开销非常少，只需要三个字节（开头的 <tt class="docutils literal"><span class="pre">&quot;+&quot;</span></tt> 和结尾的 CRLF）。</p>
</div>
<div class="section" id="id6">
<h4>错误回复<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>错误回复和状态回复非常相似，
它们之间的唯一区别是，
错误回复的第一个字节是 <tt class="docutils literal"><span class="pre">&quot;-&quot;</span></tt> ，
而状态回复的第一个字节是 <tt class="docutils literal"><span class="pre">&quot;+&quot;</span></tt> 。</p>
<p>错误回复只在某些地方出现问题时发送：
比如说，
当用户对不正确的数据类型执行命令，
或者执行一个不存在的命令，
等等。</p>
<p>一个客户端库应该在收到错误回复时产生一个异常。</p>
<p>以下是两个错误回复的例子：</p>
<div class="highlight-python"><div class="highlight"><pre>-ERR unknown command &#39;foobar&#39;
-WRONGTYPE Operation against a key holding the wrong kind of value
</pre></div>
</div>
<p>在 <tt class="docutils literal"><span class="pre">&quot;-&quot;</span></tt> 之后，直到遇到第一个空格或新行为止，这中间的内容表示所返回错误的类型。</p>
<p><tt class="docutils literal"><span class="pre">ERR</span></tt> 是一个通用错误，而 <tt class="docutils literal"><span class="pre">WRONGTYPE</span></tt> 则是一个更特定的错误。
一个客户端实现可以为不同类型的错误产生不同类型的异常，
或者提供一种通用的方式，
让调用者可以通过提供字符串形式的错误名来捕捉（trap）不同的错误。</p>
<p>不过这些特性用得并不多，
所以并不是特别重要，
一个受限的（limited）客户端可以通过简单地返回一个逻辑假（false）来表示一个通用的错误条件。</p>
</div>
<div class="section" id="id7">
<h4>整数回复<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>整数回复就是一个以 <tt class="docutils literal"><span class="pre">&quot;:&quot;</span></tt> 开头， CRLF 结尾的字符串表示的整数。</p>
<p>比如说，
<tt class="docutils literal"><span class="pre">&quot;:0\r\n&quot;</span></tt> 和 <tt class="docutils literal"><span class="pre">&quot;:1000\r\n&quot;</span></tt> 都是整数回复。</p>
<p>返回整数回复的其中两个命令是 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 和 <a class="reference internal" href="index.html#lastsave"><em>LASTSAVE</em></a> 。
被返回的整数没有什么特殊的含义，
<a class="reference internal" href="index.html#incr"><em>INCR</em></a> 返回键的一个自增后的整数值，
而 <a class="reference internal" href="index.html#lastsave"><em>LASTSAVE</em></a> 则返回一个 UNIX 时间戳，
返回值的唯一限制是这些数必须能够用 64 位有符号整数表示。</p>
<p>整数回复也被广泛地用于表示逻辑真和逻辑假：
比如 <a class="reference internal" href="index.html#exists"><em>EXISTS</em></a> 和 <a class="reference internal" href="index.html#sismember"><em>SISMEMBER</em></a> 都用返回值 <tt class="docutils literal"><span class="pre">1</span></tt> 表示真，
<tt class="docutils literal"><span class="pre">0</span></tt> 表示假。</p>
<p>其他一些命令，
比如 <a class="reference internal" href="index.html#sadd"><em>SADD</em></a> 、 <a class="reference internal" href="index.html#srem"><em>SREM</em></a> 和 <a class="reference internal" href="index.html#setnx"><em>SETNX</em></a> ，
只在操作真正被执行了的时候，
才返回 <tt class="docutils literal"><span class="pre">1</span></tt> ，
否则返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。</p>
<p>以下命令都返回整数回复：
<a class="reference internal" href="index.html#setnx"><em>SETNX</em></a> 、
<a class="reference internal" href="index.html#del"><em>DEL</em></a> 、
<a class="reference internal" href="index.html#exists"><em>EXISTS</em></a> 、
<a class="reference internal" href="index.html#incr"><em>INCR</em></a> 、
<a class="reference internal" href="index.html#incrby"><em>INCRBY</em></a> 、
<a class="reference internal" href="index.html#decr"><em>DECR</em></a> 、
<a class="reference internal" href="index.html#decrby"><em>DECRBY</em></a> 、
<a class="reference internal" href="index.html#dbsize"><em>DBSIZE</em></a> 、
<a class="reference internal" href="index.html#lastsave"><em>LASTSAVE</em></a> 、
<a class="reference internal" href="index.html#renamenx"><em>RENAMENX</em></a> 、
<a class="reference internal" href="index.html#move"><em>MOVE</em></a> 、
<a class="reference internal" href="index.html#llen"><em>LLEN</em></a> 、
<a class="reference internal" href="index.html#sadd"><em>SADD</em></a> 、
<a class="reference internal" href="index.html#srem"><em>SREM</em></a> 、
<a class="reference internal" href="index.html#sismember"><em>SISMEMBER</em></a> 、
<a class="reference internal" href="index.html#scard"><em>SCARD</em></a> 。</p>
</div>
<div class="section" id="id8">
<h4>批量回复<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>服务器使用批量回复来返回二进制安全的字符串，字符串的最大长度为 512 MB 。</p>
<div class="highlight-python"><div class="highlight"><pre>客户端：GET mykey
服务器：foobar
</pre></div>
</div>
<p>服务器发送的内容中：</p>
<ul class="simple">
<li>第一字节为 <tt class="docutils literal"><span class="pre">&quot;$&quot;</span></tt> 符号</li>
<li>接下来跟着的是表示实际回复长度的数字值</li>
<li>之后跟着一个 CRLF</li>
<li>再后面跟着的是实际回复数据</li>
<li>最末尾是另一个 CRLF</li>
</ul>
<p>对于前面的 <a class="reference internal" href="index.html#get"><em>GET</em></a> 命令，服务器实际发送的内容为：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;$6</span><span class="se">\r\n</span><span class="s">foobar</span><span class="se">\r\n</span><span class="s">&quot;</span>
</pre></div>
</div>
<p>如果被请求的值不存在，
那么批量回复会将特殊值 <tt class="docutils literal"><span class="pre">-1</span></tt> 用作回复的长度值，
就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre>客户端：GET non-existing-key
服务器：$-1
</pre></div>
</div>
<p>这种回复称为空批量回复（NULL Bulk Reply）。</p>
<p>当请求对象不存在时，客户端应该返回空对象，而不是空字符串：
比如 Ruby 库应该返回 <tt class="docutils literal"><span class="pre">nil</span></tt> ，
而 C 库应该返回 <tt class="docutils literal"><span class="pre">NULL</span></tt> （或者在回复对象中设置一个特殊标志），
诸如此类。</p>
</div>
<div class="section" id="id9">
<h4>多条批量回复<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>像 <a class="reference internal" href="index.html#lrange"><em>LRANGE</em></a> 这样的命令需要返回多个值，
这一目标可以通过多条批量回复来完成。</p>
<p>多条批量回复是由多个回复组成的数组，
数组中的每个元素都可以是任意类型的回复，
包括多条批量回复本身。</p>
<p>多条批量回复的第一个字节为 <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt> ，
后跟一个字符串表示的整数值，
这个值记录了多条批量回复所包含的回复数量，
再后面是一个 CRLF 。</p>
<div class="highlight-python"><div class="highlight"><pre>客户端： LRANGE mylist 0 3
服务器： *4
服务器： $3
服务器： foo
服务器： $3
服务器： bar
服务器： $5
服务器： Hello
服务器： $5
服务器： World
</pre></div>
</div>
<p>在上面的示例中，服务器发送的所有字符串都由 CRLF 结尾。</p>
<p>正如你所见到的那样，
多条批量回复所使用的格式，
和客户端发送命令时使用的统一请求协议的格式一模一样。
它们之间的唯一区别是：</p>
<ul class="simple">
<li>统一请求协议只发送批量回复。</li>
<li>而服务器应答命令时所发送的多条批量回复，则可以包含任意类型的回复。</li>
</ul>
<p>以下例子展示了一个多条批量回复，
回复中包含四个整数值，
以及一个二进制安全字符串：</p>
<div class="highlight-python"><div class="highlight"><pre>*5\r\n
:1\r\n
:2\r\n
:3\r\n
:4\r\n
$6\r\n
foobar\r\n
</pre></div>
</div>
<p>在回复的第一行，
服务器发送 <tt class="docutils literal"><span class="pre">*5\r\n</span></tt> ，
表示这个多条批量回复包含 5 条回复，
再后面跟着的则是 5 条回复的正文。</p>
<p>多条批量回复也可以是空白的（empty），
就像这样：</p>
<div class="highlight-python"><div class="highlight"><pre>客户端： LRANGE nokey 0 1
服务器： *0\r\n
</pre></div>
</div>
<p>无内容的多条批量回复（null multi bulk reply）也是存在的，
比如当 <a class="reference internal" href="index.html#blpop"><em>BLPOP</em></a> 命令的阻塞时间超过最大时限时，
它就返回一个无内容的多条批量回复，
这个回复的计数值为 <tt class="docutils literal"><span class="pre">-1</span></tt> ：</p>
<div class="highlight-python"><div class="highlight"><pre>客户端： BLPOP key 1
服务器： *-1\r\n
</pre></div>
</div>
<p>客户端库应该区别对待空白多条回复和无内容多条回复：
当 Redis 返回一个无内容多条回复时，
客户端库应该返回一个 null 对象，
而不是一个空数组。</p>
</div>
<div class="section" id="id10">
<h4>多条批量回复中的空元素<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>多条批量回复中的元素可以将自身的长度设置为 <tt class="docutils literal"><span class="pre">-1</span></tt> ，
从而表示该元素不存在，
并且也不是一个空白字符串（empty string）。</p>
<p>当 <a class="reference internal" href="index.html#sort"><em>SORT</em></a> 命令使用 <tt class="docutils literal"><span class="pre">GET</span> <span class="pre">pattern</span></tt> 选项对一个不存在的键进行操作时，
就会发生多条批量回复中带有空白元素的情况。</p>
<p>以下例子展示了一个包含空元素的多重批量回复：</p>
<div class="highlight-python"><div class="highlight"><pre>服务器： *3
服务器： $3
服务器： foo
服务器： $-1
服务器： $3
服务器： bar
</pre></div>
</div>
<p>其中，
回复中的第二个元素为空。</p>
<p>对于这个回复，
客户端库应该返回类似于这样的回复：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">nil</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h4>多命令和流水线<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>客户端可以通过流水线，
在一次写入操作中发送多个命令：</p>
<ul class="simple">
<li>在发送新命令之前， 无须阅读前一个命令的回复。</li>
<li>多个命令的回复会在最后一并返回。</li>
</ul>
</div>
<div class="section" id="id12">
<h4>内联命令<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>当你需要和 Redis 服务器进行沟通，
但又找不到 <tt class="docutils literal"><span class="pre">redis-cli</span></tt> ，
而手上只有 <tt class="docutils literal"><span class="pre">telnet</span></tt> 的时候，
你可以通过 Redis 特别为这种情形而设的内联命令格式来发送命令。</p>
<p>以下是一个客户端和服务器使用内联命令来进行交互的例子：</p>
<div class="highlight-python"><div class="highlight"><pre>客户端： PING
服务器： +PONG
</pre></div>
</div>
<p>以下另一个返回整数值的内联命令的例子：</p>
<div class="highlight-python"><div class="highlight"><pre>客户端： EXISTS somekey
服务器： :0
</pre></div>
</div>
<p>因为没有了统一请求协议中的 <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt> 项来声明参数的数量，
所以在 <tt class="docutils literal"><span class="pre">telnet</span></tt> 会话输入命令的时候，
必须使用空格来分割各个参数，
服务器在接收到数据之后，
会按空格对用户的输入进行分析（parse），
并获取其中的命令参数。</p>
</div>
<div class="section" id="redis">
<h4>高性能 Redis 协议分析器<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h4>
<p>尽管 Redis 的协议非常利于人类阅读，
定义也很简单，
但这个协议的实现性能仍然可以和二进制协议一样快。</p>
<p>因为 Redis 协议将数据的长度放在数据正文之前，
所以程序无须像 JSON 那样，
为了寻找某个特殊字符而扫描整个 payload ，
也无须对发送至服务器的 payload 进行转义（quote）。</p>
<p>程序可以在对协议文本中的各个字符进行处理的同时，
查找 CR 字符，
并计算出批量回复或多条批量回复的长度，
就像这样：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">&quot;$123</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">p</span><span class="o">++</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
        <span class="n">p</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Now p points at &#39;\r&#39;, and the len is in bulk_len. */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>得到了批量回复或多条批量回复的长度之后，
程序只需调用一次 <tt class="docutils literal"><span class="pre">read</span></tt> 函数，
就可以将回复的正文数据全部读入到内存中，
而无须对这些数据做任何的处理。</p>
<p>在回复最末尾的 CR 和 LF 不作处理，丢弃它们。</p>
<p>Redis 协议的实现性能可以和二进制协议的实现性能相媲美，
并且由于 Redis 协议的简单性，
大部分高级语言都可以轻易地实现这个协议，
这使得客户端软件的 bug 数量大大减少。</p>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-topic/persistence"></span><div class="section" id="persistence">
<span id="id1"></span><h3>持久化（persistence）<a class="headerlink" href="#persistence" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本文档翻译自 <a class="reference external" href="http://redis.io/topics/persistence">http://redis.io/topics/persistence</a> 。</p>
</div>
<p>这篇文章提供了 Redis 持久化的技术性描述，
推荐所有 Redis 用户阅读。</p>
<p>要更广泛地了解 Redis 持久化，
以及这种持久化所保证的耐久性（durability），
请参考文章 <a class="reference external" href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">Redis persistence demystified</a> （<a class="reference external" href="http://blog.nosqlfan.com/html/3813.html">中文</a>）。</p>
<div class="section" id="redis">
<h4>Redis 持久化<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h4>
<p>Redis 提供了多种不同级别的持久化方式：</p>
<ul class="simple">
<li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li>
<li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。
AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。
Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li>
<li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。
在这种情况下，
当 Redis 重启时，
它会优先使用 AOF 文件来还原数据集，
因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li>
<li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li>
</ul>
<p>了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的，
以下几个小节将详细地介绍这这两种持久化功能，
并对它们的相同和不同之处进行说明。</p>
</div>
<div class="section" id="rdb">
<h4>RDB 的优点<a class="headerlink" href="#rdb" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。
这种文件非常适合用于进行备份：
比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。
这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li>
<li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li>
<li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 <tt class="docutils literal"><span class="pre">fork</span></tt> 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
</div>
<div class="section" id="id3">
<h4>RDB 的缺点<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。
虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率，
但是，
因为RDB 文件需要保存整个数据集的状态，
所以它并不是一个轻松的操作。
因此你可能会至少 5 分钟才保存一次 RDB 文件。
在这种情况下，
一旦发生故障停机，
你就可能会丢失好几分钟的数据。</li>
<li>每次保存 RDB 的时候，Redis 都要 <tt class="docutils literal"><span class="pre">fork()</span></tt> 出一个子进程，并由子进程来进行实际的持久化工作。
在数据集比较庞大时， <tt class="docutils literal"><span class="pre">fork()</span></tt> 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；
如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。
虽然 AOF 重写也需要进行 <tt class="docutils literal"><span class="pre">fork()</span></tt> ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li>
</ul>
</div>
<div class="section" id="aof">
<h4>AOF 的优点<a class="headerlink" href="#aof" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 <tt class="docutils literal"><span class="pre">fsync</span></tt> 策略，比如无 <tt class="docutils literal"><span class="pre">fsync</span></tt> ，每秒钟一次 <tt class="docutils literal"><span class="pre">fsync</span></tt> ，或者每次执行写入命令时 <tt class="docutils literal"><span class="pre">fsync</span></tt> 。
AOF 的默认策略为每秒钟 <tt class="docutils literal"><span class="pre">fsync</span></tt> 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ <tt class="docutils literal"><span class="pre">fsync</span></tt> 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li>
<li>AOF 文件是一个只进行追加操作的日志文件（append only log），
因此对 AOF 文件的写入不需要进行 <tt class="docutils literal"><span class="pre">seek</span></tt> ，
即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等），
<tt class="docutils literal"><span class="pre">redis-check-aof</span></tt> 工具也可以轻易地修复这种问题。</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：
重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。
整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。
而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作，
这些写入操作以 Redis 协议的格式保存，
因此 AOF 文件的内容非常容易被人读懂，
对文件进行分析（parse）也很轻松。
导出（export） AOF 文件也非常简单：
举个例子，
如果你不小心执行了 <a class="reference internal" href="index.html#flushall"><em>FLUSHALL</em></a> 命令，
但只要 AOF 文件未被重写，
那么只要停止服务器，
移除 AOF 文件末尾的 <a class="reference internal" href="index.html#flushall"><em>FLUSHALL</em></a> 命令，
并重启 Redis ，
就可以将数据集恢复到 <a class="reference internal" href="index.html#flushall"><em>FLUSHALL</em></a> 执行之前的状态。</li>
</ul>
</div>
<div class="section" id="id4">
<h4>AOF 的缺点<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 <tt class="docutils literal"><span class="pre">fsync</span></tt> 策略，AOF 的速度可能会慢于 RDB 。
在一般情况下，
每秒 <tt class="docutils literal"><span class="pre">fsync</span></tt> 的性能依然非常高，
而关闭 <tt class="docutils literal"><span class="pre">fsync</span></tt> 可以让 AOF 的速度和 RDB 一样快，
即使在高负荷之下也是如此。
不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li>
<li>AOF 在过去曾经发生过这样的 bug ：
因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。
（举个例子，阻塞命令 <a class="reference internal" href="index.html#brpoplpush"><em>BRPOPLPUSH</em></a> 就曾经引起过这样的 bug 。）
测试套件里为这种情况添加了测试：
它们会自动生成随机的、复杂的数据集，
并通过重新载入这些数据来确保一切正常。
虽然这种 bug 在 AOF 文件中并不常见，
但是对比来说，
RDB 几乎是不可能出现这种 bug 的。</li>
</ul>
</div>
<div class="section" id="rdb-aof">
<h4>RDB 和 AOF ，我应该用哪一个？<a class="headerlink" href="#rdb-aof" title="Permalink to this headline">¶</a></h4>
<p>一般来说，
如果想达到足以媲美 PostgreSQL 的数据安全性，
你应该同时使用两种持久化功能。</p>
<p>如果你非常关心你的数据，
但仍然可以承受数分钟以内的数据丢失，
那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化，
但我们并不推荐这种方式：
因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份，
并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，
除此之外，
使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">因为以上提到的种种原因，
未来我们可能会将 AOF 和 RDB 整合成单个持久化模型。
（这是一个长期计划。）</p>
</div>
<p>接下来的几个小节将介绍 RDB 和 AOF 的更多细节。</p>
</div>
<div class="section" id="id5">
<h4>RDB 快照<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>在默认情况下，
Redis 将数据库快照保存在名字为 <tt class="docutils literal"><span class="pre">dump.rdb</span></tt> 的二进制文件中。</p>
<p>你可以对 Redis 进行设置，
让它在“  <tt class="docutils literal"><span class="pre">N</span></tt> 秒内数据集至少有 <tt class="docutils literal"><span class="pre">M</span></tt> 个改动”这一条件被满足时，
自动保存一次数据集。</p>
<p>你也可以通过调用 <a class="reference internal" href="index.html#save"><em>SAVE</em></a> 或者 <a class="reference internal" href="index.html#bgsave"><em>BGSAVE</em></a> ，
手动让 Redis 进行数据集保存操作。</p>
<p>比如说，
以下设置会让 Redis 在满足“ <tt class="docutils literal"><span class="pre">60</span></tt> 秒内有至少有 <tt class="docutils literal"><span class="pre">1000</span></tt> 个键被改动”这一条件时，
自动保存一次数据集：</p>
<div class="highlight-python"><div class="highlight"><pre>save 60 1000
</pre></div>
</div>
<p>这种持久化方式被称为快照（snapshot）。</p>
</div>
<div class="section" id="id6">
<h4>快照的运作方式<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>当 Redis 需要保存 <tt class="docutils literal"><span class="pre">dump.rdb</span></tt> 文件时，
服务器执行以下操作：</p>
<ol class="arabic simple">
<li>Redis 调用 <tt class="docutils literal"><span class="pre">fork()</span></tt> ，同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ol>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
</div>
<div class="section" id="append-only-file-aof">
<h4>只进行追加操作的文件（append-only file，AOF）<a class="headerlink" href="#append-only-file-aof" title="Permalink to this headline">¶</a></h4>
<p>快照功能并不是非常耐久（durable）：
如果 Redis 因为某些原因而造成故障停机，
那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。</p>
<p>尽管对于某些程序来说，
数据的耐久性并不是最重要的考虑因素，
但是对于那些追求完全耐久能力（full durability）的程序来说，
快照功能就不太适用了。</p>
<p>从 1.1 版本开始，
Redis 增加了一种完全耐久的持久化方式：
AOF 持久化。</p>
<p>你可以通过修改配置文件来打开 AOF 功能：</p>
<div class="highlight-python"><div class="highlight"><pre>appendonly yes
</pre></div>
</div>
<p>从现在开始，
每当 Redis 执行一个改变数据集的命令时（比如 <a class="reference internal" href="index.html#set"><em>SET</em></a>），
这个命令就会被追加到 AOF 文件的末尾。</p>
<p>这样的话，
当 Redis 重新启时，
程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p>
</div>
<div class="section" id="id7">
<h4>AOF 重写<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾，
所以随着写入命令的不断增加，
AOF 文件的体积也会变得越来越大。</p>
<p>举个例子，
如果你对一个计数器调用了 100 次 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> ，
那么仅仅是为了保存这个计数器的当前值，
AOF 文件就需要使用 100 条记录（entry）。</p>
<p>然而在实际上，
只使用一条 <a class="reference internal" href="index.html#set"><em>SET</em></a> 命令已经足以保存计数器的当前值了，
其余 99 条记录实际上都是多余的。</p>
<p>为了处理这种情况，
Redis 支持一种有趣的特性：
可以在不打断服务客户端的情况下，
对 AOF 文件进行重建（rebuild）。</p>
<p>执行 <a class="reference internal" href="index.html#bgrewriteaof"><em>BGREWRITEAOF</em></a> 命令，
Redis 将生成一个新的 AOF 文件，
这个文件包含重建当前数据集所需的最少命令。</p>
<p>Redis 2.2 需要自己手动执行 <a class="reference internal" href="index.html#bgrewriteaof"><em>BGREWRITEAOF</em></a> 命令；
Redis 2.4 则可以自动触发 AOF 重写，
具体信息请查看 2.4 的示例配置文件。</p>
</div>
<div class="section" id="id8">
<h4>AOF 的耐久性如何？<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>你可以配置 Redis 多久才将数据 <tt class="docutils literal"><span class="pre">fsync</span></tt> 到磁盘一次。</p>
<p>有三个选项：</p>
<ul class="simple">
<li>每次有新命令追加到 AOF 文件时就执行一次 <tt class="docutils literal"><span class="pre">fsync</span></tt> ：非常慢，也非常安全。</li>
<li>每秒 <tt class="docutils literal"><span class="pre">fsync</span></tt> 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li>
<li>从不 <tt class="docutils literal"><span class="pre">fsync</span></tt> ：将数据交给操作系统来处理。更快，也更不安全的选择。</li>
</ul>
<p>推荐（并且也是默认）的措施为每秒 <tt class="docutils literal"><span class="pre">fsync</span></tt> 一次，
这种 <tt class="docutils literal"><span class="pre">fsync</span></tt> 策略可以兼顾速度和安全性。</p>
<p>总是 <tt class="docutils literal"><span class="pre">fsync</span></tt> 的策略在实际使用中非常慢，
即使在 Redis 2.0 对相关的程序进行了改进之后仍是如此 ——
频繁调用 <tt class="docutils literal"><span class="pre">fsync</span></tt> 注定了这种策略不可能快得起来。</p>
</div>
<div class="section" id="id9">
<h4>如果 AOF 文件出错了，怎么办？<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>服务器可能在程序正在对 AOF 文件进行写入时停机，
如果停机造成了 AOF 文件出错（corrupt），
那么 Redis 在重启时会拒绝载入这个 AOF 文件，
从而确保数据的一致性不会被破坏。</p>
<p>当发生这种情况时，
可以用以下方法来修复出错的 AOF 文件：</p>
<ol class="arabic simple">
<li>为现有的 AOF 文件创建一个备份。</li>
<li>使用 Redis 附带的 <tt class="docutils literal"><span class="pre">redis-check-aof</span></tt> 程序，对原来的 AOF 文件进行修复。</li>
</ol>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre>$ redis-check-aof --fix
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li>（可选）使用 <tt class="docutils literal"><span class="pre">diff</span> <span class="pre">-u</span></tt> 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。</li>
<li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</li>
</ol>
</div>
<div class="section" id="id10">
<h4>AOF 的运作方式<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。</p>
<p>以下是 AOF 重写的执行步骤：</p>
<ol class="arabic simple">
<li>Redis 执行 <tt class="docutils literal"><span class="pre">fork()</span></tt> ，现在同时拥有父进程和子进程。</li>
<li>子进程开始将新 AOF 文件的内容写入到临时文件。</li>
<li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾：
这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li>
<li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li>
<li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li>
</ol>
</div>
<div class="section" id="id11">
<h4>怎么从 RDB 持久化切换到 AOF 持久化<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ：</p>
<ol class="arabic simple">
<li>为最新的 <tt class="docutils literal"><span class="pre">dump.rdb</span></tt> 文件创建一个备份。</li>
<li>将备份放到一个安全的地方。</li>
<li>执行以下两条命令：</li>
</ol>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre>redis-cli&gt; CONFIG SET appendonly yes

redis-cli&gt; CONFIG SET save &quot;&quot;
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="4">
<li>确保命令执行之后，数据库的键的数量没有改变。</li>
<li>确保写命令会被正确地追加到 AOF 文件的末尾。</li>
</ol>
<p>步骤 3 执行的第一条命令开启了 AOF 功能：
Redis 会阻塞直到初始 AOF 文件创建完成为止，
之后 Redis 会继续处理命令请求，
并开始将写入命令追加到 AOF 文件末尾。</p>
<p>步骤 3 执行的第二条命令用于关闭 RDB 功能。
这一步是可选的，
如果你愿意的话，
也可以同时使用 RDB 和 AOF 这两种持久化功能。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">别忘了在 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 中打开 AOF 功能！
否则的话，
服务器重启之后，
之前通过 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">SET</span></tt> 设置的配置就会被遗忘，
程序会按原来的配置来启动服务器。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">译注：
原文这里还有介绍 2.0 版本的切换方式，
考虑到 2.0 已经很老旧了，
这里省略了对那部分文档的翻译，
有需要的请参考原文。</p>
</div>
</div>
<div class="section" id="id12">
<h4>RDB 和 AOF 之间的相互作用<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>在版本号大于等于 2.4 的 Redis 中，
<a class="reference internal" href="index.html#bgsave"><em>BGSAVE</em></a> 执行的过程中，
不可以执行 <a class="reference internal" href="index.html#bgrewriteaof"><em>BGREWRITEAOF</em></a> 。
反过来说，
在 <a class="reference internal" href="index.html#bgrewriteaof"><em>BGREWRITEAOF</em></a> 执行的过程中，
也不可以执行 <a class="reference internal" href="index.html#bgsave"><em>BGSAVE</em></a> 。</p>
<p>这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p>
<p>如果 <a class="reference internal" href="index.html#bgsave"><em>BGSAVE</em></a> 正在执行，
并且用户显示地调用 <a class="reference internal" href="index.html#bgrewriteaof"><em>BGREWRITEAOF</em></a> 命令，
那么服务器将向用户回复一个 <tt class="docutils literal"><span class="pre">OK</span></tt> 状态，
并告知用户，
<a class="reference internal" href="index.html#bgrewriteaof"><em>BGREWRITEAOF</em></a> 已经被预定执行：
一旦 <a class="reference internal" href="index.html#bgsave"><em>BGSAVE</em></a> 执行完毕，
<a class="reference internal" href="index.html#bgrewriteaof"><em>BGREWRITEAOF</em></a> 就会正式开始。</p>
<p>当 Redis 启动时，
如果 RDB 持久化和 AOF 持久化都被打开了，
那么程序会优先使用 AOF 文件来恢复数据集，
因为 AOF 文件所保存的数据通常是最完整的。</p>
</div>
<div class="section" id="id13">
<h4>备份 Redis 数据<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>在阅读这个小节前，
先将下面这句话铭记于心：
一定要备份你的数据库！</p>
<p>磁盘故障，
节点失效，
诸如此类的问题都可能让你的数据消失不见，
不进行备份是非常危险的。</p>
<p>Redis 对于数据备份是非常友好的，
因为你可以在服务器运行的时候对 RDB 文件进行复制：
RDB 文件一旦被创建，
就不会进行任何修改。
当服务器要创建一个新的 RDB 文件时，
它先将文件的内容保存在一个临时文件里面，
当临时文件写入完毕时，
程序才使用 <tt class="docutils literal"><span class="pre">rename(2)</span></tt> 原子地用临时文件替换原来的 RDB 文件。</p>
<p>这也就是说，
无论何时，
复制 RDB 文件都是绝对安全的。</p>
<p>以下是我们的建议：</p>
<ul class="simple">
<li>创建一个定期任务（cron job），
每小时将一个 RDB 文件备份到一个文件夹，
并且每天将一个 RDB 文件备份到另一个文件夹。</li>
<li>确保快照的备份都带有相应的日期和时间信息，
每次执行定期任务脚本时，
使用 <tt class="docutils literal"><span class="pre">find</span></tt> 命令来删除过期的快照：
比如说，
你可以保留最近 48 小时内的每小时快照，
还可以保留最近一两个月的每日快照。</li>
<li>至少每天一次，
将 RDB 备份到你的数据中心之外，
或者至少是备份到你运行 Redis 服务器的物理机器之外。</li>
</ul>
</div>
<div class="section" id="id14">
<h4>容灾备份<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>Redis 的容灾备份基本上就是对数据进行备份，
并将这些备份传送到多个不同的外部数据中心。</p>
<p>容灾备份可以在 Redis 运行并产生快照的主数据中心发生严重的问题时，
仍然让数据处于安全状态。</p>
<p>因为很多 Redis 用户都是创业者，
他们没有大把大把的钱可以浪费，
所以下面介绍的都是一些实用又便宜的容灾备份方法：</p>
<ul class="simple">
<li>Amazon S3 ，以及其他类似 S3 的服务，是一个构建灾难备份系统的好地方。
最简单的方法就是将你的每小时或者每日 RDB 备份加密并传送到 S3 。
对数据的加密可以通过 <tt class="docutils literal"><span class="pre">gpg</span> <span class="pre">-c</span></tt> 命令来完成（对称加密模式）。
记得把你的密码放到几个不同的、安全的地方去（比如你可以把密码复制给你组织里最重要的人物）。
同时使用多个储存服务来保存数据文件，可以提升数据的安全性。</li>
<li>传送快照可以使用 SCP 来完成（SSH 的组件）。
以下是简单并且安全的传送方法：
买一个离你的数据中心非常远的 VPS ，
装上 SSH ，
创建一个无口令的 SSH 客户端 key ，
并将这个 key 添加到 VPS 的 authorized_keys 文件中，
这样就可以向这个 VPS 传送快照备份文件了。
为了达到最好的数据安全性，至少要从两个不同的提供商那里各购买一个 VPS 来进行数据容灾备份。</li>
</ul>
<p>需要注意的是，
这类容灾系统如果没有小心地进行处理的话，
是很容易失效的。</p>
<p>最低限度下，
你应该在文件传送完毕之后，
检查所传送备份文件的体积和原始快照文件的体积是否相同。
如果你使用的是 VPS ，
那么还可以通过比对文件的 SHA1 校验和来确认文件是否传送完整。</p>
<p>另外，
你还需要一个独立的警报系统，
让它在负责传送备份文件的传送器（transfer）失灵时通知你。</p>
</div>
</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="toctree-wrapper first last compound">
<span id="document-topic/sentinel"></span><div class="section" id="sentinel">
<span id="id1"></span><h3>Sentinel<a class="headerlink" href="#sentinel" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本文档翻译自： <a class="reference external" href="http://redis.io/topics/sentinel">http://redis.io/topics/sentinel</a> 。</p>
</div>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance），
该系统执行以下三个任务：</p>
<ul class="simple">
<li><strong>监控（Monitoring）</strong>：
Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong>：
当被监控的某个 Redis 服务器出现问题时，
Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong>：
当一个主服务器不能正常工作时，
Sentinel 会开始一次自动故障迁移操作，
它会将失效主服务器的其中一个从服务器升级为新的主服务器，
并让失效主服务器的其他从服务器改为复制新的主服务器；
当客户端试图连接失效的主服务器时，
集群也会向客户端返回新主服务器的地址，
使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis Sentinel 是一个分布式系统，
你可以在一个架构中运行多个 Sentinel 进程（progress），
这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息，
并使用投票协议（agreement protocols）来决定是否执行自动故障迁移，
以及选择哪个从服务器作为新的主服务器。</p>
<p>虽然 Redis Sentinel 释出为一个单独的可执行文件 <tt class="docutils literal"><span class="pre">redis-sentinel</span></tt> ，
但实际上它只是一个运行在特殊模式下的 Redis 服务器，
你可以在启动一个普通 Redis 服务器时通过给定 <tt class="docutils literal"><span class="pre">--sentinel</span></tt> 选项来启动 Redis Sentinel 。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Redis Sentinel 目前仍在开发中，
这个文档的内容可能随着 Sentinel 实现的修改而变更。</p>
<p class="last">Redis Sentinel 兼容 Redis 2.4.16 或以上版本，
推荐使用 Redis 2.8.0 或以上的版本。</p>
</div>
<div class="section" id="id2">
<h4>获取 Sentinel<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>目前 Sentinel 系统是 Redis 的 <tt class="docutils literal"><span class="pre">unstable</span></tt> 分支的一部分，
你必须到 <a class="reference external" href="https://github.com/antirez/redis">Redis 项目的 Github 页面</a> 克隆一份 <tt class="docutils literal"><span class="pre">unstable</span></tt> 分值，
然后通过编译来获得 Sentinel 系统。</p>
<p>Sentinel 程序可以在编译后的 <tt class="docutils literal"><span class="pre">src</span></tt> 文档中发现，
它是一个命名为 <tt class="docutils literal"><span class="pre">redis-sentinel</span></tt> 的程序。</p>
<p>你也可以通过下一节介绍的方法，
让 <tt class="docutils literal"><span class="pre">redis-server</span></tt> 程序运行在 Sentinel 模式之下。</p>
<p>另外，
一个新版本的 Sentinel 已经包含在了 Redis 2.8.0 版本的释出文件中。</p>
</div>
<div class="section" id="id3">
<h4>启动 Sentinel<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>对于 <tt class="docutils literal"><span class="pre">redis-sentinel</span></tt> 程序，
你可以用以下命令来启动 Sentinel 系统：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">redis</span><span class="o">-</span><span class="n">sentinel</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">sentinel</span><span class="o">.</span><span class="n">conf</span>
</pre></div>
</div>
<p>对于 <tt class="docutils literal"><span class="pre">redis-server</span></tt> 程序，
你可以用以下命令来启动一个运行在 Sentinel 模式下的 Redis 服务器：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">redis</span><span class="o">-</span><span class="n">server</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">sentinel</span><span class="o">.</span><span class="n">conf</span> <span class="o">--</span><span class="n">sentinel</span>
</pre></div>
</div>
<p>两种方法都可以启动一个 Sentinel 实例。</p>
<p>启动 Sentinel 实例必须指定相应的配置文件，
系统会使用配置文件来保存 Sentinel 的当前状态，
并在 Sentinel 重启时通过载入配置文件来进行状态还原。</p>
<p>如果启动 Sentinel 时没有指定相应的配置文件，
或者指定的配置文件不可写（not writable），
那么 Sentinel 会拒绝启动。</p>
</div>
<div class="section" id="id4">
<h4>配置 Sentinel<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Redis 源码中包含了一个名为 <tt class="docutils literal"><span class="pre">sentinel.conf</span></tt> 的文件，
这个文件是一个带有详细注释的 Sentinel 配置文件示例。</p>
<p>运行一个 Sentinel 所需的最少配置如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre>sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1

sentinel monitor resque 192.168.1.3 6380 4
sentinel down-after-milliseconds resque 10000
sentinel failover-timeout resque 180000
sentinel parallel-syncs resque 5
</pre></div>
</div>
<p>第一行配置指示 Sentinel 去监视一个名为 <tt class="docutils literal"><span class="pre">mymaster</span></tt> 的主服务器，
这个主服务器的 IP 地址为 <tt class="docutils literal"><span class="pre">127.0.0.1</span></tt> ，
端口号为 <tt class="docutils literal"><span class="pre">6379</span></tt> ，
而将这个主服务器判断为失效至少需要 <tt class="docutils literal"><span class="pre">2</span></tt> 个 Sentinel 同意
（只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）。</p>
<p>不过要注意，
无论你设置要多少个 Sentinel 同意才能判断一个服务器失效，
<strong>一个 Sentinel 都需要获得系统中多数（majority） Sentinel 的支持，
才能发起一次自动故障迁移，</strong>
并预留一个给定的配置纪元
（configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号）。</p>
<p>换句话说，
<strong>在只有少数（minority） Sentinel 进程正常运作的情况下，
Sentinel 是不能执行自动故障迁移的。</strong></p>
<p>其他选项的基本格式如下：</p>
<div class="highlight-python"><div class="highlight"><pre>sentinel &lt;选项的名字&gt; &lt;主服务器的名字&gt; &lt;选项的值&gt;
</pre></div>
</div>
<p>各个选项的功能如下：</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">down-after-milliseconds</span></tt> 选项指定了 Sentinel 认为服务器已经断线所需的毫秒数。</p>
<p>如果服务器在给定的毫秒数之内，
没有返回 Sentinel 发送的 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令的回复，
或者返回一个错误，
那么 Sentinel 将这个服务器标记为<strong>主观下线</strong>（subjectively down，简称 <tt class="docutils literal"><span class="pre">SDOWN</span></tt> ）。</p>
<p>不过只有一个 Sentinel 将服务器标记为主观下线并不一定会引起服务器的自动故障迁移：
只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后，
服务器才会被标记为<strong>客观下线</strong>（objectively down， 简称 <tt class="docutils literal"><span class="pre">ODOWN</span></tt> ），
这时自动故障迁移才会执行。</p>
<p>将服务器标记为客观下线所需的 Sentinel 数量由对主服务器的配置决定。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">parallel-syncs</span></tt> 选项指定了在执行故障转移时，
最多可以有多少个从服务器同时对新的主服务器进行同步，
这个数字越小，
完成故障转移所需的时间就越长。</p>
<p>如果从服务器被设置为允许使用过期数据集（参见对 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件中对 <tt class="docutils literal"><span class="pre">slave-serve-stale-data</span></tt> 选项的说明），
那么你可能不希望所有从服务器都在同一时间向新的主服务器发送同步请求，
因为尽管复制过程的绝大部分步骤都不会阻塞从服务器，
但从服务器在载入主服务器发来的 RDB 文件时，
仍然会造成从服务器在一段时间内不能处理命令请求：
如果全部从服务器一起对新的主服务器进行同步，
那么就可能会造成所有从服务器在短时间内全部不可用的情况出现。</p>
<p>你可以通过将这个值设为 <tt class="docutils literal"><span class="pre">1</span></tt> 来保证每次只有一个从服务器处于不能处理命令请求的状态。</p>
</li>
</ul>
<p>本文档剩余的内容将对 Sentinel 系统的其他选项进行介绍，
示例配置文件 <tt class="docutils literal"><span class="pre">sentinel.conf</span></tt> 也对相关的选项进行了完整的注释。</p>
</div>
<div class="section" id="id5">
<h4>主观下线和客观下线<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>前面说过，
Redis 的 Sentinel 中关于下线（down）有两个不同的概念：</p>
<ul class="simple">
<li>主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</li>
<li>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断，
并且通过 <tt class="docutils literal"><span class="pre">SENTINEL</span> <span class="pre">is-master-down-by-addr</span></tt> 命令互相交流之后，
得出的服务器下线判断。
（一个 Sentinel 可以通过向另一个 Sentinel 发送 <tt class="docutils literal"><span class="pre">SENTINEL</span> <span class="pre">is-master-down-by-addr</span></tt> 命令来询问对方是否认为给定的服务器已下线。）</li>
</ul>
<p>如果一个服务器没有在 <tt class="docutils literal"><span class="pre">master-down-after-milliseconds</span></tt> 选项所指定的时间内，
对向它发送 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令的 Sentinel 返回一个有效回复（valid reply），
那么 Sentinel 就会将这个服务器标记为主观下线。</p>
<p>服务器对 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令的有效回复可以是以下三种回复的其中一种：</p>
<ul class="simple">
<li>返回 <tt class="docutils literal"><span class="pre">+PONG</span></tt> 。</li>
<li>返回 <tt class="docutils literal"><span class="pre">-LOADING</span></tt> 错误。</li>
<li>返回 <tt class="docutils literal"><span class="pre">-MASTERDOWN</span></tt> 错误。</li>
</ul>
<p>如果服务器返回除以上三种回复之外的其他回复，
又或者在指定时间内没有回复 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令，
那么 Sentinel 认为服务器返回的回复无效（non-valid）。</p>
<p>注意，
一个服务器必须在 <tt class="docutils literal"><span class="pre">master-down-after-milliseconds</span></tt> 毫秒内，
一直返回无效回复才会被 Sentinel 标记为主观下线。</p>
<p>举个例子，
如果 <tt class="docutils literal"><span class="pre">master-down-after-milliseconds</span></tt> 选项的值为 <tt class="docutils literal"><span class="pre">30000</span></tt> 毫秒（<tt class="docutils literal"><span class="pre">30</span></tt> 秒），
那么只要服务器能在每 <tt class="docutils literal"><span class="pre">29</span></tt> 秒之内返回至少一次有效回复，
这个服务器就仍然会被认为是处于正常状态的。</p>
<p>从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm），
而是使用了流言协议：
如果 Sentinel 在给定的时间范围内，
从其他 Sentinel 那里接收到了足够数量的主服务器下线报告，
那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线。
如果之后其他 Sentinel 不再报告主服务器已下线，
那么客观下线状态就会被移除。</p>
<p>客观下线条件<strong>只适用于主服务器</strong>：
对于任何其他类型的 Redis 实例，
Sentinel 在将它们判断为下线前不需要进行协商，
所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。</p>
<p>只要一个 Sentinel 发现某个主服务器进入了客观下线状态，
这个 Sentinel 就可能会被其他 Sentinel 推选出，
并对失效的主服务器执行自动故障迁移操作。</p>
</div>
<div class="section" id="id6">
<h4>每个 Sentinel 都需要定期执行的任务<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>每个 Sentinel 以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令。</li>
<li>如果一个实例（instance）距离最后一次有效回复 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令的时间超过 <tt class="docutils literal"><span class="pre">down-after-milliseconds</span></tt> 选项所指定的值，
那么这个实例会被 Sentinel 标记为主观下线。
一个有效回复可以是： <tt class="docutils literal"><span class="pre">+PONG</span></tt> 、 <tt class="docutils literal"><span class="pre">-LOADING</span></tt> 或者 <tt class="docutils literal"><span class="pre">-MASTERDOWN</span></tt> 。</li>
<li>如果一个主服务器被标记为主观下线，
那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。</li>
<li>如果一个主服务器被标记为主观下线，
并且有足够数量的 Sentinel （至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，
那么这个主服务器被标记为客观下线。</li>
<li>在一般情况下，
每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 <a class="reference internal" href="index.html#info"><em>INFO</em></a> 命令。
当一个主服务器被 Sentinel 标记为客观下线时，
Sentinel 向下线主服务器的所有从服务器发送 <a class="reference internal" href="index.html#info"><em>INFO</em></a> 命令的频率会从 10 秒一次改为每秒一次。</li>
<li>当没有足够数量的 Sentinel 同意主服务器已经下线，
主服务器的客观下线状态就会被移除。
当主服务器重新向 Sentinel 的 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令返回有效回复时，
主服务器的主管下线状态就会被移除。</li>
</ul>
</div>
<div class="section" id="id7">
<h4>自动发现 Sentinel 和从服务器<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>一个 Sentinel 可以与其他多个 Sentinel 进行连接，
各个 Sentinel 之间可以互相检查对方的可用性，
并进行信息交换。</p>
<p>你无须为运行的每个 Sentinel 分别设置其他 Sentinel 的地址，
因为 Sentinel 可以通过发布与订阅功能来自动发现正在监视相同主服务器的其他 Sentinel ，
这一功能是通过向频道 <tt class="docutils literal"><span class="pre">__sentinel__:hello</span></tt> 发送信息来实现的。</p>
<p>与此类似，
你也不必手动列出主服务器属下的所有从服务器，
因为 Sentinel 可以通过询问主服务器来获得所有从服务器的信息。</p>
<ul class="simple">
<li>每个 Sentinel 会以每两秒一次的频率，
通过发布与订阅功能，
向被它监视的所有主服务器和从服务器的 <tt class="docutils literal"><span class="pre">__sentinel__:hello</span></tt> 频道发送一条信息，
信息中包含了 Sentinel 的 IP 地址、端口号和运行 ID （runid）。</li>
<li>每个 Sentinel 都订阅了被它监视的所有主服务器和从服务器的 <tt class="docutils literal"><span class="pre">__sentinel__:hello</span></tt> 频道，
查找之前未出现过的 sentinel （looking for unknown sentinels）。
当一个 Sentinel 发现一个新的 Sentinel 时，
它会将新的 Sentinel 添加到一个列表中，
这个列表保存了 Sentinel 已知的，
监视同一个主服务器的所有其他 Sentinel 。</li>
<li>Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。
如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧，
那么这个 Sentinel 会立即升级到新配置上。</li>
<li>在将一个新 Sentinel 添加到监视主服务器的列表上面之前，
Sentinel 会先检查列表中是否已经包含了和要添加的 Sentinel 拥有相同运行 ID 或者相同地址（包括 IP 地址和端口号）的 Sentinel ，
如果是的话，
Sentinel 会先移除列表中已有的那些拥有相同运行 ID 或者相同地址的 Sentinel ，
然后再添加新 Sentinel 。</li>
</ul>
</div>
<div class="section" id="sentinel-api">
<h4>Sentinel API<a class="headerlink" href="#sentinel-api" title="Permalink to this headline">¶</a></h4>
<p>在默认情况下，
Sentinel 使用 TCP 端口 <tt class="docutils literal"><span class="pre">26379</span></tt>
（普通 Redis 服务器使用的是 <tt class="docutils literal"><span class="pre">6379</span></tt> ）。</p>
<p>Sentinel 接受 Redis 协议格式的命令请求，
所以你可以使用 <tt class="docutils literal"><span class="pre">redis-cli</span></tt> 或者任何其他 Redis 客户端来与 Sentinel 进行通讯。</p>
<p>有两种方式可以和 Sentinel 进行通讯：</p>
<ul class="simple">
<li>第一种方法是通过直接发送命令来查询被监视 Redis 服务器的当前状态，
以及 Sentinel 所知道的关于其他 Sentinel 的信息，
诸如此类。</li>
<li>另一种方法是使用发布与订阅功能，
通过接收 Sentinel 发送的通知：
当执行故障转移操作，
或者某个被监视的服务器被判断为主观下线或者客观下线时，
Sentinel 就会发送相应的信息。</li>
</ul>
<div class="section" id="id8">
<h5>Sentinel 命令<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h5>
<p>以下列出的是 Sentinel 接受的命令：</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#ping"><em>PING</em></a> ：返回 <tt class="docutils literal"><span class="pre">PONG</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">SENTINEL</span> <span class="pre">masters</span></tt> ：列出所有被监视的主服务器，以及这些主服务器的当前状态。</li>
<li><tt class="docutils literal"><span class="pre">SENTINEL</span> <span class="pre">slaves</span> <span class="pre">&lt;master</span> <span class="pre">name&gt;</span></tt> ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。</li>
<li><tt class="docutils literal"><span class="pre">SENTINEL</span> <span class="pre">get-master-addr-by-name</span> <span class="pre">&lt;master</span> <span class="pre">name&gt;</span></tt> ：
返回给定名字的主服务器的 IP 地址和端口号。
如果这个主服务器正在执行故障转移操作，
或者针对这个主服务器的故障转移操作已经完成，
那么这个命令返回新的主服务器的 IP 地址和端口号。</li>
<li><tt class="docutils literal"><span class="pre">SENTINEL</span> <span class="pre">reset</span> <span class="pre">&lt;pattern&gt;</span></tt> ：
重置所有名字和给定模式 <tt class="docutils literal"><span class="pre">pattern</span></tt> 相匹配的主服务器。
<tt class="docutils literal"><span class="pre">pattern</span></tt> 参数是一个 Glob 风格的模式。
重置操作清楚主服务器目前的所有状态，
包括正在执行中的故障转移，
并移除目前已经发现和关联的，
主服务器的所有从服务器和 Sentinel 。</li>
<li><tt class="docutils literal"><span class="pre">SENTINEL</span> <span class="pre">failover</span> <span class="pre">&lt;master</span> <span class="pre">name&gt;</span></tt> ：
当主服务器失效时，
在不询问其他 Sentinel 意见的情况下，
强制开始一次自动故障迁移
（不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。</li>
</ul>
</div>
<div class="section" id="id9">
<h5>发布与订阅信息<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>客户端可以将 Sentinel 看作是一个只提供了订阅功能的 Redis 服务器：
你不可以使用 <a class="reference internal" href="index.html#publish"><em>PUBLISH</em></a> 命令向这个服务器发送信息，
但你可以用 <a class="reference internal" href="index.html#subscribe"><em>SUBSCRIBE</em></a> 命令或者 <a class="reference internal" href="index.html#psubscribe"><em>PSUBSCRIBE</em></a> 命令，
通过订阅给定的频道来获取相应的事件提醒。</p>
<p>一个频道能够接收和这个频道的名字相同的事件。
比如说，
名为 <tt class="docutils literal"><span class="pre">+sdown</span></tt> 的频道就可以接收所有实例进入主观下线（SDOWN）状态的事件。</p>
<p>通过执行 <tt class="docutils literal"><span class="pre">PSUBSCRIBE</span> <span class="pre">*</span></tt> 命令可以接收所有事件信息。</p>
<p>以下列出的是客户端可以通过订阅来获得的频道和信息的格式：
第一个英文单词是频道/事件的名字，
其余的是数据的格式。</p>
<p>注意，
当格式中包含 <tt class="docutils literal"><span class="pre">instance</span> <span class="pre">details</span></tt> 字样时，
表示频道所返回的信息中包含了以下用于识别目标实例的内容：</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;instance-type&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt;
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">&#64;</span></tt> 字符之后的内容用于指定主服务器，
这些内容是可选的，
它们仅在 <tt class="docutils literal"><span class="pre">&#64;</span></tt> 字符之前的内容指定的实例不是主服务器时使用。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">+reset-master</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：主服务器已被重置。</li>
<li><tt class="docutils literal"><span class="pre">+slave</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：一个新的从服务器已经被 Sentinel 识别并关联。</li>
<li><tt class="docutils literal"><span class="pre">+failover-state-reconf-slaves</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：故障转移状态切换到了 <tt class="docutils literal"><span class="pre">reconf-slaves</span></tt> 状态。</li>
<li><tt class="docutils literal"><span class="pre">+failover-detected</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：另一个 Sentinel 开始了一次故障转移操作，或者一个从服务器转换成了主服务器。</li>
<li><tt class="docutils literal"><span class="pre">+slave-reconf-sent</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：领头（leader）的 Sentinel 向实例发送了 <a class="reference internal" href="index.html#slaveof"><em>SLAVEOF</em></a> 命令，为实例设置新的主服务器。</li>
<li><tt class="docutils literal"><span class="pre">+slave-reconf-inprog</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：实例正在将自己设置为指定主服务器的从服务器，但相应的同步过程仍未完成。</li>
<li><tt class="docutils literal"><span class="pre">+slave-reconf-done</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：从服务器已经成功完成对新主服务器的同步。</li>
<li><tt class="docutils literal"><span class="pre">-dup-sentinel</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：对给定主服务器进行监视的一个或多个 Sentinel 已经因为重复出现而被移除 —— 当 Sentinel 实例重启的时候，就会出现这种情况。</li>
<li><tt class="docutils literal"><span class="pre">+sentinel</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：一个监视给定主服务器的新 Sentinel 已经被识别并添加。</li>
<li><tt class="docutils literal"><span class="pre">+sdown</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：给定的实例现在处于主观下线状态。</li>
<li><tt class="docutils literal"><span class="pre">-sdown</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：给定的实例已经不再处于主观下线状态。</li>
<li><tt class="docutils literal"><span class="pre">+odown</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：给定的实例现在处于客观下线状态。</li>
<li><tt class="docutils literal"><span class="pre">-odown</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：给定的实例已经不再处于客观下线状态。</li>
<li><tt class="docutils literal"><span class="pre">+new-epoch</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：当前的纪元（epoch）已经被更新。</li>
<li><tt class="docutils literal"><span class="pre">+try-failover</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：一个新的故障迁移操作正在执行中，等待被大多数 Sentinel 选中（waiting to be elected by the majority）。</li>
<li><tt class="docutils literal"><span class="pre">+elected-leader</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：赢得指定纪元的选举，可以进行故障迁移操作了。</li>
<li><tt class="docutils literal"><span class="pre">+failover-state-select-slave</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：故障转移操作现在处于 <tt class="docutils literal"><span class="pre">select-slave</span></tt> 状态 —— Sentinel 正在寻找可以升级为主服务器的从服务器。</li>
<li><tt class="docutils literal"><span class="pre">no-good-slave</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：Sentinel 操作未能找到适合进行升级的从服务器。Sentinel 会在一段时间之后再次尝试寻找合适的从服务器来进行升级，又或者直接放弃执行故障转移操作。</li>
<li><tt class="docutils literal"><span class="pre">selected-slave</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：Sentinel 顺利找到适合进行升级的从服务器。</li>
<li><tt class="docutils literal"><span class="pre">failover-state-send-slaveof-noone</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：Sentinel 正在将指定的从服务器升级为主服务器，等待升级功能完成。</li>
<li><tt class="docutils literal"><span class="pre">failover-end-for-timeout</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：故障转移因为超时而中止，不过最终所有从服务器都会开始复制新的主服务器（slaves will eventually be configured to replicate with the new master anyway）。</li>
<li><tt class="docutils literal"><span class="pre">failover-end</span> <span class="pre">&lt;instance</span> <span class="pre">details&gt;</span></tt> ：故障转移操作顺利完成。所有从服务器都开始复制新的主服务器了。</li>
<li><tt class="docutils literal"><span class="pre">+switch-master</span> <span class="pre">&lt;master</span> <span class="pre">name&gt;</span> <span class="pre">&lt;oldip&gt;</span> <span class="pre">&lt;oldport&gt;</span> <span class="pre">&lt;newip&gt;</span> <span class="pre">&lt;newport&gt;</span></tt> ：配置变更，主服务器的 IP 和地址已经改变。 <strong>这是绝大多数外部用户都关心的信息。</strong></li>
<li><tt class="docutils literal"><span class="pre">+tilt</span></tt> ：进入 tilt 模式。</li>
<li><tt class="docutils literal"><span class="pre">-tilt</span></tt> ：退出 tilt 模式。</li>
</ul>
</div>
</div>
<div class="section" id="id10">
<h4>故障转移<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>一次故障转移操作由以下步骤组成：</p>
<ul class="simple">
<li>发现主服务器已经进入客观下线状态。</li>
<li>对我们的当前纪元进行自增（详情请参考 <a class="reference external" href="https://www.google.com.hk/search?q=Raft+leader+election&amp;client=ubuntu&amp;channel=cs&amp;oq=Raft+leader+election&amp;aqs=chrome..69i57&amp;sourceid=chrome&amp;ie=UTF-8">Raft leader election</a> ），
并尝试在这个纪元中当选。</li>
<li>如果当选失败，
那么在设定的故障迁移超时时间的两倍之后，
重新尝试当选。
如果当选成功，
那么执行以下步骤。</li>
<li>选出一个从服务器，并将它升级为主服务器。</li>
<li>向被选中的从服务器发送 <tt class="docutils literal"><span class="pre">SLAVEOF</span> <span class="pre">NO</span> <span class="pre">ONE</span></tt> 命令，让它转变为主服务器。</li>
<li>通过发布与订阅功能，
将更新后的配置传播给所有其他 Sentinel ，
其他 Sentinel 对它们自己的配置进行更新。</li>
<li>向已下线主服务器的从服务器发送 <a class="reference internal" href="index.html#slaveof"><em>SLAVEOF</em></a> 命令，
让它们去复制新的主服务器。</li>
<li>当所有从服务器都已经开始复制新的主服务器时，
领头 Sentinel 终止这次故障迁移操作。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">每当一个 Redis 实例被重新配置（reconfigured） ——
无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 ——
Sentinel 都会向被重新配置的实例发送一个 <tt class="docutils literal"><span class="pre">CONFIG</span> <span class="pre">REWRITE</span></tt> 命令，
从而确保这些配置会持久化在硬盘里。</p>
</div>
<p>Sentinel 使用以下规则来选择新的主服务器：</p>
<ul class="simple">
<li>在失效主服务器属下的从服务器当中，
那些被标记为主观下线、已断线、或者最后一次回复 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令的时间大于五秒钟的从服务器都会被淘汰。</li>
<li>在失效主服务器属下的从服务器当中，
那些与失效主服务器连接断开的时长超过 <tt class="docutils literal"><span class="pre">down-after</span></tt> 选项指定的时长十倍的从服务器都会被淘汰。</li>
<li>在经历了以上两轮淘汰之后剩下来的从服务器中，
我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器；
如果复制偏移量不可用，
或者从服务器的复制偏移量相同，
那么带有最小运行 ID 的那个从服务器成为新的主服务器。</li>
</ul>
<div class="section" id="id11">
<h5>Sentinel 自动故障迁移的一致性特质<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ，
从而确保在一个给定的纪元（epoch）里，
只有一个领头产生。</p>
<p>这表示在同一个纪元中，
不会有两个 Sentinel 同时被选中为领头，
并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。</p>
<p>更高的配置纪元总是优于较低的纪元，
因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。</p>
<p>简单来说，
我们可以将 Sentinel 配置看作是一个带有版本号的状态。
一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。</p>
<p>举个例子，
当出现网络分割（<a class="reference external" href="http://en.wikipedia.org/wiki/Network_partition">network partitions</a>）时，
一个 Sentinel 可能会包含了较旧的配置，
而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时，
Sentinel 就会对自己的配置进行更新。</p>
<p>如果要在网络分割出现的情况下仍然保持一致性，
那么应该使用 <tt class="docutils literal"><span class="pre">min-slaves-to-write</span></tt> 选项，
让主服务器在连接的从实例少于给定数量时停止执行写操作，
与此同时，
应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。</p>
</div>
<div class="section" id="id12">
<h5>Sentinel 状态的持久化<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
<p>Sentinel 的状态会被持久化在 Sentinel 配置文件里面。</p>
<p>每当 Sentinel 接收到一个新的配置，
或者当领头 Sentinel 为主服务器创建一个新的配置时，
这个配置会与配置纪元一起被保存到磁盘里面。</p>
<p>这意味着停止和重启 Sentinel 进程都是安全的。</p>
</div>
<div class="section" id="id13">
<h5>Sentinel 在非故障迁移的情况下对实例进行重新配置<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
<p>即使没有自动故障迁移操作在进行，
Sentinel 总会尝试将当前的配置设置到被监视的实例上面。
特别是：</p>
<ul class="simple">
<li>根据当前的配置，
如果一个从服务器被宣告为主服务器，
那么它会代替原有的主服务器，
成为新的主服务器，
并且成为原有主服务器的所有从服务器的复制对象。</li>
<li>那些连接了错误主服务器的从服务器会被重新配置，
使得这些从服务器会去复制正确的主服务器。</li>
</ul>
<p>不过，
在以上这些条件满足之后，
Sentinel 在对实例进行重新配置之前仍然会等待一段足够长的时间，
确保可以接收到其他 Sentinel 发来的配置更新，
从而避免自身因为保存了过期的配置而对实例进行了不必要的重新配置。</p>
</div>
</div>
<div class="section" id="tilt">
<h4>TILT 模式<a class="headerlink" href="#tilt" title="Permalink to this headline">¶</a></h4>
<p>Redis Sentinel 严重依赖计算机的时间功能：
比如说，
为了判断一个实例是否可用，
Sentinel 会记录这个实例最后一次相应 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令的时间，
并将这个时间和当前时间进行对比，
从而知道这个实例有多长时间没有和 Sentinel 进行任何成功通讯。</p>
<p>不过，
一旦计算机的时间功能出现故障，
或者计算机非常忙碌，
又或者进程因为某些原因而被阻塞时，
Sentinel 可能也会跟着出现故障。</p>
<p>TILT 模式是一种特殊的保护模式：
当 Sentinel 发现系统有些不对劲时，
Sentinel 就会进入 TILT 模式。</p>
<p>因为 Sentinel 的时间中断器默认每秒执行 10 次，
所以我们预期时间中断器的两次执行之间的间隔为 100 毫秒左右。
Sentinel 的做法是，
记录上一次时间中断器执行时的时间，
并将它和这一次时间中断器执行的时间进行对比：</p>
<ul class="simple">
<li>如果两次调用时间之间的差距为负值，
或者非常大（超过 2 秒钟），
那么 Sentinel 进入 TILT 模式。</li>
<li>如果 Sentinel 已经进入 TILT 模式，
那么 Sentinel 延迟退出 TILT 模式的时间。</li>
</ul>
<p>当 Sentinel 进入 TILT 模式时，
它仍然会继续监视所有目标，
但是：</p>
<ul class="simple">
<li>它不再执行任何操作，比如故障转移。</li>
<li>当有实例向这个 Sentinel 发送 <tt class="docutils literal"><span class="pre">SENTINEL</span> <span class="pre">is-master-down-by-addr</span></tt> 命令时，
Sentinel 返回负值：
因为这个 Sentinel 所进行的下线判断已经不再准确。</li>
</ul>
<p>如果 TILT 可以正常维持 30 秒钟，
那么 Sentinel 退出 TILT 模式。</p>
</div>
<div class="section" id="busy">
<h4>处理 <tt class="docutils literal"><span class="pre">-BUSY</span></tt> 状态<a class="headerlink" href="#busy" title="Permalink to this headline">¶</a></h4>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">该功能尚未实现</p>
</div>
<p>当 Lua 脚本的运行时间超过指定时限时，
Redis 就会返回 <tt class="docutils literal"><span class="pre">-BUSY</span></tt> 错误。</p>
<p>当出现这种情况时，
Sentinel 在尝试执行故障转移操作之前，
会先向服务器发送一个 <a class="reference internal" href="index.html#script-kill"><em>SCRIPT KILL</em></a> 命令，
如果服务器正在执行的是一个只读脚本的话，
那么这个脚本就会被杀死，
服务器就会回到正常状态。</p>
</div>
<div class="section" id="id14">
<h4>Sentinel 的客户端实现<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>关于 Sentinel 客户端的实现信息可以参考 <a class="reference external" href="http://redis.io/topics/sentinel-clients">Sentinel 客户端指引手册</a> 。</p>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-topic/cluster-tutorial"></span><div class="section" id="cluster-tutorial">
<span id="id1"></span><h3>集群教程<a class="headerlink" href="#cluster-tutorial" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本文档翻译自 <a class="reference external" href="http://redis.io/topics/cluster-tutorial">http://redis.io/topics/cluster-tutorial</a> 。</p>
</div>
<p>本文档是 Redis 集群的入门教程，
从用户的角度介绍了设置、测试和操作集群的方法。</p>
<p>本教程不包含晦涩难懂的分布式概念，
也没有像 <a class="reference internal" href="index.html#cluster-spec"><em>Redis 集群规范</em></a> 那样包含 Redis 集群的实现细节，
如果你打算深入地学习 Redis 集群的部署方法，
那么推荐你在阅读完这个教程之后，
再去看一看集群规范。</p>
<p><strong>Redis 集群目前仍处于 Alpha 测试版本</strong>，
如果在使用过程中发现任何问题，
请到 <a class="reference external" href="https://groups.google.com/forum/?fromgroups#!forum/redis-db">Redis 的邮件列表</a> 发贴，
或者到 <a class="reference external" href="https://github.com/antirez/redis">Redis 的 Github 页面</a> 报告错误。</p>
<div class="section" id="id2">
<h4>集群简介<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群是一个可以<strong>在多个 Redis 节点之间进行数据共享</strong>的设施（installation）。</p>
<p>Redis 集群不支持那些需要同时处理多个键的 Redis 命令，
因为执行这些命令需要在多个 Redis 节点之间移动数据，
并且在高负载的情况下，
这些命令将降低 Redis 集群的性能，
并导致不可预测的行为。</p>
<p>Redis 集群<strong>通过分区（partition）来提供一定程度的可用性</strong>（availability）：
即使集群中有一部分节点失效或者无法进行通讯，
集群也可以继续处理命令请求。</p>
<p>Redis 集群提供了以下两个好处：</p>
<ul class="simple">
<li>将数据自动切分（split）到多个节点的能力。</li>
<li>当集群中的一部分节点失效或者无法进行通讯时，
仍然可以继续处理命令请求的能力。</li>
</ul>
</div>
<div class="section" id="id3">
<h4>Redis 集群数据共享<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现：
一个 Redis 集群包含 <tt class="docutils literal"><span class="pre">16384</span></tt> 个哈希槽（hash slot），
数据库中的每个键都属于这 <tt class="docutils literal"><span class="pre">16384</span></tt> 个哈希槽的其中一个，
集群使用公式 <tt class="docutils literal"><span class="pre">CRC16(key)</span> <span class="pre">%</span> <span class="pre">16384</span></tt> 来计算键 <tt class="docutils literal"><span class="pre">key</span></tt> 属于哪个槽，
其中 <tt class="docutils literal"><span class="pre">CRC16(key)</span></tt> 语句用于计算键 <tt class="docutils literal"><span class="pre">key</span></tt> 的 <a class="reference external" href="http://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">CRC16 校验和</a> 。</p>
<p>集群中的每个节点负责处理一部分哈希槽。
举个例子，
一个集群可以有三个哈希槽，
其中：</p>
<ul class="simple">
<li>节点 A 负责处理 <tt class="docutils literal"><span class="pre">0</span></tt> 号至 <tt class="docutils literal"><span class="pre">5500</span></tt> 号哈希槽。</li>
<li>节点 B 负责处理 <tt class="docutils literal"><span class="pre">5501</span></tt> 号至 <tt class="docutils literal"><span class="pre">11000</span></tt> 号哈希槽。</li>
<li>节点 C 负责处理 <tt class="docutils literal"><span class="pre">11001</span></tt> 号至 <tt class="docutils literal"><span class="pre">16384</span></tt> 号哈希槽。</li>
</ul>
<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。
比如说：</p>
<ul class="simple">
<li>如果用户将新节点 D 添加到集群中，
那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li>
<li>与此类似，
如果用户要从集群中移除节点 A ，
那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ，
然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li>
</ul>
<p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞，
所以无论是添加新节点还是移除已存在节点，
又或者改变某个节点包含的哈希槽数量，
都不会造成集群下线。</p>
</div>
<div class="section" id="id4">
<h4>Redis 集群中的主从复制<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下，
仍然可以正常运作，
Redis 集群对节点使用了主从复制功能：
集群中的每个节点都有 <tt class="docutils literal"><span class="pre">1</span></tt> 个至 <tt class="docutils literal"><span class="pre">N</span></tt> 个复制品（replica），
其中一个复制品为主节点（master），
而其余的 <tt class="docutils literal"><span class="pre">N-1</span></tt> 个复制品为从节点（slave）。</p>
<p>在之前列举的节点 A 、B 、C 的例子中，
如果节点 B 下线了，
那么集群将无法正常运行，
因为集群找不到节点来处理 <tt class="docutils literal"><span class="pre">5501</span></tt> 号至 <tt class="docutils literal"><span class="pre">11000</span></tt> 号的哈希槽。</p>
<p>另一方面，
假如在创建集群的时候（或者至少在节点 B 下线之前），
我们为主节点 B 添加了从节点 B1 ，
那么当主节点 B 下线的时候，
集群就会将 B1 设置为新的主节点，
并让它代替下线的主节点 B ，
继续处理 <tt class="docutils literal"><span class="pre">5501</span></tt> 号至 <tt class="docutils literal"><span class="pre">11000</span></tt> 号的哈希槽，
这样集群就不会因为主节点 B 的下线而无法正常运作了。</p>
<p>不过如果节点 B 和 B1 都下线的话，
Redis 集群还是会停止运作。</p>
</div>
<div class="section" id="redis-guarantee">
<h4>Redis 集群的一致性保证（guarantee）<a class="headerlink" href="#redis-guarantee" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群<strong>不保证数据的强一致性</strong>（strong consistency）：
在特定条件下，
Redis 集群可能会丢失已经被执行过的写命令。</p>
<p>使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因。
考虑以下这个写命令的例子：</p>
<ul class="simple">
<li>客户端向主节点 B 发送一条写命令。</li>
<li>主节点 B 执行写命令，并向客户端返回命令回复。</li>
<li>主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。</li>
</ul>
<p>如你所见，
主节点对命令的复制工作发生在返回命令回复之后，
因为如果每次处理命令请求都需要等待复制操作完成的话，
那么主节点处理命令请求的速度将极大地降低 ——
我们必须在性能和一致性之间做出权衡。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">如果真的有必要的话，
Redis 集群可能会在将来提供同步地（synchronou）执行写命令的方法。</p>
</div>
<p>Redis 集群另外一种可能会丢失命令的情况是，
集群出现网络分裂（<a class="reference external" href="http://en.wikipedia.org/wiki/Network_partition">network partition</a>），
并且一个客户端与至少包括一个主节点在内的少数（minority）实例被孤立。</p>
<p>举个例子，
假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点，
其中 A 、B 、C 为主节点，
而 A1 、B1 、C1 分别为三个主节点的从节点，
另外还有一个客户端 Z1 。</p>
<p>假设集群中发生网络分裂，
那么集群可能会分裂为两方，
大多数（majority）的一方包含节点 A 、C 、A1 、B1 和 C1 ，
而少数（minority）的一方则包含节点 B 和客户端 Z1 。</p>
<p>在网络分裂期间，
主节点 B 仍然会接受 Z1 发送的写命令：</p>
<ul class="simple">
<li>如果网络分裂出现的时间很短，
那么集群会继续正常运行；</li>
<li>但是，
如果网络分裂出现的时间足够长，
使得大多数一方将从节点 B1 设置为新的主节点，
并使用 B1 来代替原来的主节点 B ，
那么 Z1 发送给主节点 B 的写命令将丢失。</li>
</ul>
<p>注意，
在网络分裂出现期间，
客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的，
这一时间限制称为<strong>节点超时时间</strong>（node timeout），
是 Redis 集群的一个重要的配置选项：</p>
<ul class="simple">
<li>对于大多数一方来说，
如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群，
那么集群会将这个主节点视为下线，
并使用从节点来代替这个主节点继续工作。</li>
<li>对于少数一方，
如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群，
那么它将停止处理写命令，
并向客户端报告错误。</li>
</ul>
</div>
<div class="section" id="id5">
<h4>创建并使用 Redis 集群<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群由多个运行在集群模式（cluster mode）下的 Redis 实例组成，
实例的集群模式需要通过配置来开启，
开启集群模式的实例将可以使用集群特有的功能和命令。</p>
<p>以下是一个包含了最少选项的集群配置文件示例：</p>
<div class="highlight-python"><div class="highlight"><pre>port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
</pre></div>
</div>
<p>文件中的 <tt class="docutils literal"><span class="pre">cluster-enabled</span></tt> 选项用于开实例的集群模式，
而 <tt class="docutils literal"><span class="pre">cluster-conf-file</span></tt> 选项则设定了保存节点配置文件的路径，
默认值为 <tt class="docutils literal"><span class="pre">nodes.conf</span></tt> 。</p>
<p>节点配置文件无须人为修改，
它由 Redis 集群在启动时创建，
并在有需要时自动进行更新。</p>
<p><strong>要让集群正常运作至少需要三个主节点</strong>，
不过在刚开始试用集群功能时，
强烈建议使用六个节点：
其中三个为主节点，
而其余三个则是各个主节点的从节点。</p>
<p>首先，
让我们进入一个新目录，
并创建六个以端口号为名字的子目录，
稍后我们在将每个目录中运行一个 Redis 实例：</p>
<div class="highlight-python"><div class="highlight"><pre>mkdir cluster-test
cd cluster-test
mkdir 7000 7001 7002 7003 7004 7005
</pre></div>
</div>
<p>在文件夹 <tt class="docutils literal"><span class="pre">7000</span></tt> 至 <tt class="docutils literal"><span class="pre">7005</span></tt> 中，
各创建一个 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件，
文件的内容可以使用上面的示例配置文件，
但记得将配置中的端口号从 <tt class="docutils literal"><span class="pre">7000</span></tt> 改为与文件夹名字相同的号码。</p>
<p>现在，
从 <a class="reference external" href="https://github.com/antirez/redis">Redis Github 页面</a> 的 <tt class="docutils literal"><span class="pre">unstable</span></tt> 分支中取出最新的 Redis 源码，
编译出可执行文件 <tt class="docutils literal"><span class="pre">redis-server</span></tt> ，
并将文件复制到 <tt class="docutils literal"><span class="pre">cluster-test</span></tt> 文件夹，
然后使用类似以下命令，
在每个标签页中打开一个实例：</p>
<div class="highlight-python"><div class="highlight"><pre>cd 7000
../redis-server ./redis.conf
</pre></div>
</div>
<p>实例打印的日志显示，
因为 <tt class="docutils literal"><span class="pre">nodes.conf</span></tt> 文件不存在，
所以每个节点都为它自身指定了一个新的 ID ：</p>
<div class="highlight-python"><div class="highlight"><pre>[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&#39;m 97a3a64667477371c4479320d683e4c8db5858b1
</pre></div>
</div>
<p>实例会一直使用同一个 ID ，
从而在集群中保持一个独一无二（unique）的名字。</p>
<p>每个节点都使用 ID 而不是 IP 或者端口号来记录其他节点，
因为 IP 地址和端口号都可能会改变，
而这个独一无二的标识符（identifier）则会在节点的整个生命周期中一直保持不变。</p>
<p>我们将这个标识符称为<strong>节点 ID</strong>。</p>
</div>
<div class="section" id="id7">
<h4>创建集群<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>现在我们已经有了六个正在运行中的 Redis 实例，
接下来我们需要使用这些实例来创建集群，
并为每个节点编写配置文件。</p>
<p>通过使用 Redis 集群命令行工具 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> ，
编写节点配置文件的工作可以非常容易地完成：
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 位于 Redis 源码的 <tt class="docutils literal"><span class="pre">src</span></tt> 文件夹中，
它是一个 Ruby 程序，
这个程序通过向实例发送特殊命令来完成创建新集群，
检查集群，
或者对集群进行重新分片（reshared）等工作。</p>
<p>我们需要执行以下命令来创建集群：</p>
<div class="highlight-python"><div class="highlight"><pre>./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \
127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
</pre></div>
</div>
<p>命令的意义如下：</p>
<ul class="simple">
<li>给定 <tt class="docutils literal"><span class="pre">redis-trib.rb</span></tt> 程序的命令是 <tt class="docutils literal"><span class="pre">create</span></tt> ，
这表示我们希望创建一个新的集群。</li>
<li>选项 <tt class="docutils literal"><span class="pre">--replicas</span> <span class="pre">1</span></tt> 表示我们希望为集群中的每个主节点创建一个从节点。</li>
<li>之后跟着的其他参数则是实例的地址列表，
我们希望程序使用这些地址所指示的实例来创建新集群。</li>
</ul>
<p>简单来说，
以上命令的意思就是让 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 程序创建一个包含三个主节点和三个从节点的集群。</p>
<p>接着，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 会打印出一份预想中的配置给你看，
如果你觉得没问题的话，
就可以输入 <tt class="docutils literal"><span class="pre">yes</span></tt> ，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 就会将这份配置应用到集群当中：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Creating</span> <span class="n">cluster</span>
<span class="go">Connecting to node 127.0.0.1:7000: OK</span>
<span class="go">Connecting to node 127.0.0.1:7001: OK</span>
<span class="go">Connecting to node 127.0.0.1:7002: OK</span>
<span class="go">Connecting to node 127.0.0.1:7003: OK</span>
<span class="go">Connecting to node 127.0.0.1:7004: OK</span>
<span class="go">Connecting to node 127.0.0.1:7005: OK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Performing</span> <span class="nb">hash</span> <span class="n">slots</span> <span class="n">allocation</span> <span class="n">on</span> <span class="mi">6</span> <span class="n">nodes</span><span class="o">...</span>
<span class="go">Using 3 masters:</span>
<span class="go">127.0.0.1:7000</span>
<span class="go">127.0.0.1:7001</span>
<span class="go">127.0.0.1:7002</span>
<span class="go">127.0.0.1:7000 replica #1 is 127.0.0.1:7003</span>
<span class="go">127.0.0.1:7001 replica #1 is 127.0.0.1:7004</span>
<span class="go">127.0.0.1:7002 replica #1 is 127.0.0.1:7005</span>
<span class="go">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span>
<span class="go">slots:0-5460 (5461 slots) master</span>
<span class="go">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span>
<span class="go">slots:5461-10921 (5461 slots) master</span>
<span class="go">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span>
<span class="go">slots:10922-16383 (5462 slots) master</span>
<span class="go">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span>
<span class="go">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span>
<span class="go">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span>
<span class="go">Can I set the above configuration? (type &#39;yes&#39; to accept): yes</span>
</pre></div>
</div>
<p>输入 <tt class="docutils literal"><span class="pre">yes</span></tt> 并按下回车确认之后，
集群就会将配置应用到各个节点，
并连接起（join）各个节点 ——
也即是，
让各个节点开始互相通讯：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Nodes</span> <span class="n">configuration</span> <span class="n">updated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sending</span> <span class="n">CLUSTER</span> <span class="n">MEET</span> <span class="n">messages</span> <span class="n">to</span> <span class="n">join</span> <span class="n">the</span> <span class="n">cluster</span>
<span class="go">Waiting for the cluster to join...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Performing</span> <span class="n">Cluster</span> <span class="n">Check</span> <span class="p">(</span><span class="n">using</span> <span class="n">node</span> <span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span><span class="p">:</span><span class="mi">7000</span><span class="p">)</span>
<span class="go">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span>
<span class="go">slots:0-5460 (5461 slots) master</span>
<span class="go">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span>
<span class="go">slots:5461-10921 (5461 slots) master</span>
<span class="go">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span>
<span class="go">slots:10922-16383 (5462 slots) master</span>
<span class="go">M: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span>
<span class="go">slots: (0 slots) master</span>
<span class="go">M: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span>
<span class="go">slots: (0 slots) master</span>
<span class="go">M: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span>
<span class="go">slots: (0 slots) master</span>
<span class="go">[OK] All nodes agree about slots configuration.</span>
</pre></div>
</div>
<p>如果一切正常的话，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 将输出以下信息：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Check</span> <span class="k">for</span> <span class="nb">open</span> <span class="n">slots</span><span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Check</span> <span class="n">slots</span> <span class="n">coverage</span><span class="o">...</span>
<span class="go">[OK] All 16384 slots covered.</span>
</pre></div>
</div>
<p>这表示集群中的 <tt class="docutils literal"><span class="pre">16384</span></tt> 个槽都有至少一个主节点在处理，
集群运作正常。</p>
</div>
<div class="section" id="id8">
<h4>集群的客户端<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群现阶段的一个问题是客户端实现很少。
以下是一些我知道的实现：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">redis-rb-cluster</span></tt> 是我（&#64;antirez）编写的 Ruby 实现，
用于作为其他实现的参考。
该实现是对 <tt class="docutils literal"><span class="pre">redis-rb</span></tt> 的一个简单包装，
高效地实现了与集群进行通讯所需的最少语义（semantic）。</li>
<li><tt class="docutils literal"><span class="pre">redis-py-cluster</span></tt> 看上去是 <tt class="docutils literal"><span class="pre">redis-rb-cluster</span></tt> 的一个 Python 版本，
这个项目有一段时间没有更新了（最后一次提交是在六个月之前），
不过可以将这个项目用作学习集群的起点。</li>
<li>流行的 Predis 曾经对早期的 Redis 集群有过一定的支持，
但我不确定它对集群的支持是否完整，
也不清楚它是否和最新版本的 Redis 集群兼容
（因为新版的 Redis 集群将槽的数量从 4k 改为 16k 了）。</li>
<li>Redis <tt class="docutils literal"><span class="pre">unstable</span></tt> 分支中的 <tt class="docutils literal"><span class="pre">redis-cli</span></tt> 程序实现了非常基本的集群支持，
可以使用命令 <tt class="docutils literal"><span class="pre">redis-cli</span> <span class="pre">-c</span></tt> 来启动。</li>
</ul>
<p>测试 Redis 集群比较简单的办法就是使用 <tt class="docutils literal"><span class="pre">redis-rb-cluster</span></tt> 或者 <tt class="docutils literal"><span class="pre">redis-cli</span></tt> ，
接下来我们将使用 <tt class="docutils literal"><span class="pre">redis-cli</span></tt> 为例来进行演示：</p>
<div class="highlight-python"><div class="highlight"><pre>$ redis-cli -c -p 7000
redis 127.0.0.1:7000&gt; set foo bar
-&gt; Redirected to slot [12182] located at 127.0.0.1:7002
OK

redis 127.0.0.1:7002&gt; set hello world
-&gt; Redirected to slot [866] located at 127.0.0.1:7000
OK

redis 127.0.0.1:7000&gt; get foo
-&gt; Redirected to slot [12182] located at 127.0.0.1:7002
&quot;bar&quot;

redis 127.0.0.1:7000&gt; get hello
-&gt; Redirected to slot [866] located at 127.0.0.1:7000
&quot;world&quot;
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">redis-cli</span></tt> 对集群的支持是非常基本的，
所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。</p>
<p>一个真正的（serious）集群客户端应该做得比这更好：
它应该用缓存记录起哈希槽与节点地址之间的映射（map），
从而直接将命令发送到正确的节点上面。</p>
<p>这种映射只会在集群的配置出现某些修改时变化，
比如说，
在一次故障转移（failover）之后，
或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后，
诸如此类。</p>
</div>
<div class="section" id="redis-rb-cluster">
<h4>使用 <tt class="docutils literal"><span class="pre">redis-rb-cluster</span></tt> 编写一个示例应用<a class="headerlink" href="#redis-rb-cluster" title="Permalink to this headline">¶</a></h4>
<p>在展示如何使用集群进行故障转移、重新分片等操作之前，
我们需要创建一个示例应用，
了解一些与 Redis 集群客户端进行交互的基本方法。</p>
<p>在运行示例应用的过程中，
我们会尝试让节点进入失效状态，
又或者开始一次重新分片，
以此来观察 Redis 集群在真实世界运行时的表现，
并且为了让这个示例尽可能地有用，
我们会让这个应用向集群进行写操作。</p>
<p>本节将通过两个示例应用来展示 <tt class="docutils literal"><span class="pre">redis-rb-cluster</span></tt> 的基本用法，
以下是本节的第一个示例应用，
它是一个名为 <a class="reference external" href="https://github.com/antirez/redis-rb-cluster/blob/master/cluster.rb">example.rb</a> 的文件，
包含在<a class="reference external" href="https://github.com/antirez/redis-rb-cluster">redis-rb-cluster 项目里面</a>：</p>
<div class="highlight-ruby"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;./cluster&#39;</span>

<span class="n">startup_nodes</span> <span class="o">=</span> <span class="o">[</span>
    <span class="p">{</span><span class="ss">:host</span> <span class="o">=&gt;</span> <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="ss">:port</span> <span class="o">=&gt;</span> <span class="mi">7000</span><span class="p">},</span>
    <span class="p">{</span><span class="ss">:host</span> <span class="o">=&gt;</span> <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="ss">:port</span> <span class="o">=&gt;</span> <span class="mi">7001</span><span class="p">}</span>
<span class="o">]</span>
<span class="n">rc</span> <span class="o">=</span> <span class="no">RedisCluster</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">startup_nodes</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="ss">:timeout</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>

<span class="n">last</span> <span class="o">=</span> <span class="kp">false</span>

<span class="k">while</span> <span class="ow">not</span> <span class="n">last</span>
    <span class="k">begin</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;__last__&quot;</span><span class="p">)</span>
        <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="o">!</span><span class="n">last</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
        <span class="nb">puts</span> <span class="s2">&quot;error </span><span class="si">#{</span><span class="n">e</span><span class="o">.</span><span class="n">to_s</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="nb">sleep</span> <span class="mi">1</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="p">((</span><span class="n">last</span><span class="o">.</span><span class="n">to_i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">.</span><span class="mi">1000000000</span><span class="p">)</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="k">begin</span>
        <span class="n">rc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;foo</span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
        <span class="nb">puts</span> <span class="n">rc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;foo</span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;__last__&quot;</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
        <span class="nb">puts</span> <span class="s2">&quot;error </span><span class="si">#{</span><span class="n">e</span><span class="o">.</span><span class="n">to_s</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">end</span>
    <span class="nb">sleep</span> <span class="mi">0</span><span class="o">.</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>这个应用所做的工作非常简单：
它不断地以 <tt class="docutils literal"><span class="pre">foo&lt;number&gt;</span></tt> 为键，
<tt class="docutils literal"><span class="pre">number</span></tt> 为值，
使用 <a class="reference internal" href="index.html#set"><em>SET</em></a> 命令向数据库设置键值对。</p>
<p>如果我们执行这个应用的话，
应用将按顺序执行以下命令：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SET</span> <span class="pre">foo0</span> <span class="pre">0</span></tt></li>
<li><tt class="docutils literal"><span class="pre">SET</span> <span class="pre">foo1</span> <span class="pre">1</span></tt></li>
<li><tt class="docutils literal"><span class="pre">SET</span> <span class="pre">foo2</span> <span class="pre">2</span></tt></li>
<li>诸如此类。。。</li>
</ul>
<p>代码中的每个集群操作都使用一个 <tt class="docutils literal"><span class="pre">begin</span></tt> 和 <tt class="docutils literal"><span class="pre">rescue</span></tt> 代码块（block）包裹着，
因为我们希望在代码出错时，
将错误打印到终端上面，
而不希望应用因为异常（exception）而退出。</p>
<p>代码的<strong>第七行</strong>是代码中第一个有趣的地方，
它创建了一个 Redis 集群对象，
其中创建对象所使用的参数及其意义如下：</p>
<ul class="simple">
<li>第一个参数是记录了启动节点的 <tt class="docutils literal"><span class="pre">startup_nodes</span></tt> 列表，
列表中包含了两个集群节点的地址。</li>
<li>第二个参数指定了对于集群中的各个不同的节点，
Redis 集群对象可以获得（take）的最大连接数
（maximum number of connections this object is allowed to take）。</li>
<li>第三个参数 <tt class="docutils literal"><span class="pre">timeout</span></tt> 指定了一个命令在执行多久之后，
才会被看作是执行失败。</li>
</ul>
<p>记住，
启动列表中并不需要包含所有集群节点的地址，
但这些地址中至少要有一个是有效的（reachable）：
一旦 <tt class="docutils literal"><span class="pre">redis-rb-cluster</span></tt> 成功连接上集群中的某个节点时，
集群节点列表就会被自动更新，
任何真正的（serious）的集群客户端都应该这样做。</p>
<p>现在，
程序创建的 Redis 集群对象实例被保存到 <tt class="docutils literal"><span class="pre">rc</span></tt> 变量里面，
我们可以将这个对象当作普通 Redis 对象实例来使用。</p>
<p>在<strong>十一至十九行</strong>，
我们先尝试阅读计数器中的值，
如果计数器不存在的话，
我们才将计数器初始化为 <tt class="docutils literal"><span class="pre">0</span></tt> ：
通过将计数值保存到 Redis 的计数器里面，
我们可以在示例重启之后，
仍然继续之前的执行过程，
而不必每次重启之后都从 <tt class="docutils literal"><span class="pre">foo0</span></tt> 开始重新设置键值对。</p>
<p>为了让程序在集群下线的情况下，
仍然不断地尝试读取计数器的值，
我们将读取操作包含在了一个 <tt class="docutils literal"><span class="pre">while</span></tt> 循环里面，
一般的应用程序并不需要如此小心。</p>
<p><strong>二十一至三十行</strong>是程序的主循环，
这个循环负责设置键值对，
并在设置出错时打印错误信息。</p>
<p>程序在主循环的末尾添加了一个 <tt class="docutils literal"><span class="pre">sleep</span></tt> 调用，
让写操作的执行速度变慢，
帮助执行示例的人更容易看清程序的输出。</p>
<p>执行 <tt class="docutils literal"><span class="pre">example.rb</span></tt> 程序将产生以下输出：</p>
<div class="highlight-python"><div class="highlight"><pre>ruby ./example.rb
1
2
3
4
5
6
7
8
9
...
</pre></div>
</div>
<p>这个程序并不是十分有趣，
稍后我们就会看到一个更有趣的集群应用示例，
不过在此之前，
让我们先使用这个示例来演示集群的重新分片操作。</p>
</div>
<div class="section" id="id10">
<h4>对集群进行重新分片<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>现在，
让我们来试试对集群进行重新分片操作。</p>
<p>在执行重新分片的过程中，
请让你的 <tt class="docutils literal"><span class="pre">example.rb</span></tt> 程序处于运行状态，
这样你就会看到，
重新分片并不会对正在运行的集群程序产生任何影响，
你也可以考虑将 <tt class="docutils literal"><span class="pre">example.rb</span></tt> 中的 <tt class="docutils literal"><span class="pre">sleep</span></tt> 调用删掉，
从而让重新分片操作在近乎真实的写负载下执行。</p>
<p>重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面，
和创建集群一样，
重新分片也可以使用 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 程序来执行。</p>
<p>执行以下命令可以开始一次重新分片操作：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-trib.rb reshard 127.0.0.1:7000
</pre></div>
</div>
<p>你只需要指定集群中其中一个节点的地址，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 就会自动找到集群中的其他节点。</p>
<p>目前 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 只能在管理员的协助下完成重新分片的工作，
要让 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 自动将哈希槽从一个节点移动到另一个节点，
目前来说还做不到
（不过实现这个功能并不难）。</p>
<p>执行 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 的第一步就是设定你打算移动的哈希槽的数量：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-trib.rb reshard 127.0.0.1:7000
Connecting to node 127.0.0.1:7000: OK
Connecting to node 127.0.0.1:7002: OK
Connecting to node 127.0.0.1:7005: OK
Connecting to node 127.0.0.1:7001: OK
Connecting to node 127.0.0.1:7003: OK
Connecting to node 127.0.0.1:7004: OK
&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)
M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000
slots:0-5460 (5461 slots) master
M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002
slots:10922-16383 (5462 slots) master
S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005
slots: (0 slots) slave
M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001
slots:5461-10921 (5461 slots) master
S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003
slots: (0 slots) slave
S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004
slots: (0 slots) slave
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
How many slots do you want to move (from 1 to 16384)? 1000
</pre></div>
</div>
<p>我们将打算移动的槽数量设置为 <tt class="docutils literal"><span class="pre">1000</span></tt> 个，
如果 <tt class="docutils literal"><span class="pre">example.rb</span></tt> 程序一直运行着的话，
现在 <tt class="docutils literal"><span class="pre">1000</span></tt> 个槽里面应该有不少键了。</p>
<p>除了移动的哈希槽数量之外，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 还需要知道重新分片的目标（target node），
也即是，
负责接收这 <tt class="docutils literal"><span class="pre">1000</span></tt> 个哈希槽的节点。</p>
<p>指定目标需要使用节点的 ID ，
而不是 IP 地址和端口。
比如说，
我们打算使用集群的第一个主节点来作为目标，
它的 IP 地址和端口是 <tt class="docutils literal"><span class="pre">127.0.0.1:7000</span></tt> ，
而节点 ID 则是 <tt class="docutils literal"><span class="pre">9991306f0e50640a5684f1958fd754b38fa034c9</span></tt> ，
那么我们应该向 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 提供节点的 ID ：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-trib.rb reshard 127.0.0.1:7000
...
What is the receiving node ID? 9991306f0e50640a5684f1958fd754b38fa034c9
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><tt class="docutils literal"><span class="pre">redis-trib</span></tt> 会打印出集群中所有节点的 ID ，
并且我们也可以通过执行以下命令来获得节点的运行 ID ：</p>
<div class="last highlight-python"><div class="highlight"><pre>$ ./redis-cli -p 7000 cluster nodes | grep myself
9991306f0e50640a5684f1958fd754b38fa034c9 :0 myself,master - 0 0 0 connected 0-5460
</pre></div>
</div>
</div>
<p>接着，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 会向你询问重新分片的源节点（source node），
也即是，
要从哪个节点中取出 <tt class="docutils literal"><span class="pre">1000</span></tt> 个哈希槽，
并将这些槽移动到目标节点上面。</p>
<p>如果我们不打算从特定的节点上取出指定数量的哈希槽，
那么可以向 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 输入 <tt class="docutils literal"><span class="pre">all</span></tt> ，
这样的话，
集群中的所有主节点都会成为源节点，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 将从各个源节点中各取出一部分哈希槽，
凑够 <tt class="docutils literal"><span class="pre">1000</span></tt> 个，
然后移动到目标节点上面：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-trib.rb reshard 127.0.0.1:7000
...
Please enter all the source node IDs.
Type &#39;all&#39; to use all the nodes as source nodes for the hash slots.
Type &#39;done&#39; once you entered all the source nodes IDs.
Source node #1:all
</pre></div>
</div>
<p>输入 <tt class="docutils literal"><span class="pre">all</span></tt> 并按下回车之后，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 将打印出哈希槽的移动计划，
如果你觉得没问题的话，
就可以输入 <tt class="docutils literal"><span class="pre">yes</span></tt> 并再次按下回车：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-trib.rb reshard 127.0.0.1:7000
...
Moving slot 11421 from 393c6df5eb4b4cec323f0e4ca961c8b256e3460a
Moving slot 11422 from 393c6df5eb4b4cec323f0e4ca961c8b256e3460a
Moving slot 5461 from e68e52cee0550f558b03b342f2f0354d2b8a083b
Moving slot 5469 from e68e52cee0550f558b03b342f2f0354d2b8a083b
...
Moving slot 5959 from e68e52cee0550f558b03b342f2f0354d2b8a083b
Do you want to proceed with the proposed reshard plan (yes/no)? yes
</pre></div>
</div>
<p>输入 <tt class="docutils literal"><span class="pre">yes</span></tt> 并使用按下回车之后，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 就会正式开始执行重新分片操作，
将指定的哈希槽从源节点一个个地移动到目标节点上面：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-trib.rb reshard 127.0.0.1:7000
...
Moving slot 5934 from 127.0.0.1:7001 to 127.0.0.1:7000:
Moving slot 5935 from 127.0.0.1:7001 to 127.0.0.1:7000:
Moving slot 5936 from 127.0.0.1:7001 to 127.0.0.1:7000:
Moving slot 5937 from 127.0.0.1:7001 to 127.0.0.1:7000:
...
Moving slot 5959 from 127.0.0.1:7001 to 127.0.0.1:7000:
</pre></div>
</div>
<p>在重新分片的过程中，
<tt class="docutils literal"><span class="pre">example.rb</span></tt> 应该可以继续正常运行，
不会出现任何问题。</p>
<p>在重新分片操作执行完毕之后，
可以使用以下命令来检查集群是否正常：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./redis-trib.rb check 127.0.0.1:7000
Connecting to node 127.0.0.1:7000: OK
Connecting to node 127.0.0.1:7002: OK
Connecting to node 127.0.0.1:7005: OK
Connecting to node 127.0.0.1:7001: OK
Connecting to node 127.0.0.1:7003: OK
Connecting to node 127.0.0.1:7004: OK
&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)
M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000
slots:0-5959,10922-11422 (6461 slots) master
M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002
slots:11423-16383 (4961 slots) master
S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005
slots: (0 slots) slave
M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001
slots:5960-10921 (4962 slots) master
S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003
slots: (0 slots) slave
S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004
slots: (0 slots) slave
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</pre></div>
</div>
<p>根据检查结果显示，
集群运作正常。</p>
<p>需要注意的就是，
在三个主节点中，
节点 <tt class="docutils literal"><span class="pre">127.0.0.1:7000</span></tt> 包含了 <tt class="docutils literal"><span class="pre">6461</span></tt> 个哈希槽，
而节点 <tt class="docutils literal"><span class="pre">127.0.0.1:7001</span></tt> 和节点 <tt class="docutils literal"><span class="pre">127.0.0.1:7002</span></tt> 都只包含了 <tt class="docutils literal"><span class="pre">4961</span></tt> 个哈希槽，
因为后两者都将自己的 <tt class="docutils literal"><span class="pre">500</span></tt> 个哈希槽移动到了节点 <tt class="docutils literal"><span class="pre">127.0.0.1:7000</span></tt> 。</p>
</div>
<div class="section" id="id11">
<h4>一个更有趣的示例应用<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>我们在前面使用的示例程序 <tt class="docutils literal"><span class="pre">example.rb</span></tt> 并不是十分有趣，
因为它只是不断地对集群进行写入，
但并不检查写入结果是否正确。
比如说，
集群可能会错误地将 <tt class="docutils literal"><span class="pre">example.rb</span></tt> 发送的所有 <a class="reference internal" href="index.html#set"><em>SET</em></a> 命令都改成了 <tt class="docutils literal"><span class="pre">SET</span> <span class="pre">foo</span> <span class="pre">42</span></tt> ，
但因为 <tt class="docutils literal"><span class="pre">example.rb</span></tt> 并不检查写入后的值，
所以它不会意识到集群实际上写入的值是错误的。</p>
<p>因为这个原因，
<a class="reference external" href="https://github.com/antirez/redis-rb-cluster">redis-rb-cluster 项目</a>包含了一个名为 <a class="reference external" href="https://github.com/antirez/redis-rb-cluster/blob/master/consistency-test.rb">consistency-test.rb</a> 的示例应用，
这个应用比起 <tt class="docutils literal"><span class="pre">example.rb</span></tt> 有趣得多：
它创建了多个计数器（默认为 <tt class="docutils literal"><span class="pre">1000</span></tt> 个），
并通过发送 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令来增加这些计数器的值。</p>
<p>在增加计数器值的同时，
<tt class="docutils literal"><span class="pre">consistency-test.rb</span></tt> 还执行以下操作：</p>
<ul class="simple">
<li>每次使用 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令更新一个计数器时，
应用会记录下计数器执行 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令之后应该有的值。
举个例子，
如果计数器的起始值为 <tt class="docutils literal"><span class="pre">0</span></tt> ，
而这次是程序第 <tt class="docutils literal"><span class="pre">50</span></tt> 次向它发送 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令，
那么计数器的值应该是 <tt class="docutils literal"><span class="pre">50</span></tt> 。</li>
<li>在每次发送 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令之前，
程序会随机从集群中读取一个计数器的值，
并将它与自己记录的值进行对比，
看两个值是否相同。</li>
</ul>
<p>换句话说，
这个程序是一个一致性检查器（consistency checker）：
如果集群在执行 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令的过程中，
丢失了某条 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令，
又或者多执行了某条客户端没有确认到的 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令，
那么检查器将察觉到这一点 ——
在前一种情况中，
<tt class="docutils literal"><span class="pre">consistency-test.rb</span></tt> 记录的计数器值将比集群记录的计数器值要大；
而在后一种情况中，
<tt class="docutils literal"><span class="pre">consistency-test.rb</span></tt> 记录的计数器值将比集群记录的计数器值要小。</p>
<p>运行 <tt class="docutils literal"><span class="pre">consistency-test</span></tt> 程序将产生类似以下的输出：</p>
<div class="highlight-python"><div class="highlight"><pre>$ ruby consistency-test.rb
925 R (0 err) | 925 W (0 err) |
5030 R (0 err) | 5030 W (0 err) |
9261 R (0 err) | 9261 W (0 err) |
13517 R (0 err) | 13517 W (0 err) |
17780 R (0 err) | 17780 W (0 err) |
22025 R (0 err) | 22025 W (0 err) |
25818 R (0 err) | 25818 W (0 err) |
</pre></div>
</div>
<p>每行输出都打印了程序执行的读取次数和写入次数，
以及执行操作的过程中因为集群不可用而产生的错误数。</p>
<p>如果程序察觉了不一致的情况出现，
它将在输出行的末尾显式不一致的详细情况。</p>
<p>比如说，
如果我们在 <tt class="docutils literal"><span class="pre">consistency-test.rb</span></tt> 运行的过程中，
手动修改某个计数器的值：</p>
<div class="highlight-python"><div class="highlight"><pre>$ redis 127.0.0.1:7000&gt; set key_217 0
OK
</pre></div>
</div>
<p>那么 <tt class="docutils literal"><span class="pre">consistency-test.rb</span></tt> 将向我们报告不一致情况：</p>
<div class="highlight-python"><div class="highlight"><pre>(in the other tab I see...)

94774 R (0 err) | 94774 W (0 err) |
98821 R (0 err) | 98821 W (0 err) |
102886 R (0 err) | 102886 W (0 err) | 114 lost |
107046 R (0 err) | 107046 W (0 err) | 114 lost |
</pre></div>
</div>
<p>在我们修改计数器值的时候，
计数器的正确值是 <tt class="docutils literal"><span class="pre">114</span></tt> （执行了 <tt class="docutils literal"><span class="pre">114</span></tt> 次 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令），
因为我们将计数器的值设成了 <tt class="docutils literal"><span class="pre">0</span></tt> ，
所以 <tt class="docutils literal"><span class="pre">consistency-test.rb</span></tt> 会向我们报告说丢失了 <tt class="docutils literal"><span class="pre">114</span></tt> 个 <a class="reference internal" href="index.html#incr"><em>INCR</em></a> 命令。</p>
<p>因为这个示例程序具有一致性检查功能，
所以我们用它来测试 Redis 集群的故障转移操作。</p>
</div>
<div class="section" id="id13">
<h4>故障转移测试<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在执行本节操作的过程中，
请一直运行 <tt class="docutils literal"><span class="pre">consistency-test</span></tt> 程序。</p>
</div>
<p>要触发一次故障转移，
最简单的办法就是令集群中的某个主节点进入下线状态。</p>
<p>首先用以下命令列出集群中的所有主节点：</p>
<div class="highlight-python"><div class="highlight"><pre>$ redis-cli -p 7000 cluster nodes | grep master
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383
97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422
</pre></div>
</div>
<p>通过命令输出，
我们知道端口号为 <tt class="docutils literal"><span class="pre">7000</span></tt> 、 <tt class="docutils literal"><span class="pre">7001</span></tt> 和 <tt class="docutils literal"><span class="pre">7002</span></tt> 的节点都是主节点，
然后我们可以通过向端口号为 <tt class="docutils literal"><span class="pre">7002</span></tt> 的主节点发送 <a class="reference internal" href="index.html#debug-segfault"><em>DEBUG SEGFAULT</em></a> 命令，
让这个主节点崩溃：</p>
<div class="highlight-python"><div class="highlight"><pre>$ redis-cli -p 7002 debug segfault
Error: Server closed the connection
</pre></div>
</div>
<p>现在，
切换到运行着 <tt class="docutils literal"><span class="pre">consistency-test</span></tt> 的标签页，
可以看到，
<tt class="docutils literal"><span class="pre">consistency-test</span></tt> 在 <tt class="docutils literal"><span class="pre">7002</span></tt> 下线之后的一段时间里将产生大量的错误警告信息：</p>
<div class="highlight-python"><div class="highlight"><pre>18849 R (0 err) | 18849 W (0 err) |
23151 R (0 err) | 23151 W (0 err) |
27302 R (0 err) | 27302 W (0 err) |

... many error warnings here ...

29659 R (578 err) | 29660 W (577 err) |
33749 R (578 err) | 33750 W (577 err) |
37918 R (578 err) | 37919 W (577 err) |
42077 R (578 err) | 42078 W (577 err) |
</pre></div>
</div>
<p>从 <tt class="docutils literal"><span class="pre">consistency-test</span></tt> 的这段输出可以看到，
集群在执行故障转移期间，
总共丢失了 <tt class="docutils literal"><span class="pre">578</span></tt> 个读命令和 <tt class="docutils literal"><span class="pre">577</span></tt> 个写命令，
但是并没有产生任何数据不一致。</p>
<p>这听上去可能有点奇怪，
因为在教程的开头我们提到过，
Redis 使用的是异步复制，
在执行故障转移期间，
集群可能会丢失写命令。</p>
<p>但是在实际上，
丢失命令的情况并不常见，
因为 Redis 几乎是同时执行将命令回复发送给客户端，
以及将命令复制给从节点这两个操作，
所以实际上造成命令丢失的时间窗口是非常小的。</p>
<p>不过，
尽管出现的几率不高，
但丢失命令的情况还是有可能会出现的，
所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。</p>
<p>现在，
让我们使用 <tt class="docutils literal"><span class="pre">cluster</span> <span class="pre">nodes</span></tt> 命令，
查看集群在执行故障转移操作之后，
主从节点的布局情况：</p>
<div class="highlight-python"><div class="highlight"><pre>$ redis-cli -p 7000 cluster nodes
3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected
a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected
97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422
3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected
</pre></div>
</div>
<p>我重启了之前下线的 <tt class="docutils literal"><span class="pre">127.0.0.1:7002</span></tt> 节点，
该节点已经从原来的主节点变成了从节点，
而现在集群中的三个主节点分别是 <tt class="docutils literal"><span class="pre">127.0.0.1:7000</span></tt> 、 <tt class="docutils literal"><span class="pre">127.0.0.1:7001</span></tt> 和 <tt class="docutils literal"><span class="pre">127.0.0.1:7005</span></tt> ，
其中 <tt class="docutils literal"><span class="pre">127.0.0.1:7005</span></tt> 就是因为 <tt class="docutils literal"><span class="pre">127.0.0.1:7002</span></tt> 下线而变成主节点的。</p>
<p><tt class="docutils literal"><span class="pre">cluster</span> <span class="pre">nodes</span></tt> 命令的输出有点儿复杂，
它的每一行都是由以下信息组成的：</p>
<ul class="simple">
<li>节点 ID ：例如 <tt class="docutils literal"><span class="pre">3fc783611028b1707fd65345e763befb36454d73</span></tt> 。</li>
<li><tt class="docutils literal"><span class="pre">ip:port</span></tt> ：节点的 IP 地址和端口号，
例如 <tt class="docutils literal"><span class="pre">127.0.0.1:7000</span></tt> ，
其中 <tt class="docutils literal"><span class="pre">:0</span></tt> 表示的是客户端当前连接的 IP 地址和端口号。</li>
<li><tt class="docutils literal"><span class="pre">flags</span></tt> ：节点的角色（例如 <tt class="docutils literal"><span class="pre">master</span></tt> 、 <tt class="docutils literal"><span class="pre">slave</span></tt> 、 <tt class="docutils literal"><span class="pre">myself</span></tt> ）以及状态（例如 <tt class="docutils literal"><span class="pre">fail</span></tt> ，等等）。</li>
<li>如果节点是一个从节点的话，
那么跟在 <tt class="docutils literal"><span class="pre">flags</span></tt> 之后的将是主节点的节点 ID ：
例如 <tt class="docutils literal"><span class="pre">127.0.0.1:7002</span></tt> 的主节点的节点 ID 就是 <tt class="docutils literal"><span class="pre">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span></tt> 。</li>
<li>集群最近一次向节点发送 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令之后，
过去了多长时间还没接到回复。</li>
<li>节点最近一次返回 <tt class="docutils literal"><span class="pre">PONG</span></tt> 回复的时间。</li>
<li>节点的配置纪元（configuration epoch）：详细信息请参考 <a class="reference internal" href="index.html#cluster-spec"><em>Redis 集群规范</em></a> 。</li>
<li>本节点的网络连接情况：例如 <tt class="docutils literal"><span class="pre">connected</span></tt> 。</li>
<li>节点目前包含的槽：例如 <tt class="docutils literal"><span class="pre">127.0.0.1:7001</span></tt> 目前包含号码为 <tt class="docutils literal"><span class="pre">5960</span></tt> 至 <tt class="docutils literal"><span class="pre">10921</span></tt> 的哈希槽。</li>
</ul>
</div>
<div class="section" id="id14">
<h4>添加新节点到集群<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>根据新添加节点的种类，
我们需要用两种方法来将新节点添加到集群里面：</p>
<ul class="simple">
<li>如果要添加的新节点是一个主节点，
那么我们需要创建一个空节点（empty node），
然后将某些哈希桶移动到这个空节点里面。</li>
<li>另一方面，
如果要添加的新节点是一个从节点，
那么我们需要将这个新节点设置为集群中某个节点的复制品（replica）。</li>
</ul>
<p>本节将对以上两种情况进行介绍，
首先介绍主节点的添加方法，
然后再介绍从节点的添加方法。</p>
<p>无论添加的是那种节点，
第一步要做的总是添加一个空节点。</p>
<p>我们可以继续使用之前启动 <tt class="docutils literal"><span class="pre">127.0.0.1:7000</span></tt> 、 <tt class="docutils literal"><span class="pre">127.0.0.1:7001</span></tt> 等节点的方法，
创建一个端口号为 <tt class="docutils literal"><span class="pre">7006</span></tt> 的新节点，
使用的配置文件也和之前一样，
只是记得要将配置中的端口号改为 <tt class="docutils literal"><span class="pre">7000</span></tt> 。</p>
<p>以下是启动端口号为 <tt class="docutils literal"><span class="pre">7006</span></tt> 的新节点的详细步骤：</p>
<ol class="arabic simple">
<li>在终端里创建一个新的标签页。</li>
<li>进入 <tt class="docutils literal"><span class="pre">cluster-test</span></tt> 文件夹。</li>
<li>创建并进入 <tt class="docutils literal"><span class="pre">7006</span></tt> 文件夹。</li>
<li>将 <tt class="docutils literal"><span class="pre">redis.conf</span></tt> 文件复制到 <tt class="docutils literal"><span class="pre">7006</span></tt> 文件夹里面，然后将配置中的端口号选项改为 <tt class="docutils literal"><span class="pre">7006</span></tt> 。</li>
<li>使用命令 <tt class="docutils literal"><span class="pre">../../redis-server</span> <span class="pre">redis.conf</span></tt> 启动节点。</li>
</ol>
<p>如果一切正常，
那么节点应该会正确地启动。</p>
<p>接下来，
执行以下命令，
将这个新节点添加到集群里面：</p>
<div class="highlight-python"><div class="highlight"><pre>./redis-trib.rb addnode 127.0.0.1:7006 127.0.0.1:7000
</pre></div>
</div>
<p>命令中的 <tt class="docutils literal"><span class="pre">addnode</span></tt> 表示我们要让 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 将一个节点添加到集群里面，
<tt class="docutils literal"><span class="pre">addnode</span></tt> 之后跟着的是新节点的 IP 地址和端口号，
再之后跟着的是集群中任意一个已存在节点的 IP 地址和端口号，
这里我们使用的是 <tt class="docutils literal"><span class="pre">127.0.0.1:7000</span></tt> 。</p>
<p>通过 <tt class="docutils literal"><span class="pre">cluster</span> <span class="pre">nodes</span></tt> 命令，
我们可以确认新节点 <tt class="docutils literal"><span class="pre">127.0.0.1:7006</span></tt> 已经被添加到集群里面了：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:7006&gt; cluster nodes
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921
3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected
f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected
a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected
97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422
3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383
</pre></div>
</div>
<p>新节点现在已经连接上了集群，
成为集群的一份子，
并且可以对客户端的命令请求进行转向了，
但是和其他主节点相比，
新节点还有两点区别：</p>
<ul class="simple">
<li>新节点没有包含任何数据，
因为它没有包含任何哈希桶。</li>
<li>尽管新节点没有包含任何哈希桶，
但它仍然是一个主节点，
所以在集群需要将某个从节点升级为新的主节点时，
这个新节点不会被选中。</li>
</ul>
<p>接下来，
只要使用 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 程序，
将集群中的某些哈希桶移动到新节点里面，
新节点就会成为真正的主节点了。</p>
<p>因为使用 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 移动哈希桶的方法在前面已经介绍过，
所以这里就不再重复介绍了。</p>
<p>现在，
让我们来看看，
将一个新节点转变为某个主节点的复制品（也即是从节点）的方法。</p>
<p>举个例子，
如果我们打算让新节点成为 <tt class="docutils literal"><span class="pre">127.0.0.1:7005</span></tt> 的从节点，
那么我们只要用客户端连接上新节点，
然后执行以下命令就可以了：</p>
<div class="highlight-python"><div class="highlight"><pre>redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
</pre></div>
</div>
<p>其中命令提供的 <tt class="docutils literal"><span class="pre">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span></tt> 就是主节点 <tt class="docutils literal"><span class="pre">127.0.0.1:7005</span></tt> 的节点 ID 。</p>
<p>执行 <tt class="docutils literal"><span class="pre">cluster</span> <span class="pre">replicate</span></tt> 命令之后，
我们可以使用以下命令来确认 <tt class="docutils literal"><span class="pre">127.0.0.1:7006</span></tt> 已经成为了 ID 为 <tt class="docutils literal"><span class="pre">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span></tt> 的节点的从节点：</p>
<div class="highlight-python"><div class="highlight"><pre>$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">3c3a0c...</span></tt> 现在有两个从节点，
一个从节点的端口号为 <tt class="docutils literal"><span class="pre">7002</span></tt> ，
而另一个从节点的端口号为 <tt class="docutils literal"><span class="pre">7006</span></tt> 。</p>
</div>
<div class="section" id="id15">
<h4>移除一个节点<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>未完待续。</p>
</div>
</div>
</div>
</td>
<td><div class="toctree-wrapper first last compound">
<span id="document-topic/cluster-spec"></span><div class="section" id="redis">
<span id="cluster-spec"></span><h3>Redis 集群规范<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本文档翻译自 <a class="reference external" href="http://redis.io/topics/cluster-spec">http://redis.io/topics/cluster-spec</a> 。</p>
</div>
<div class="section" id="id1">
<h4>引言<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>这个文档是正在开发中的 Redis 集群功能的规范（specification）文档，
文档分为两个部分：</p>
<ul class="simple">
<li>第一部分介绍目前已经在 <tt class="docutils literal"><span class="pre">unstable</span></tt> 分支中实现了的那些功能。</li>
<li>第二部分介绍目前仍未实现的那些功能。</li>
</ul>
<p>文档各个部分的内容可能会随着集群功能的设计修改而发生改变，
其中，
未实现功能发生修改的几率比已实现功能发生修改的几率要高。</p>
<p>这个规范包含了编写客户端库（client library）所需的全部知识，
不过请注意，
这里列出的一部分细节可能会在未来发生变化。</p>
</div>
<div class="section" id="id2">
<h4>什么是 Redis 集群？<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现，
集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。</p>
<p>Redis 集群中不存在中心（central）节点或者代理（proxy）节点，
集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。</p>
<p>Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性：
系统会在保证对网络断线（net split）和节点失效（node failure）具有有限（limited）抵抗力的前提下，
尽可能地保持数据的一致性。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">集群将节点失效视为网络断线的其中一种特殊情况。</p>
</div>
<p>集群的容错功能是通过使用主节点（master）和从节点（slave）两种角色（role）的节点（node）来实现的：</p>
<ul class="simple">
<li>主节点和从节点使用完全相同的服务器实现，
它们的功能（functionally）也完全一样，
但从节点通常仅用于替换失效的主节点。</li>
<li>不过，
如果不需要保证“先写入，后读取”操作的一致性（read-after-write consistency），
那么可以使用从节点来执行只读查询。</li>
</ul>
</div>
<div class="section" id="id3">
<h4>Redis 集群实现的功能子集<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群实现了单机 Redis 中，
所有处理单个数据库键的命令。</p>
<p>针对多个数据库键的复杂计算操作，
比如集合的并集操作、合集操作没有被实现，
那些理论上需要使用多个节点的多个数据库键才能完成的命令也没有被实现。</p>
<p>在将来，
用户也许可以通过 <a class="reference internal" href="index.html#migrate"><em>MIGRATE COPY</em></a> 命令，
在集群的计算节点（computation node）中执行针对多个数据库键的只读操作，
但集群本身不会去实现那些需要将多个数据库键在多个节点中移来移去的复杂多键命令。</p>
<p>Redis 集群不像单机 Redis 那样支持多数据库功能，
集群只使用默认的 <tt class="docutils literal"><span class="pre">0</span></tt> 号数据库，
并且不能使用 <a class="reference internal" href="index.html#select"><em>SELECT</em></a> 命令。</p>
</div>
<div class="section" id="id4">
<h4>Redis 集群协议中的客户端和服务器<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群中的节点有以下责任：</p>
<ul class="simple">
<li>持有键值对数据。</li>
<li>记录集群的状态，包括键到正确节点的映射（mapping keys to right nodes）。</li>
<li>自动发现其他节点，识别工作不正常的节点，并在有需要时，在从节点中选举出新的主节点。</li>
</ul>
<p>为了执行以上列出的任务，
集群中的每个节点都与其他节点建立起了“集群连接（cluster bus）”，
该连接是一个 TCP 连接，
使用二进制协议进行通讯。</p>
<p>节点之间使用 <a class="reference external" href="http://en.wikipedia.org/wiki/Gossip_protocol">Gossip 协议</a> 来进行以下工作：</p>
<ul class="simple">
<li>传播（propagate）关于集群的信息，以此来发现新的节点。</li>
<li>向其他节点发送 <tt class="docutils literal"><span class="pre">PING</span></tt> 数据包，以此来检查目标节点是否正常运作。</li>
<li>在特定事件发生时，发送集群信息。</li>
</ul>
<p>除此之外，
集群连接还用于在集群中发布或订阅信息。</p>
<p>因为集群节点不能代理（proxy）命令请求，
所以客户端应该在节点返回 <tt class="docutils literal"><span class="pre">-MOVED</span></tt> 或者 <tt class="docutils literal"><span class="pre">-ASK</span></tt> 转向（redirection）错误时，
自行将命令请求转发至其他节点。</p>
<p>因为客户端可以自由地向集群中的任何一个节点发送命令请求，
并可以在有需要时，
根据转向错误所提供的信息，
将命令转发至正确的节点，
所以在理论上来说，
客户端是无须保存集群状态信息的。</p>
<p>不过，
如果客户端可以将键和节点之间的映射信息保存起来，
可以有效地减少可能出现的转向次数，
籍此提升命令执行的效率。</p>
</div>
<div class="section" id="id5">
<h4>键分布模型<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群的键空间被分割为 <tt class="docutils literal"><span class="pre">16384</span></tt> 个槽（slot），
集群的最大节点数量也是 <tt class="docutils literal"><span class="pre">16384</span></tt> 个。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">推荐的最大节点数量为 1000 个左右。</p>
</div>
<p>每个主节点都负责处理 <tt class="docutils literal"><span class="pre">16384</span></tt> 个哈希槽的其中一部分。</p>
<p>当我们说一个集群处于“稳定”（stable）状态时，
指的是集群没有在执行重配置（reconfiguration）操作，
每个哈希槽都只由一个节点进行处理。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">重配置指的是将某个/某些槽从一个节点移动到另一个节点。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">一个主节点可以有任意多个从节点，
这些从节点用于在主节点发生网络断线或者节点失效时，
对主节点进行替换。</p>
</div>
<p>以下是负责将键映射到槽的算法：</p>
<div class="highlight-python"><div class="highlight"><pre>HASH_SLOT = CRC16(key) mod 16384
</pre></div>
</div>
<p>以下是该算法所使用的参数：</p>
<ul class="simple">
<li>算法的名称: XMODEM (又称 ZMODEM 或者 CRC-16/ACORN)</li>
<li>结果的长度: 16 位</li>
<li>多项数（poly）: 1021 (也即是 <tt class="docutils literal"><span class="pre">x16</span> <span class="pre">+</span> <span class="pre">x12</span> <span class="pre">+</span> <span class="pre">x5</span> <span class="pre">+</span> <span class="pre">1</span></tt>)</li>
<li>初始化值: <tt class="docutils literal"><span class="pre">0000</span></tt></li>
<li>反射输入字节（Reflect Input byte）: <tt class="docutils literal"><span class="pre">False</span></tt></li>
<li>发射输出 CRC （Reflect Output CRC）: <tt class="docutils literal"><span class="pre">False</span></tt></li>
<li>用于 CRC 输出值的异或常量（Xor constant to output CRC）: <tt class="docutils literal"><span class="pre">0000</span></tt></li>
<li>该算法对于输入 <tt class="docutils literal"><span class="pre">&quot;123456789&quot;</span></tt> 的输出: <tt class="docutils literal"><span class="pre">31C3</span></tt></li>
</ul>
<p>附录 A 中给出了集群所使用的 CRC16 算法的实现。</p>
<p>CRC16 算法所产生的 16 位输出中的 14 位会被用到。</p>
<p>在我们的测试中，
CRC16 算法可以很好地将各种不同类型的键平稳地分布到 <tt class="docutils literal"><span class="pre">16384</span></tt> 个槽里面。</p>
</div>
<div class="section" id="id6">
<h4>集群节点属性<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>每个节点在集群中都有一个独一无二的 ID ，
该 ID 是一个十六进制表示的 160 位随机数，
在节点第一次启动时由 <tt class="docutils literal"><span class="pre">/dev/urandom</span></tt> 生成。</p>
<p>节点会将它的 ID 保存到配置文件，
只要这个配置文件不被删除，
节点就会一直沿用这个 ID 。</p>
<p>节点 ID 用于标识集群中的每个节点。
一个节点可以改变它的 IP 和端口号，
而不改变节点 ID 。
集群可以自动识别出 IP/端口号的变化，
并将这一信息通过 Gossip 协议广播给其他节点知道。</p>
<p>以下是每个节点都有的关联信息，
并且节点会将这些信息发送给其他节点：</p>
<ul class="simple">
<li>节点所使用的 IP 地址和 TCP 端口号。</li>
<li>节点的标志（flags）。</li>
<li>节点负责处理的哈希槽。</li>
<li>节点最近一次使用集群连接发送 <tt class="docutils literal"><span class="pre">PING</span></tt> 数据包（packet）的时间。</li>
<li>节点最近一次在回复中接收到 <tt class="docutils literal"><span class="pre">PONG</span></tt> 数据包的时间。</li>
<li>集群将该节点标记为下线的时间。</li>
<li>该节点的从节点数量。</li>
<li>如果该节点是从节点的话，那么它会记录主节点的节点 ID 。
如果这是一个主节点的话，那么主节点 ID 这一栏的值为 <tt class="docutils literal"><span class="pre">0000000</span></tt> 。</li>
</ul>
<p>以上信息的其中一部分可以通过向集群中的任意节点（主节点或者从节点都可以）发送 <tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">NODES</span></tt> 命令来获得。</p>
<p>以下是一个向集群中的主节点发送 <tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">NODES</span></tt> 命令的例子，
该集群由三个节点组成：</p>
<div class="highlight-python"><div class="highlight"><pre>$ redis-cli cluster nodes
d1861060fe6a534d42d8a19aeb36600e18785e04 :0 myself - 0 1318428930 connected 0-1364
3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 connected 1365-2729
d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 connected 2730-4095
</pre></div>
</div>
<p>在上面列出的三行信息中，
从左到右的各个域分别是：
节点 ID ，
IP 地址和端口号，
标志（flag），
最后发送 <tt class="docutils literal"><span class="pre">PING</span></tt> 的时间，
最后接收 <tt class="docutils literal"><span class="pre">PONG</span></tt> 的时间，
连接状态，
节点负责处理的槽。</p>
</div>
<div class="section" id="id7">
<h4>节点握手（已实现）<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>节点总是应答（accept）来自集群连接端口的连接请求，
并对接收到的 <tt class="docutils literal"><span class="pre">PING</span></tt> 数据包进行回复，
即使这个 <tt class="docutils literal"><span class="pre">PING</span></tt> 数据包来自不可信的节点。</p>
<p>然而，
除了 <tt class="docutils literal"><span class="pre">PING</span></tt> 之外，
节点会拒绝其他所有并非来自集群节点的数据包。</p>
<p>要让一个节点承认另一个节点同属于一个集群，
只有以下两种方法：</p>
<ul class="simple">
<li>一个节点可以通过向另一个节点发送 <tt class="docutils literal"><span class="pre">MEET</span></tt> 信息，
来强制让接收信息的节点承认发送信息的节点为集群中的一份子。
一个节点仅在管理员显式地向它发送 <tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">MEET</span> <span class="pre">ip</span> <span class="pre">port</span></tt> 命令时，
才会向另一个节点发送 <tt class="docutils literal"><span class="pre">MEET</span></tt> 信息。</li>
<li>另外，
如果一个可信节点向另一个节点传播第三者节点的信息，
那么接收信息的那个节点也会将第三者节点识别为集群中的一份子。
也即是说，
如果 A 认识 B ，
B 认识 C ，
并且 B 向 A 传播关于 C 的信息，
那么 A 也会将 C 识别为集群中的一份子，
并尝试连接 C 。</li>
</ul>
<p>这意味着如果我们将一个/一些新节点添加到一个集群中，
那么这个/这些新节点最终会和集群中已有的其他所有节点连接起来。</p>
<p>这说明只要管理员使用 <tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">MEET</span></tt> 命令显式地指定了可信关系，
集群就可以自动发现其他节点。</p>
<p>这种节点识别机制通过防止不同的 Redis 集群因为 IP 地址变更或者其他网络事件的发生而产生意料之外的联合（mix），
从而使得集群更具健壮性。</p>
<p>当节点的网络连接断开时，
它会主动连接其他已知的节点。</p>
</div>
<div class="section" id="moved">
<h4>MOVED 转向<a class="headerlink" href="#moved" title="Permalink to this headline">¶</a></h4>
<p>一个 Redis 客户端可以向集群中的任意节点（包括从节点）发送命令请求。
节点会对命令请求进行分析，
如果该命令是集群可以执行的命令，
那么节点会查找这个命令所要处理的键所在的槽。</p>
<p>如果要查找的哈希槽正好就由接收到命令的节点负责处理，
那么节点就直接执行这个命令。</p>
<p>另一方面，
如果所查找的槽不是由该节点处理的话，
节点将查看自身内部所保存的哈希槽到节点 ID 的映射记录，
并向客户端回复一个 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 错误。</p>
<p>以下是一个 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 错误的例子：</p>
<div class="highlight-python"><div class="highlight"><pre>GET x

-MOVED 3999 127.0.0.1:6381
</pre></div>
</div>
<p>错误信息包含键 <tt class="docutils literal"><span class="pre">x</span></tt> 所属的哈希槽 <tt class="docutils literal"><span class="pre">3999</span></tt> ，
以及负责处理这个槽的节点的 IP 和端口号 <tt class="docutils literal"><span class="pre">127.0.0.1:6381</span></tt> 。
客户端需要根据这个 IP 和端口号，
向所属的节点重新发送一次 <a class="reference internal" href="index.html#get"><em>GET</em></a> 命令请求。</p>
<p>注意，
即使客户端在重新发送 <a class="reference internal" href="index.html#get"><em>GET</em></a> 命令之前，
等待了非常久的时间，
以至于集群又再次更改了配置，
使得节点 <tt class="docutils literal"><span class="pre">127.0.0.1:6381</span></tt> 已经不再处理槽 <tt class="docutils literal"><span class="pre">3999</span></tt> ，
那么当客户端向节点 <tt class="docutils literal"><span class="pre">127.0.0.1:6381</span></tt> 发送 <a class="reference internal" href="index.html#get"><em>GET</em></a> 命令的时候，
节点将再次向客户端返回 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 错误，
指示现在负责处理槽 <tt class="docutils literal"><span class="pre">3999</span></tt> 的节点。</p>
<p>虽然我们用 ID 来标识集群中的节点，
但是为了让客户端的转向操作尽可能地简单，
节点在 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 错误中直接返回目标节点的 IP 和端口号，
而不是目标节点的 ID 。</p>
<p>虽然不是必须的，
但一个客户端应该记录（memorize）下“槽 <tt class="docutils literal"><span class="pre">3999</span></tt> 由节点 <tt class="docutils literal"><span class="pre">127.0.0.1:6381</span></tt> 负责处理“这一信息，
这样当再次有命令需要对槽 <tt class="docutils literal"><span class="pre">3999</span></tt> 执行时，
客户端就可以加快寻找正确节点的速度。</p>
<p>注意，
当集群处于稳定状态时，
所有客户端最终都会保存有一个哈希槽至节点的映射记录（map of hash slots to nodes），
使得集群非常高效：
客户端可以直接向正确的节点发送命令请求，
无须转向、代理或者其他任何可能发生单点故障（single point failure）的实体（entiy）。</p>
<p>除了 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 转向错误之外，
一个客户端还应该可以处理稍后介绍的 <tt class="docutils literal"><span class="pre">ASK</span></tt> 转向错误。</p>
</div>
<div class="section" id="live-reconfiguration">
<h4>集群在线重配置（live reconfiguration）<a class="headerlink" href="#live-reconfiguration" title="Permalink to this headline">¶</a></h4>
<p>Redis 集群支持在集群运行的过程中添加或者移除节点。</p>
<p>实际上，
节点的添加操作和节点的删除操作可以抽象成同一个操作，
那就是，
将哈希槽从一个节点移动到另一个节点：</p>
<ul class="simple">
<li>添加一个新节点到集群，
等于将其他已存在节点的槽移动到一个空白的新节点里面。</li>
<li>从集群中移除一个节点，
等于将被移除节点的所有槽移动到集群的其他节点上面去。</li>
</ul>
<p>因此，
实现 Redis 集群在线重配置的核心就是将槽从一个节点移动到另一个节点的能力。
因为一个哈希槽实际上就是一些键的集合，
所以 Redis 集群在重哈希（rehash）时真正要做的，
就是将一些键从一个节点移动到另一个节点。</p>
<p>要理解 Redis 集群如何将槽从一个节点移动到另一个节点，
我们需要对 <tt class="docutils literal"><span class="pre">CLUSTER</span></tt> 命令的各个子命令进行介绍，
这些命理负责管理集群节点的槽转换表（slots translation table）。</p>
<p>以下是 <tt class="docutils literal"><span class="pre">CLUSTER</span></tt> 命令可用的子命令：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">ADDSLOTS</span> <span class="pre">slot1</span> <span class="pre">[slot2]</span> <span class="pre">...</span> <span class="pre">[slotN]</span></tt></li>
<li><tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">DELSLOTS</span> <span class="pre">slot1</span> <span class="pre">[slot2]</span> <span class="pre">...</span> <span class="pre">[slotN]</span></tt></li>
<li><tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">SETSLOT</span> <span class="pre">slot</span> <span class="pre">NODE</span> <span class="pre">node</span></tt></li>
<li><tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">SETSLOT</span> <span class="pre">slot</span> <span class="pre">MIGRATING</span> <span class="pre">node</span></tt></li>
<li><tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">SETSLOT</span> <span class="pre">slot</span> <span class="pre">IMPORTING</span> <span class="pre">node</span></tt></li>
</ul>
<p>最开头的两条命令 <tt class="docutils literal"><span class="pre">ADDSLOTS</span></tt> 和 <tt class="docutils literal"><span class="pre">DELSLOTS</span></tt> 分别用于向节点指派（assign）或者移除节点，
当槽被指派或者移除之后，
节点会将这一信息通过 Gossip 协议传播到整个集群。
<tt class="docutils literal"><span class="pre">ADDSLOTS</span></tt> 命令通常在新创建集群时，
作为一种快速地将各个槽指派给各个节点的手段来使用。</p>
<p><tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">SETSLOT</span> <span class="pre">slot</span> <span class="pre">NODE</span> <span class="pre">node</span></tt> 子命令可以将指定的槽 <tt class="docutils literal"><span class="pre">slot</span></tt> 指派给节点 <tt class="docutils literal"><span class="pre">node</span></tt> 。</p>
<p>至于 <tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">SETSLOT</span> <span class="pre">slot</span> <span class="pre">MIGRATING</span> <span class="pre">node</span></tt> 命令和 <tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">SETSLOT</span> <span class="pre">slot</span> <span class="pre">IMPORTING</span> <span class="pre">node</span></tt> 命令，
前者用于将给定节点 <tt class="docutils literal"><span class="pre">node</span></tt> 中的槽 <tt class="docutils literal"><span class="pre">slot</span></tt> 迁移出节点，
而后者用于将给定槽 <tt class="docutils literal"><span class="pre">slot</span></tt> 导入到节点 <tt class="docutils literal"><span class="pre">node</span></tt> ：</p>
<ul>
<li><p class="first">当一个槽被设置为 <tt class="docutils literal"><span class="pre">MIGRATING</span></tt> 状态时，
原来持有这个槽的节点仍然会继续接受关于这个槽的命令请求，
但只有命令所处理的键仍然存在于节点时，
节点才会处理这个命令请求。</p>
<p>如果命令所使用的键不存在与该节点，
那么节点将向客户端返回一个 <tt class="docutils literal"><span class="pre">-ASK</span></tt> 转向（redirection）错误，
告知客户端，
要将命令请求发送到槽的迁移目标节点。</p>
</li>
<li><p class="first">当一个槽被设置为 <tt class="docutils literal"><span class="pre">IMPORTING</span></tt> 状态时，
节点仅在接收到 <tt class="docutils literal"><span class="pre">ASKING</span></tt> 命令之后，
才会接受关于这个槽的命令请求。</p>
<p>如果客户端没有向节点发送 <tt class="docutils literal"><span class="pre">ASKING</span></tt> 命令，
那么节点会使用 <tt class="docutils literal"><span class="pre">-MOVED</span></tt> 转向错误将命令请求转向至真正负责处理这个槽的节点。</p>
</li>
</ul>
<p>上面关于 <tt class="docutils literal"><span class="pre">MIGRATING</span></tt> 和 <tt class="docutils literal"><span class="pre">IMPORTING</span></tt> 的说明有些难懂，
让我们用一个实际的实例来说明一下。</p>
<p>假设现在，
我们有 A 和 B 两个节点，
并且我们想将槽 <tt class="docutils literal"><span class="pre">8</span></tt> 从节点 A 移动到节点 B ，
于是我们：</p>
<ul class="simple">
<li>向节点 B 发送命令 <tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">SETSLOT</span> <span class="pre">8</span> <span class="pre">IMPORTING</span> <span class="pre">A</span></tt></li>
<li>向节点 A 发送命令 <tt class="docutils literal"><span class="pre">CLUSTER</span> <span class="pre">SETSLOT</span> <span class="pre">8</span> <span class="pre">MIGRATING</span> <span class="pre">B</span></tt></li>
</ul>
<p>每当客户端向其他节点发送关于哈希槽 <tt class="docutils literal"><span class="pre">8</span></tt> 的命令请求时，
这些节点都会向客户端返回指向节点 A 的转向信息：</p>
<ul class="simple">
<li>如果命令要处理的键已经存在于槽 <tt class="docutils literal"><span class="pre">8</span></tt> 里面，
那么这个命令将由节点 A 处理。</li>
<li>如果命令要处理的键未存在于槽 <tt class="docutils literal"><span class="pre">8</span></tt> 里面（比如说，要向槽添加一个新的键），
那么这个命令由节点 B 处理。</li>
</ul>
<p>这种机制将使得节点 A 不再创建关于槽 <tt class="docutils literal"><span class="pre">8</span></tt> 的任何新键。</p>
<p>与此同时，
一个特殊的客户端 <tt class="docutils literal"><span class="pre">redis-trib</span></tt> 以及 Redis 集群配置程序（configuration utility）会将节点 A 中槽 <tt class="docutils literal"><span class="pre">8</span></tt> 里面的键移动到节点 B 。</p>
<p>键的移动操作由以下两个命令执行：</p>
<div class="highlight-python"><div class="highlight"><pre>CLUSTER GETKEYSINSLOT slot count
</pre></div>
</div>
<p>上面的命令会让节点返回 <tt class="docutils literal"><span class="pre">count</span></tt> 个 <tt class="docutils literal"><span class="pre">slot</span></tt> 槽中的键，
对于命令所返回的每个键，
<tt class="docutils literal"><span class="pre">redis-trib</span></tt> 都会向节点 A 发送一条 <a class="reference internal" href="index.html#migrate"><em>MIGRATE</em></a> 命令，
该命令会将所指定的键原子地（atomic）从节点 A 移动到节点 B
（在移动键期间，两个节点都会处于阻塞状态，以免出现竞争条件）。</p>
<p>以下为 <a class="reference internal" href="index.html#migrate"><em>MIGRATE</em></a> 命令的运作原理：</p>
<div class="highlight-python"><div class="highlight"><pre>MIGRATE target_host target_port key target_database id timeout
</pre></div>
</div>
<p>执行 <a class="reference internal" href="index.html#migrate"><em>MIGRATE</em></a> 命令的节点会连接到 <tt class="docutils literal"><span class="pre">target</span></tt> 节点，
并将序列化后的 <tt class="docutils literal"><span class="pre">key</span></tt> 数据发送给 <tt class="docutils literal"><span class="pre">target</span></tt> ，
一旦 <tt class="docutils literal"><span class="pre">target</span></tt> 返回 <tt class="docutils literal"><span class="pre">OK</span></tt> ，
节点就将自己的 <tt class="docutils literal"><span class="pre">key</span></tt> 从数据库中删除。</p>
<p>从一个外部客户端的视角来看，
在某个时间点上，
键 <tt class="docutils literal"><span class="pre">key</span></tt> 要么存在于节点 A ，
要么存在于节点 B ，
但不会同时存在于节点 A 和节点 B 。</p>
<p>因为 Redis 集群只使用 <tt class="docutils literal"><span class="pre">0</span></tt> 号数据库，
所以当 <a class="reference internal" href="index.html#migrate"><em>MIGRATE</em></a> 命令被用于执行集群操作时，
<tt class="docutils literal"><span class="pre">target_database</span></tt> 的值总是 <tt class="docutils literal"><span class="pre">0</span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre">target_database</span></tt> 参数的存在是为了让 <a class="reference internal" href="index.html#migrate"><em>MIGRATE</em></a> 命令成为一个通用命令，
从而可以作用于集群以外的其他功能。</p>
<p>我们对 <a class="reference internal" href="index.html#migrate"><em>MIGRATE</em></a> 命令做了优化，
使得它即使在传输包含多个元素的列表键这样的复杂数据时，
也可以保持高效。</p>
<p>不过，
尽管 <a class="reference internal" href="index.html#migrate"><em>MIGRATE</em></a> 非常高效，
对一个键非常多、并且键的数据量非常大的集群来说，
集群重配置还是会占用大量的时间，
可能会导致集群没办法适应那些对于响应时间有严格要求的应用程序。</p>
</div>
<div class="section" id="ask">
<h4>ASK 转向<a class="headerlink" href="#ask" title="Permalink to this headline">¶</a></h4>
<p>在之前介绍 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 转向的时候，
我们说除了 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 转向之外，
还有另一种 <tt class="docutils literal"><span class="pre">ASK</span></tt> 转向。</p>
<p>当节点需要让一个客户端长期地（permanently）将针对某个槽的命令请求发送至另一个节点时，
节点向客户端返回 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 转向。</p>
<p>另一方面，
当节点需要让客户端仅仅在下一个命令请求中转向至另一个节点时，
节点向客户端返回 <tt class="docutils literal"><span class="pre">ASK</span></tt> 转向。</p>
<p>比如说，
在我们上一节列举的槽 <tt class="docutils literal"><span class="pre">8</span></tt> 的例子中，
因为槽 <tt class="docutils literal"><span class="pre">8</span></tt> 所包含的各个键分散在节点 A 和节点 B 中，
所以当客户端在节点 A 中没找到某个键时，
它应该转向到节点 B 中去寻找，
但是这种转向应该仅仅影响一次命令查询，
而不是让客户端每次都直接去查找节点 B ：
在节点 A 所持有的属于槽 <tt class="docutils literal"><span class="pre">8</span></tt> 的键没有全部被迁移到节点 B 之前，
客户端应该先访问节点 A ，
然后再访问节点 B 。</p>
<p>因为这种转向只针对 <tt class="docutils literal"><span class="pre">16384</span></tt> 个槽中的其中一个槽，
所以转向对集群造成的性能损耗属于可接受的范围。</p>
<p>因为上述原因，
如果我们要在查找节点 A 之后，
继续查找节点 B ，
那么客户端在向节点 B 发送命令请求之前，
应该先发送一个 <tt class="docutils literal"><span class="pre">ASKING</span></tt> 命令，
否则这个针对带有 <tt class="docutils literal"><span class="pre">IMPORTING</span></tt> 状态的槽的命令请求将被节点 B 拒绝执行。</p>
<p>接收到客户端 <tt class="docutils literal"><span class="pre">ASKING</span></tt> 命令的节点将为客户端设置一个一次性的标志（flag），
使得客户端可以执行一次针对 <tt class="docutils literal"><span class="pre">IMPORTING</span></tt> 状态的槽的命令请求。</p>
<p>从客户端的角度来看，
<tt class="docutils literal"><span class="pre">ASK</span></tt> 转向的完整语义（semantics）如下：</p>
<ul class="simple">
<li>如果客户端接收到 <tt class="docutils literal"><span class="pre">ASK</span></tt> 转向，
那么将命令请求的发送对象调整为转向所指定的节点。</li>
<li>先发送一个 <tt class="docutils literal"><span class="pre">ASKING</span></tt> 命令，然后再发送真正的命令请求。</li>
<li>不必更新客户端所记录的槽 <tt class="docutils literal"><span class="pre">8</span></tt> 至节点的映射：
槽 <tt class="docutils literal"><span class="pre">8</span></tt> 应该仍然映射到节点 A ，
而不是节点 B 。</li>
</ul>
<p>一旦节点 A 针对槽 <tt class="docutils literal"><span class="pre">8</span></tt> 的迁移工作完成，
节点 A 在再次收到针对槽 <tt class="docutils literal"><span class="pre">8</span></tt> 的命令请求时，
就会向客户端返回 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 转向，
将关于槽  <tt class="docutils literal"><span class="pre">8</span></tt> 的命令请求长期地转向到节点 B 。</p>
<p>注意，
即使客户端出现 Bug ，
过早地将槽 <tt class="docutils literal"><span class="pre">8</span></tt> 映射到了节点 B 上面，
但只要这个客户端不发送 <tt class="docutils literal"><span class="pre">ASKING</span></tt> 命令，
客户端发送命令请求的时候就会遇上 <tt class="docutils literal"><span class="pre">MOVED</span></tt> 错误，
并将它转向回节点 A 。</p>
</div>
<div class="section" id="id8">
<h4>容错<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id9">
<h5>节点失效检测<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>以下是节点失效检查的实现方法：</p>
<ul>
<li><p class="first">当一个节点向另一个节点发送 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令，
但是目标节点未能在给定的时限内返回 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令的回复时，
那么发送命令的节点会将目标节点标记为 <tt class="docutils literal"><span class="pre">PFAIL</span></tt> （possible failure，可能已失效）。</p>
<p>等待 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令回复的时限称为“节点超时时限（node timeout）”，
是一个节点选项（node-wise setting）。</p>
</li>
<li><p class="first">每次当节点对其他节点发送 <a class="reference internal" href="index.html#ping"><em>PING</em></a> 命令的时候，
它都会随机地广播三个它所知道的节点的信息，
这些信息里面的其中一项就是说明节点是否已经被标记为 <tt class="docutils literal"><span class="pre">PFAIL</span></tt> 或者 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 。</p>
</li>
<li><p class="first">当节点接收到其他节点发来的信息时，
它会记下那些被其他节点标记为失效的节点。
这称为失效报告（failure report）。</p>
</li>
<li><p class="first">如果节点已经将某个节点标记为 <tt class="docutils literal"><span class="pre">PFAIL</span></tt> ，
并且根据节点所收到的失效报告显式，
集群中的大部分其他主节点也认为那个节点进入了失效状态，
那么节点会将那个失效节点的状态标记为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 。</p>
</li>
<li><p class="first">一旦某个节点被标记为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> ，
关于这个节点已失效的信息就会被广播到整个集群，
所有接收到这条信息的节点都会将失效节点标记为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 。</p>
</li>
</ul>
<p>简单来说，
一个节点要将另一个节点标记为失效，
必须先询问其他节点的意见，
并且得到大部分主节点的同意才行。</p>
<p>因为过期的失效报告会被移除，
所以主节点要将某个节点标记为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 的话，
必须以最近接收到的失效报告作为根据。</p>
<p>在以下两种情况中，
节点的 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态会被移除：</p>
<ul>
<li><p class="first">如果被标记为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 的是从节点，
那么当这个节点重新上线时，
<tt class="docutils literal"><span class="pre">FAIL</span></tt> 标记就会被移除。</p>
<p>保持（retaning）从节点的 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态是没有意义的，
因为它不处理任何槽，
一个从节点是否处于 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态，
决定了这个从节点在有需要时能否被提升为主节点。</p>
</li>
<li><p class="first">如果一个主节点被打上 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 标记之后，
经过了节点超时时限的四倍时间，
再加上十秒钟之后，
针对这个主节点的槽的故障转移操作仍未完成，
并且这个主节点已经重新上线的话，
那么移除对这个节点的 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 标记。</p>
</li>
</ul>
<p>在第二种情况中，
如果故障转移未能顺利完成，
并且主节点重新上线，
那么集群就继续使用原来的主节点，
从而免去管理员介入的必要。</p>
</div>
<div class="section" id="id10">
<h5>集群状态检测（已部分实现）<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>每当集群发生配置变化时（可能是哈希槽更新，也可能是某个节点进入失效状态），
集群中的每个节点都会对它所知道的节点进行扫描（scan）。</p>
<p>一旦配置处理完毕，
集群会进入以下两种状态的其中一种：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">FAIL</span></tt> ：
集群不能正常工作。
当集群中有某个节点进入失效状态时，
集群不能处理任何命令请求，
对于每个命令请求，
集群节点都返回错误回复。</li>
<li><tt class="docutils literal"><span class="pre">OK</span></tt> ：
集群可以正常工作，
负责处理全部 <tt class="docutils literal"><span class="pre">16384</span></tt> 个槽的节点中，
没有一个节点被标记为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态。</li>
</ul>
<p>这说明即使集群中只有一部分哈希槽不能正常使用，
整个集群也会停止处理任何命令。</p>
<p>不过节点从出现问题到被标记为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态的这段时间里，
集群仍然会正常运作，
所以集群在某些时候，
仍然有可能只能处理针对 <tt class="docutils literal"><span class="pre">16384</span></tt> 个槽的其中一个子集的命令请求。</p>
<p>以下是集群进入 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态的两种情况：</p>
<ol class="arabic simple">
<li>至少有一个哈希槽不可用，因为负责处理这个槽的节点进入了 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态。</li>
<li>集群中的大部分主节点都进入下线状态。当大部分主节点都进入 <tt class="docutils literal"><span class="pre">PFAIL</span></tt> 状态时，集群也会进入 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态。</li>
</ol>
<p>第二个检查是必须的，
因为要将一个节点从 <tt class="docutils literal"><span class="pre">PFAIL</span></tt> 状态改变为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态，
必须要有大部分主节点进行投票表决，
但是，
当集群中的大部分主节点都进入失效状态时，
单凭一个两个节点是没有办法将一个节点标记为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态的。</p>
<p>因此，
有了第二个检查条件，
只要集群中的大部分主节点进入了下线状态，
那么集群就可以在不请求这些主节点的意见下，
将某个节点判断为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态，
从而让整个集群停止处理命令请求。</p>
</div>
<div class="section" id="id11">
<h5>从节点选举<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>一旦某个主节点进入 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态，
如果这个主节点有一个或多个从节点存在，
那么其中一个从节点会被升级为新的主节点，
而其他从节点则会开始对这个新的主节点进行复制。</p>
<p>新的主节点由已下线主节点属下的所有从节点中自行选举产生，
以下是选举的条件：</p>
<ul class="simple">
<li>这个节点是已下线主节点的从节点。</li>
<li>已下线主节点负责处理的槽数量非空。</li>
<li>从节点的数据被认为是可靠的，
也即是，
主从节点之间的复制连接（replication link）的断线时长不能超过节点超时时限（node timeout）乘以 <tt class="docutils literal"><span class="pre">REDIS_CLUSTER_SLAVE_VALIDITY_MULT</span></tt> 常量得出的积。</li>
</ul>
<p>如果一个从节点满足了以上的所有条件，
那么这个从节点将向集群中的其他主节点发送授权请求，
询问它们，
是否允许自己（从节点）升级为新的主节点。</p>
<p>如果发送授权请求的从节点满足以下属性，
那么主节点将向从节点返回 <tt class="docutils literal"><span class="pre">FAILOVER_AUTH_GRANTED</span></tt> 授权，
同意从节点的升级要求：</p>
<ul class="simple">
<li>发送授权请求的是一个从节点，
并且它所属的主节点处于 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态。</li>
<li>在已下线主节点的所有从节点中，
这个从节点的节点 ID 在排序中是最小的。</li>
<li>这个从节点处于正常的运行状态：
它没有被标记为 <tt class="docutils literal"><span class="pre">FAIL</span></tt> 状态，
也没有被标记为 <tt class="docutils literal"><span class="pre">PFAIL</span></tt> 状态。</li>
</ul>
<p>一旦某个从节点在给定的时限内得到大部分主节点的授权，
它就会开始执行以下故障转移操作：</p>
<ul class="simple">
<li>通过 <tt class="docutils literal"><span class="pre">PONG</span></tt> 数据包（packet）告知其他节点，
这个节点现在是主节点了。</li>
<li>通过 <tt class="docutils literal"><span class="pre">PONG</span></tt> 数据包告知其他节点，
这个节点是一个已升级的从节点（promoted slave）。</li>
<li>接管（claiming）所有由已下线主节点负责处理的哈希槽。</li>
<li>显式地向所有节点广播一个 <tt class="docutils literal"><span class="pre">PONG</span></tt> 数据包，
加速其他节点识别这个节点的进度，
而不是等待定时的 <tt class="docutils literal"><span class="pre">PING</span></tt> / <tt class="docutils literal"><span class="pre">PONG</span></tt> 数据包。</li>
</ul>
<p>所有其他节点都会根据新的主节点对配置进行相应的更新，特别地：</p>
<ul class="simple">
<li>所有被新的主节点接管的槽会被更新。</li>
<li>已下线主节点的所有从节点会察觉到 <tt class="docutils literal"><span class="pre">PROMOTED</span></tt> 标志，
并开始对新的主节点进行复制。</li>
<li>如果已下线的主节点重新回到上线状态，
那么它会察觉到 <tt class="docutils literal"><span class="pre">PROMOTED</span></tt> 标志，
并将自身调整为现任主节点的从节点。</li>
</ul>
<p>在集群的生命周期中，
如果一个带有 <tt class="docutils literal"><span class="pre">PROMOTED</span></tt> 标识的主节点因为某些原因转变成了从节点，
那么该节点将丢失它所带有的 <tt class="docutils literal"><span class="pre">PROMOTED</span></tt> 标识。</p>
</div>
</div>
<div class="section" id="id12">
<h4>发布/订阅（已实现，但仍然需要改善）<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>在一个 Redis 集群中，
客户端可以订阅任意一个节点，
也可以向任意一个节点发送信息，
节点会对客户端所发送的信息进行转发。</p>
<p>在目前的实现中，
节点会将接收到的信息广播至集群中的其他所有节点，
在将来的实现中，
可能会使用 bloom filter 或者其他算法来优化这一操作。</p>
</div>
<div class="section" id="a-crc16-ansi">
<h4>附录 A： CRC16 算法的 ANSI 实现参考<a class="headerlink" href="#a-crc16-ansi" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>/*
 * Copyright 2001-2010 Georges Menie (www.menie.org)
 * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the University of California, Berkeley nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* CRC16 implementation acording to CCITT standards.
 *
 * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the
 * following parameters:
 *
 * Name                       : &quot;XMODEM&quot;, also known as &quot;ZMODEM&quot;, &quot;CRC-16/ACORN&quot;
 * Width                      : 16 bit
 * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)
 * Initialization             : 0000
 * Reflect Input byte         : False
 * Reflect Output CRC         : False
 * Xor constant to output CRC : 0000
 * Output for &quot;123456789&quot;     : 31C3
 */

static const uint16_t crc16tab[256]= {
    0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
    0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,
    0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,
    0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,
    0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,
    0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,
    0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,
    0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,
    0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,
    0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,
    0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,
    0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,
    0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,
    0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,
    0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,
    0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,
    0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,
    0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,
    0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,
    0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,
    0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,
    0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,
    0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,
    0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,
    0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,
    0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,
    0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,
    0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,
    0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,
    0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,
    0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
    0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
};

uint16_t crc16(const char *buf, int len) {
    int counter;
    uint16_t crc = 0;
    for (counter = 0; counter &lt; len; counter++)
            crc = (crc&lt;&lt;8) ^ crc16tab[((crc&gt;&gt;8) ^ *buf++)&amp;0x00FF];
    return crc;
}
</pre></div>
</div>
</div>
</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id2">
<h2>关于<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>本文档由 <a class="reference external" href="http://www.huangz.me">huangz</a> 翻译，
版权归 Redis 官方所有。</p>
<p>关注 <a class="reference external" href="https://github.com/huangz1990/redis">文档的 github 项目</a> 可以随时追踪文档的最新更新，
有任何问题、意见或建议，
可以在文档配套的 disqus 论坛里留言，
或者直接联系译者。</p>
</div>
<div class="section" id="id3">
<h2>通过捐款支持本文档<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>对 Redis 的文档更新进行追踪并及时地进行翻译需要花费大量的时间和精力，
如果你喜欢这个《Redis 命令参考》文档的话，
可以通过捐款的方式，
支持译者继续对 Redis 文档进行翻译，
并将这个文档更好地维护下去。</p>
<p>你可以通过使用<a class="reference external" href="https://mobile.alipay.com/main/download.htm?action=mobileClient">支付宝钱包</a>扫描以下二维码来进行捐款，
或者通过向支付宝帐号 <a class="reference external" href="mailto:huangz1990&#37;&#52;&#48;gmail&#46;com">huangz1990<span>&#64;</span>gmail<span>&#46;</span>com</a> 转帐来进行捐款。</p>
<img alt="_images/pay_to_huangz.png" src="_images/pay_to_huangz.png" />
</div>
</div>



            <div class="section" id="discuss">

    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redis-command-cn'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<div id="ad">
    <h2>广告</h2>
    <p>计算关于生命、宇宙以及一切的终极的答案。</p>
    <a href="http://vps.42qu.com" style="padding: 0px 0px 8px 20px;display: block;"><img src="_static/42qu.png"/></a>
    <a href="http://vps.42qu.com" style="font-weight: bold;padding-left: 20px;">42qu.com 主机空间</a>
    <ul>
        <li>中国 BGP 七线 / 美国五机房可选</li>
        <li>独立 IP / root 权限</li>
        <li><a href="http://www.vpsee.com/">vpsee</a> 专业技术支持</li>
        <li>XEN 虚拟机，<span style="font-weight: bold;">卖给创业的你</span></li>
    </ul>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="index.html#document-index">Redis 命令参考</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Redis.
      Last updated on Sep 08, 2014.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>